"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swiper";
exports.ids = ["vendor-chunks/swiper"];
exports.modules = {

/***/ "(ssr)/./node_modules/swiper/modules/navigation.css":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/navigation.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"64f3e2ab0cd4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvbmF2aWdhdGlvbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFnb25hbHMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvbmF2aWdhdGlvbi5jc3M/N2M3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjY0ZjNlMmFiMGNkNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/modules/navigation.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/modules/pagination.css":
/*!****************************************************!*\
  !*** ./node_modules/swiper/modules/pagination.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"bcdc1be3afcf\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvcGFnaW5hdGlvbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFnb25hbHMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL21vZHVsZXMvcGFnaW5hdGlvbi5jc3M/NmQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImJjZGMxYmUzYWZjZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/modules/pagination.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/swiper.css":
/*!****************************************!*\
  !*** ./node_modules/swiper/swiper.css ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"00d6101acdf3\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFnb25hbHMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci5jc3M/ZmQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjAwZDYxMDFhY2RmM1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/swiper.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getWindow),\n/* harmony export */   g: () => (/* binding */ getDocument)\n/* harmony export */ });\n/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */ /* eslint-disable no-param-reassign */ function isObject(obj) {\n    return obj !== null && typeof obj === \"object\" && \"constructor\" in obj && obj.constructor === Object;\n}\nfunction extend(target, src) {\n    if (target === void 0) {\n        target = {};\n    }\n    if (src === void 0) {\n        src = {};\n    }\n    Object.keys(src).forEach((key)=>{\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            extend(target[key], src[key]);\n        }\n    });\n}\nconst ssrDocument = {\n    body: {},\n    addEventListener () {},\n    removeEventListener () {},\n    activeElement: {\n        blur () {},\n        nodeName: \"\"\n    },\n    querySelector () {\n        return null;\n    },\n    querySelectorAll () {\n        return [];\n    },\n    getElementById () {\n        return null;\n    },\n    createEvent () {\n        return {\n            initEvent () {}\n        };\n    },\n    createElement () {\n        return {\n            children: [],\n            childNodes: [],\n            style: {},\n            setAttribute () {},\n            getElementsByTagName () {\n                return [];\n            }\n        };\n    },\n    createElementNS () {\n        return {};\n    },\n    importNode () {\n        return null;\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    }\n};\nfunction getDocument() {\n    const doc = typeof document !== \"undefined\" ? document : {};\n    extend(doc, ssrDocument);\n    return doc;\n}\nconst ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n        userAgent: \"\"\n    },\n    location: {\n        hash: \"\",\n        host: \"\",\n        hostname: \"\",\n        href: \"\",\n        origin: \"\",\n        pathname: \"\",\n        protocol: \"\",\n        search: \"\"\n    },\n    history: {\n        replaceState () {},\n        pushState () {},\n        go () {},\n        back () {}\n    },\n    CustomEvent: function CustomEvent() {\n        return this;\n    },\n    addEventListener () {},\n    removeEventListener () {},\n    getComputedStyle () {\n        return {\n            getPropertyValue () {\n                return \"\";\n            }\n        };\n    },\n    Image () {},\n    Date () {},\n    screen: {},\n    setTimeout () {},\n    clearTimeout () {},\n    matchMedia () {\n        return {};\n    },\n    requestAnimationFrame (callback) {\n        if (typeof setTimeout === \"undefined\") {\n            callback();\n            return null;\n        }\n        return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame (id) {\n        if (typeof setTimeout === \"undefined\") {\n            return;\n        }\n        clearTimeout(id);\n    }\n};\nfunction getWindow() {\n    const win =  false ? 0 : {};\n    extend(win, ssrWindow);\n    return win;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ0Qsb0NBQW9DLEdBQ3BDLFNBQVNBLFNBQVNDLEdBQUc7SUFDbkIsT0FBT0EsUUFBUSxRQUFRLE9BQU9BLFFBQVEsWUFBWSxpQkFBaUJBLE9BQU9BLElBQUlDLFdBQVcsS0FBS0M7QUFDaEc7QUFDQSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVDLEdBQUc7SUFDekIsSUFBSUQsV0FBVyxLQUFLLEdBQUc7UUFDckJBLFNBQVMsQ0FBQztJQUNaO0lBQ0EsSUFBSUMsUUFBUSxLQUFLLEdBQUc7UUFDbEJBLE1BQU0sQ0FBQztJQUNUO0lBQ0FILE9BQU9JLElBQUksQ0FBQ0QsS0FBS0UsT0FBTyxDQUFDQyxDQUFBQTtRQUN2QixJQUFJLE9BQU9KLE1BQU0sQ0FBQ0ksSUFBSSxLQUFLLGFBQWFKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHSCxHQUFHLENBQUNHLElBQUk7YUFBTSxJQUFJVCxTQUFTTSxHQUFHLENBQUNHLElBQUksS0FBS1QsU0FBU0ssTUFBTSxDQUFDSSxJQUFJLEtBQUtOLE9BQU9JLElBQUksQ0FBQ0QsR0FBRyxDQUFDRyxJQUFJLEVBQUVDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZKTixPQUFPQyxNQUFNLENBQUNJLElBQUksRUFBRUgsR0FBRyxDQUFDRyxJQUFJO1FBQzlCO0lBQ0Y7QUFDRjtBQUNBLE1BQU1FLGNBQWM7SUFDbEJDLE1BQU0sQ0FBQztJQUNQQyxxQkFBb0I7SUFDcEJDLHdCQUF1QjtJQUN2QkMsZUFBZTtRQUNiQyxTQUFRO1FBQ1JDLFVBQVU7SUFDWjtJQUNBQztRQUNFLE9BQU87SUFDVDtJQUNBQztRQUNFLE9BQU8sRUFBRTtJQUNYO0lBQ0FDO1FBQ0UsT0FBTztJQUNUO0lBQ0FDO1FBQ0UsT0FBTztZQUNMQyxjQUFhO1FBQ2Y7SUFDRjtJQUNBQztRQUNFLE9BQU87WUFDTEMsVUFBVSxFQUFFO1lBQ1pDLFlBQVksRUFBRTtZQUNkQyxPQUFPLENBQUM7WUFDUkMsaUJBQWdCO1lBQ2hCQztnQkFDRSxPQUFPLEVBQUU7WUFDWDtRQUNGO0lBQ0Y7SUFDQUM7UUFDRSxPQUFPLENBQUM7SUFDVjtJQUNBQztRQUNFLE9BQU87SUFDVDtJQUNBQyxVQUFVO1FBQ1JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxVQUFVO1FBQ1ZDLFVBQVU7UUFDVkMsUUFBUTtJQUNWO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLE1BQU0sT0FBT0MsYUFBYSxjQUFjQSxXQUFXLENBQUM7SUFDMUR0QyxPQUFPcUMsS0FBSzlCO0lBQ1osT0FBTzhCO0FBQ1Q7QUFDQSxNQUFNRSxZQUFZO0lBQ2hCRCxVQUFVL0I7SUFDVmlDLFdBQVc7UUFDVEMsV0FBVztJQUNiO0lBQ0FkLFVBQVU7UUFDUkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsVUFBVTtRQUNWQyxRQUFRO0lBQ1Y7SUFDQU8sU0FBUztRQUNQQyxpQkFBZ0I7UUFDaEJDLGNBQWE7UUFDYkMsT0FBTTtRQUNOQyxTQUFRO0lBQ1Y7SUFDQUMsYUFBYSxTQUFTQTtRQUNwQixPQUFPLElBQUk7SUFDYjtJQUNBdEMscUJBQW9CO0lBQ3BCQyx3QkFBdUI7SUFDdkJzQztRQUNFLE9BQU87WUFDTEM7Z0JBQ0UsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUNBQyxVQUFTO0lBQ1RDLFNBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLGVBQWM7SUFDZEMsaUJBQWdCO0lBQ2hCQztRQUNFLE9BQU8sQ0FBQztJQUNWO0lBQ0FDLHVCQUFzQkMsUUFBUTtRQUM1QixJQUFJLE9BQU9KLGVBQWUsYUFBYTtZQUNyQ0k7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxPQUFPSixXQUFXSSxVQUFVO0lBQzlCO0lBQ0FDLHNCQUFxQkMsRUFBRTtRQUNyQixJQUFJLE9BQU9OLGVBQWUsYUFBYTtZQUNyQztRQUNGO1FBQ0FDLGFBQWFLO0lBQ2Y7QUFDRjtBQUNBLFNBQVNDO0lBQ1AsTUFBTUMsTUFBTSxNQUFrQixHQUFjQyxDQUFNQSxHQUFHLENBQUM7SUFDdEQ5RCxPQUFPNkQsS0FBS3RCO0lBQ1osT0FBT3NCO0FBQ1Q7QUFFNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaWFnb25hbHMvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9zc3Itd2luZG93LmVzbS5tanM/ZTc4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNTUiBXaW5kb3cgNC4wLjJcbiAqIEJldHRlciBoYW5kbGluZyBmb3Igd2luZG93IG9iamVjdCBpbiBTU1IgZW52aXJvbm1lbnRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2xpbWl0czR3ZWIvc3NyLXdpbmRvd1xuICpcbiAqIENvcHlyaWdodCAyMDIxLCBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICpcbiAqIFJlbGVhc2VkIG9uOiBEZWNlbWJlciAxMywgMjAyMVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgdGFyZ2V0ID0ge307XG4gIH1cbiAgaWYgKHNyYyA9PT0gdm9pZCAwKSB7XG4gICAgc3JjID0ge307XG4gIH1cbiAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHRhcmdldFtrZXldID0gc3JjW2tleV07ZWxzZSBpZiAoaXNPYmplY3Qoc3JjW2tleV0pICYmIGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBPYmplY3Qua2V5cyhzcmNba2V5XSkubGVuZ3RoID4gMCkge1xuICAgICAgZXh0ZW5kKHRhcmdldFtrZXldLCBzcmNba2V5XSk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IHNzckRvY3VtZW50ID0ge1xuICBib2R5OiB7fSxcbiAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG4gIGFjdGl2ZUVsZW1lbnQ6IHtcbiAgICBibHVyKCkge30sXG4gICAgbm9kZU5hbWU6ICcnXG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBnZXRFbGVtZW50QnlJZCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY3JlYXRlRXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRFdmVudCgpIHt9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICBzdHlsZToge30sXG4gICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcbiAgICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudE5TKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgaW1wb3J0Tm9kZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgbG9jYXRpb246IHtcbiAgICBoYXNoOiAnJyxcbiAgICBob3N0OiAnJyxcbiAgICBob3N0bmFtZTogJycsXG4gICAgaHJlZjogJycsXG4gICAgb3JpZ2luOiAnJyxcbiAgICBwYXRobmFtZTogJycsXG4gICAgcHJvdG9jb2w6ICcnLFxuICAgIHNlYXJjaDogJydcbiAgfVxufTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICBjb25zdCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fTtcbiAgZXh0ZW5kKGRvYywgc3NyRG9jdW1lbnQpO1xuICByZXR1cm4gZG9jO1xufVxuY29uc3Qgc3NyV2luZG93ID0ge1xuICBkb2N1bWVudDogc3NyRG9jdW1lbnQsXG4gIG5hdmlnYXRvcjoge1xuICAgIHVzZXJBZ2VudDogJydcbiAgfSxcbiAgbG9jYXRpb246IHtcbiAgICBoYXNoOiAnJyxcbiAgICBob3N0OiAnJyxcbiAgICBob3N0bmFtZTogJycsXG4gICAgaHJlZjogJycsXG4gICAgb3JpZ2luOiAnJyxcbiAgICBwYXRobmFtZTogJycsXG4gICAgcHJvdG9jb2w6ICcnLFxuICAgIHNlYXJjaDogJydcbiAgfSxcbiAgaGlzdG9yeToge1xuICAgIHJlcGxhY2VTdGF0ZSgpIHt9LFxuICAgIHB1c2hTdGF0ZSgpIHt9LFxuICAgIGdvKCkge30sXG4gICAgYmFjaygpIHt9XG4gIH0sXG4gIEN1c3RvbUV2ZW50OiBmdW5jdGlvbiBDdXN0b21FdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9LFxuICByZW1vdmVFdmVudExpc3RlbmVyKCkge30sXG4gIGdldENvbXB1dGVkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFByb3BlcnR5VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBJbWFnZSgpIHt9LFxuICBEYXRlKCkge30sXG4gIHNjcmVlbjoge30sXG4gIHNldFRpbWVvdXQoKSB7fSxcbiAgY2xlYXJUaW1lb3V0KCkge30sXG4gIG1hdGNoTWVkaWEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgfSxcbiAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcbiAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRXaW5kb3coKSB7XG4gIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge307XG4gIGV4dGVuZCh3aW4sIHNzcldpbmRvdyk7XG4gIHJldHVybiB3aW47XG59XG5cbmV4cG9ydCB7IGdldFdpbmRvdyBhcyBhLCBnZXREb2N1bWVudCBhcyBnIH07XG4iXSwibmFtZXMiOlsiaXNPYmplY3QiLCJvYmoiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImV4dGVuZCIsInRhcmdldCIsInNyYyIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwibGVuZ3RoIiwic3NyRG9jdW1lbnQiLCJib2R5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsIm5vZGVOYW1lIiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRFbGVtZW50QnlJZCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY3JlYXRlRWxlbWVudCIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsInN0eWxlIiwic2V0QXR0cmlidXRlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVFbGVtZW50TlMiLCJpbXBvcnROb2RlIiwibG9jYXRpb24iLCJoYXNoIiwiaG9zdCIsImhvc3RuYW1lIiwiaHJlZiIsIm9yaWdpbiIsInBhdGhuYW1lIiwicHJvdG9jb2wiLCJzZWFyY2giLCJnZXREb2N1bWVudCIsImRvYyIsImRvY3VtZW50Iiwic3NyV2luZG93IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaGlzdG9yeSIsInJlcGxhY2VTdGF0ZSIsInB1c2hTdGF0ZSIsImdvIiwiYmFjayIsIkN1c3RvbUV2ZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJJbWFnZSIsIkRhdGUiLCJzY3JlZW4iLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibWF0Y2hNZWRpYSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGxiYWNrIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpZCIsImdldFdpbmRvdyIsIndpbiIsIndpbmRvdyIsImEiLCJnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/swiper-core.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/swiper-core.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ Swiper),\n/* harmony export */   d: () => (/* binding */ defaults)\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"(ssr)/./node_modules/swiper/shared/utils.mjs\");\n\n\nlet support;\nfunction calcSupport() {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    return {\n        smoothScroll: document1.documentElement && document1.documentElement.style && \"scrollBehavior\" in document1.documentElement.style,\n        touch: !!(\"ontouchstart\" in window1 || window1.DocumentTouch && document1 instanceof window1.DocumentTouch)\n    };\n}\nfunction getSupport() {\n    if (!support) {\n        support = calcSupport();\n    }\n    return support;\n}\nlet deviceCached;\nfunction calcDevice(_temp) {\n    let { userAgent } = _temp === void 0 ? {} : _temp;\n    const support = getSupport();\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const platform = window1.navigator.platform;\n    const ua = userAgent || window1.navigator.userAgent;\n    const device = {\n        ios: false,\n        android: false\n    };\n    const screenWidth = window1.screen.width;\n    const screenHeight = window1.screen.height;\n    const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n    let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    const windows = platform === \"Win32\";\n    let macos = platform === \"MacIntel\";\n    // iPadOs 13 fix\n    const iPadScreens = [\n        \"1024x1366\",\n        \"1366x1024\",\n        \"834x1194\",\n        \"1194x834\",\n        \"834x1112\",\n        \"1112x834\",\n        \"768x1024\",\n        \"1024x768\",\n        \"820x1180\",\n        \"1180x820\",\n        \"810x1080\",\n        \"1080x810\"\n    ];\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n        ipad = ua.match(/(Version)\\/([\\d.]+)/);\n        if (!ipad) ipad = [\n            0,\n            1,\n            \"13_0_0\"\n        ];\n        macos = false;\n    }\n    // Android\n    if (android && !windows) {\n        device.os = \"android\";\n        device.android = true;\n    }\n    if (ipad || iphone || ipod) {\n        device.os = \"ios\";\n        device.ios = true;\n    }\n    // Export object\n    return device;\n}\nfunction getDevice(overrides) {\n    if (overrides === void 0) {\n        overrides = {};\n    }\n    if (!deviceCached) {\n        deviceCached = calcDevice(overrides);\n    }\n    return deviceCached;\n}\nlet browser;\nfunction calcBrowser() {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let needPerspectiveFix = false;\n    function isSafari() {\n        const ua = window1.navigator.userAgent.toLowerCase();\n        return ua.indexOf(\"safari\") >= 0 && ua.indexOf(\"chrome\") < 0 && ua.indexOf(\"android\") < 0;\n    }\n    if (isSafari()) {\n        const ua = String(window1.navigator.userAgent);\n        if (ua.includes(\"Version/\")) {\n            const [major, minor] = ua.split(\"Version/\")[1].split(\" \")[0].split(\".\").map((num)=>Number(num));\n            needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n        }\n    }\n    return {\n        isSafari: needPerspectiveFix || isSafari(),\n        needPerspectiveFix,\n        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window1.navigator.userAgent)\n    };\n}\nfunction getBrowser() {\n    if (!browser) {\n        browser = calcBrowser();\n    }\n    return browser;\n}\nfunction Resize(_ref) {\n    let { swiper, on, emit } = _ref;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let observer = null;\n    let animationFrame = null;\n    const resizeHandler = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"beforeResize\");\n        emit(\"resize\");\n    };\n    const createObserver = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        observer = new ResizeObserver((entries)=>{\n            animationFrame = window1.requestAnimationFrame(()=>{\n                const { width, height } = swiper;\n                let newWidth = width;\n                let newHeight = height;\n                entries.forEach((_ref2)=>{\n                    let { contentBoxSize, contentRect, target } = _ref2;\n                    if (target && target !== swiper.el) return;\n                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n                });\n                if (newWidth !== width || newHeight !== height) {\n                    resizeHandler();\n                }\n            });\n        });\n        observer.observe(swiper.el);\n    };\n    const removeObserver = ()=>{\n        if (animationFrame) {\n            window1.cancelAnimationFrame(animationFrame);\n        }\n        if (observer && observer.unobserve && swiper.el) {\n            observer.unobserve(swiper.el);\n            observer = null;\n        }\n    };\n    const orientationChangeHandler = ()=>{\n        if (!swiper || swiper.destroyed || !swiper.initialized) return;\n        emit(\"orientationchange\");\n    };\n    on(\"init\", ()=>{\n        if (swiper.params.resizeObserver && typeof window1.ResizeObserver !== \"undefined\") {\n            createObserver();\n            return;\n        }\n        window1.addEventListener(\"resize\", resizeHandler);\n        window1.addEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n    on(\"destroy\", ()=>{\n        removeObserver();\n        window1.removeEventListener(\"resize\", resizeHandler);\n        window1.removeEventListener(\"orientationchange\", orientationChangeHandler);\n    });\n}\nfunction Observer(_ref) {\n    let { swiper, extendParams, on, emit } = _ref;\n    const observers = [];\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const attach = function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        const ObserverFunc = window1.MutationObserver || window1.WebkitMutationObserver;\n        const observer = new ObserverFunc((mutations)=>{\n            // The observerUpdate event should only be triggered\n            // once despite the number of mutations.  Additional\n            // triggers are redundant and are very costly\n            if (swiper.__preventObserver__) return;\n            if (mutations.length === 1) {\n                emit(\"observerUpdate\", mutations[0]);\n                return;\n            }\n            const observerUpdate = function observerUpdate() {\n                emit(\"observerUpdate\", mutations[0]);\n            };\n            if (window1.requestAnimationFrame) {\n                window1.requestAnimationFrame(observerUpdate);\n            } else {\n                window1.setTimeout(observerUpdate, 0);\n            }\n        });\n        observer.observe(target, {\n            attributes: typeof options.attributes === \"undefined\" ? true : options.attributes,\n            childList: typeof options.childList === \"undefined\" ? true : options.childList,\n            characterData: typeof options.characterData === \"undefined\" ? true : options.characterData\n        });\n        observers.push(observer);\n    };\n    const init = ()=>{\n        if (!swiper.params.observer) return;\n        if (swiper.params.observeParents) {\n            const containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.hostEl);\n            for(let i = 0; i < containerParents.length; i += 1){\n                attach(containerParents[i]);\n            }\n        }\n        // Observe container\n        attach(swiper.hostEl, {\n            childList: swiper.params.observeSlideChildren\n        });\n        // Observe wrapper\n        attach(swiper.wrapperEl, {\n            attributes: false\n        });\n    };\n    const destroy = ()=>{\n        observers.forEach((observer)=>{\n            observer.disconnect();\n        });\n        observers.splice(0, observers.length);\n    };\n    extendParams({\n        observer: false,\n        observeParents: false,\n        observeSlideChildren: false\n    });\n    on(\"init\", init);\n    on(\"destroy\", destroy);\n}\n/* eslint-disable no-underscore-dangle */ var eventsEmitter = {\n    on (events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        events.split(\" \").forEach((event)=>{\n            if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n            self.eventsListeners[event][method](handler);\n        });\n        return self;\n    },\n    once (events, handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        function onceHandler() {\n            self.off(events, onceHandler);\n            if (onceHandler.__emitterProxy) {\n                delete onceHandler.__emitterProxy;\n            }\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            handler.apply(self, args);\n        }\n        onceHandler.__emitterProxy = handler;\n        return self.on(events, onceHandler, priority);\n    },\n    onAny (handler, priority) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (typeof handler !== \"function\") return self;\n        const method = priority ? \"unshift\" : \"push\";\n        if (self.eventsAnyListeners.indexOf(handler) < 0) {\n            self.eventsAnyListeners[method](handler);\n        }\n        return self;\n    },\n    offAny (handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsAnyListeners) return self;\n        const index = self.eventsAnyListeners.indexOf(handler);\n        if (index >= 0) {\n            self.eventsAnyListeners.splice(index, 1);\n        }\n        return self;\n    },\n    off (events, handler) {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        events.split(\" \").forEach((event)=>{\n            if (typeof handler === \"undefined\") {\n                self.eventsListeners[event] = [];\n            } else if (self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach((eventHandler, index)=>{\n                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n                        self.eventsListeners[event].splice(index, 1);\n                    }\n                });\n            }\n        });\n        return self;\n    },\n    emit () {\n        const self = this;\n        if (!self.eventsListeners || self.destroyed) return self;\n        if (!self.eventsListeners) return self;\n        let events;\n        let data;\n        let context;\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n            events = args[0];\n            data = args.slice(1, args.length);\n            context = self;\n        } else {\n            events = args[0].events;\n            data = args[0].data;\n            context = args[0].context || self;\n        }\n        data.unshift(context);\n        const eventsArray = Array.isArray(events) ? events : events.split(\" \");\n        eventsArray.forEach((event)=>{\n            if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n                self.eventsAnyListeners.forEach((eventHandler)=>{\n                    eventHandler.apply(context, [\n                        event,\n                        ...data\n                    ]);\n                });\n            }\n            if (self.eventsListeners && self.eventsListeners[event]) {\n                self.eventsListeners[event].forEach((eventHandler)=>{\n                    eventHandler.apply(context, data);\n                });\n            }\n        });\n        return self;\n    }\n};\nfunction updateSize() {\n    const swiper = this;\n    let width;\n    let height;\n    const el = swiper.el;\n    if (typeof swiper.params.width !== \"undefined\" && swiper.params.width !== null) {\n        width = swiper.params.width;\n    } else {\n        width = el.clientWidth;\n    }\n    if (typeof swiper.params.height !== \"undefined\" && swiper.params.height !== null) {\n        height = swiper.params.height;\n    } else {\n        height = el.clientHeight;\n    }\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n        return;\n    }\n    // Subtract paddings\n    width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"padding-left\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"padding-right\") || 0, 10);\n    height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"padding-top\") || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"padding-bottom\") || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n        width,\n        height,\n        size: swiper.isHorizontal() ? width : height\n    });\n}\nfunction updateSlides() {\n    const swiper = this;\n    function getDirectionPropertyValue(node, label) {\n        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n    }\n    const params = swiper.params;\n    const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    let snapGrid = [];\n    const slidesGrid = [];\n    const slidesSizesGrid = [];\n    let offsetBefore = params.slidesOffsetBefore;\n    if (typeof offsetBefore === \"function\") {\n        offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n    let offsetAfter = params.slidesOffsetAfter;\n    if (typeof offsetAfter === \"function\") {\n        offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n    const previousSnapGridLength = swiper.snapGrid.length;\n    const previousSlidesGridLength = swiper.slidesGrid.length;\n    let spaceBetween = params.spaceBetween;\n    let slidePosition = -offsetBefore;\n    let prevSlideSize = 0;\n    let index = 0;\n    if (typeof swiperSize === \"undefined\") {\n        return;\n    }\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiperSize;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    swiper.virtualSize = -spaceBetween;\n    // reset margins\n    slides.forEach((slideEl)=>{\n        if (rtl) {\n            slideEl.style.marginLeft = \"\";\n        } else {\n            slideEl.style.marginRight = \"\";\n        }\n        slideEl.style.marginBottom = \"\";\n        slideEl.style.marginTop = \"\";\n    });\n    // reset cssMode offsets\n    if (params.centeredSlides && params.cssMode) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", \"\");\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", \"\");\n    }\n    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n    if (gridEnabled) {\n        swiper.grid.initSlides(slides);\n    } else if (swiper.grid) {\n        swiper.grid.unsetSlides();\n    }\n    // Calc slides\n    let slideSize;\n    const shouldResetSlideSize = params.slidesPerView === \"auto\" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{\n        return typeof params.breakpoints[key].slidesPerView !== \"undefined\";\n    }).length > 0;\n    for(let i = 0; i < slidesLength; i += 1){\n        slideSize = 0;\n        let slide;\n        if (slides[i]) slide = slides[i];\n        if (gridEnabled) {\n            swiper.grid.updateSlide(i, slide, slides);\n        }\n        if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(slide, \"display\") === \"none\") continue; // eslint-disable-line\n        if (params.slidesPerView === \"auto\") {\n            if (shouldResetSlideSize) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = ``;\n            }\n            const slideStyles = getComputedStyle(slide);\n            const currentTransform = slide.style.transform;\n            const currentWebKitTransform = slide.style.webkitTransform;\n            if (currentTransform) {\n                slide.style.transform = \"none\";\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = \"none\";\n            }\n            if (params.roundLengths) {\n                slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"width\", true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, \"height\", true);\n            } else {\n                // eslint-disable-next-line\n                const width = getDirectionPropertyValue(slideStyles, \"width\");\n                const paddingLeft = getDirectionPropertyValue(slideStyles, \"padding-left\");\n                const paddingRight = getDirectionPropertyValue(slideStyles, \"padding-right\");\n                const marginLeft = getDirectionPropertyValue(slideStyles, \"margin-left\");\n                const marginRight = getDirectionPropertyValue(slideStyles, \"margin-right\");\n                const boxSizing = slideStyles.getPropertyValue(\"box-sizing\");\n                if (boxSizing && boxSizing === \"border-box\") {\n                    slideSize = width + marginLeft + marginRight;\n                } else {\n                    const { clientWidth, offsetWidth } = slide;\n                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n                }\n            }\n            if (currentTransform) {\n                slide.style.transform = currentTransform;\n            }\n            if (currentWebKitTransform) {\n                slide.style.webkitTransform = currentWebKitTransform;\n            }\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n        } else {\n            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n            if (params.roundLengths) slideSize = Math.floor(slideSize);\n            if (slides[i]) {\n                slides[i].style[swiper.getDirectionLabel(\"width\")] = `${slideSize}px`;\n            }\n        }\n        if (slides[i]) {\n            slides[i].swiperSlideSize = slideSize;\n        }\n        slidesSizesGrid.push(slideSize);\n        if (params.centeredSlides) {\n            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n            if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n            if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n        } else {\n            if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n            slidesGrid.push(slidePosition);\n            slidePosition = slidePosition + slideSize + spaceBetween;\n        }\n        swiper.virtualSize += slideSize + spaceBetween;\n        prevSlideSize = slideSize;\n        index += 1;\n    }\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n    if (rtl && wrongRTL && (params.effect === \"slide\" || params.effect === \"coverflow\")) {\n        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (params.setWrapperSize) {\n        wrapperEl.style[swiper.getDirectionLabel(\"width\")] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (gridEnabled) {\n        swiper.grid.updateWrapperSize(slideSize, snapGrid);\n    }\n    // Remove last grid elements depending on width\n    if (!params.centeredSlides) {\n        const newSlidesGrid = [];\n        for(let i = 0; i < snapGrid.length; i += 1){\n            let slidesGridItem = snapGrid[i];\n            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n            if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n                newSlidesGrid.push(slidesGridItem);\n            }\n        }\n        snapGrid = newSlidesGrid;\n        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n            snapGrid.push(swiper.virtualSize - swiperSize);\n        }\n    }\n    if (isVirtual && params.loop) {\n        const size = slidesSizesGrid[0] + spaceBetween;\n        if (params.slidesPerGroup > 1) {\n            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n            const groupSize = size * params.slidesPerGroup;\n            for(let i = 0; i < groups; i += 1){\n                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n            }\n        }\n        for(let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1){\n            if (params.slidesPerGroup === 1) {\n                snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n            }\n            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n            swiper.virtualSize += size;\n        }\n    }\n    if (snapGrid.length === 0) snapGrid = [\n        0\n    ];\n    if (spaceBetween !== 0) {\n        const key = swiper.isHorizontal() && rtl ? \"marginLeft\" : swiper.getDirectionLabel(\"marginRight\");\n        slides.filter((_, slideIndex)=>{\n            if (!params.cssMode || params.loop) return true;\n            if (slideIndex === slides.length - 1) {\n                return false;\n            }\n            return true;\n        }).forEach((slideEl)=>{\n            slideEl.style[key] = `${spaceBetween}px`;\n        });\n    }\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue)=>{\n            allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        const maxSnap = allSlidesSize - swiperSize;\n        snapGrid = snapGrid.map((snap)=>{\n            if (snap <= 0) return -offsetBefore;\n            if (snap > maxSnap) return maxSnap + offsetAfter;\n            return snap;\n        });\n    }\n    if (params.centerInsufficientSlides) {\n        let allSlidesSize = 0;\n        slidesSizesGrid.forEach((slideSizeValue)=>{\n            allSlidesSize += slideSizeValue + (spaceBetween || 0);\n        });\n        allSlidesSize -= spaceBetween;\n        if (allSlidesSize < swiperSize) {\n            const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n            snapGrid.forEach((snap, snapIndex)=>{\n                snapGrid[snapIndex] = snap - allSlidesOffset;\n            });\n            slidesGrid.forEach((snap, snapIndex)=>{\n                slidesGrid[snapIndex] = snap + allSlidesOffset;\n            });\n        }\n    }\n    Object.assign(swiper, {\n        slides,\n        snapGrid,\n        slidesGrid,\n        slidesSizesGrid\n    });\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-before\", `${-snapGrid[0]}px`);\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, \"--swiper-centered-offset-after\", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n        const addToSnapGrid = -swiper.snapGrid[0];\n        const addToSlidesGrid = -swiper.slidesGrid[0];\n        swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);\n        swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);\n    }\n    if (slidesLength !== previousSlidesLength) {\n        swiper.emit(\"slidesLengthChange\");\n    }\n    if (snapGrid.length !== previousSnapGridLength) {\n        if (swiper.params.watchOverflow) swiper.checkOverflow();\n        swiper.emit(\"snapGridLengthChange\");\n    }\n    if (slidesGrid.length !== previousSlidesGridLength) {\n        swiper.emit(\"slidesGridLengthChange\");\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    swiper.emit(\"slidesUpdated\");\n    if (!isVirtual && !params.cssMode && (params.effect === \"slide\" || params.effect === \"fade\")) {\n        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n        if (slidesLength <= params.maxBackfaceHiddenSlides) {\n            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n        } else if (hasClassBackfaceClassAdded) {\n            swiper.el.classList.remove(backFaceHiddenClass);\n        }\n    }\n}\nfunction updateAutoHeight(speed) {\n    const swiper = this;\n    const activeSlides = [];\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let newHeight = 0;\n    let i;\n    if (typeof speed === \"number\") {\n        swiper.setTransition(speed);\n    } else if (speed === true) {\n        swiper.setTransition(swiper.params.speed);\n    }\n    const getSlideByIndex = (index)=>{\n        if (isVirtual) {\n            return swiper.slides[swiper.getSlideIndexByData(index)];\n        }\n        return swiper.slides[index];\n    };\n    // Find slides currently in view\n    if (swiper.params.slidesPerView !== \"auto\" && swiper.params.slidesPerView > 1) {\n        if (swiper.params.centeredSlides) {\n            (swiper.visibleSlides || []).forEach((slide)=>{\n                activeSlides.push(slide);\n            });\n        } else {\n            for(i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1){\n                const index = swiper.activeIndex + i;\n                if (index > swiper.slides.length && !isVirtual) break;\n                activeSlides.push(getSlideByIndex(index));\n            }\n        }\n    } else {\n        activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    }\n    // Find new height from highest slide in view\n    for(i = 0; i < activeSlides.length; i += 1){\n        if (typeof activeSlides[i] !== \"undefined\") {\n            const height = activeSlides[i].offsetHeight;\n            newHeight = height > newHeight ? height : newHeight;\n        }\n    }\n    // Update Height\n    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\nfunction updateSlidesOffset() {\n    const swiper = this;\n    const slides = swiper.slides;\n    // eslint-disable-next-line\n    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n    for(let i = 0; i < slides.length; i += 1){\n        slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n}\nfunction updateSlidesProgress(translate) {\n    if (translate === void 0) {\n        translate = this && this.translate || 0;\n    }\n    const swiper = this;\n    const params = swiper.params;\n    const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === \"undefined\") swiper.updateSlidesOffset();\n    let offsetCenter = -translate;\n    if (rtl) offsetCenter = translate;\n    // Visible Slides\n    slides.forEach((slideEl)=>{\n        slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass);\n    });\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n    let spaceBetween = params.spaceBetween;\n    if (typeof spaceBetween === \"string\" && spaceBetween.indexOf(\"%\") >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace(\"%\", \"\")) / 100 * swiper.size;\n    } else if (typeof spaceBetween === \"string\") {\n        spaceBetween = parseFloat(spaceBetween);\n    }\n    for(let i = 0; i < slides.length; i += 1){\n        const slide = slides[i];\n        let slideOffset = slide.swiperSlideOffset;\n        if (params.cssMode && params.centeredSlides) {\n            slideOffset -= slides[0].swiperSlideOffset;\n        }\n        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n        const slideBefore = -(offsetCenter - slideOffset);\n        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n        const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n        if (isVisible) {\n            swiper.visibleSlides.push(slide);\n            swiper.visibleSlidesIndexes.push(i);\n            slides[i].classList.add(params.slideVisibleClass);\n        }\n        if (isFullyVisible) {\n            slides[i].classList.add(params.slideFullyVisibleClass);\n        }\n        slide.progress = rtl ? -slideProgress : slideProgress;\n        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n}\nfunction updateProgress(translate) {\n    const swiper = this;\n    if (typeof translate === \"undefined\") {\n        const multiplier = swiper.rtlTranslate ? -1 : 1;\n        // eslint-disable-next-line\n        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n    }\n    const params = swiper.params;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    let { progress, isBeginning, isEnd, progressLoop } = swiper;\n    const wasBeginning = isBeginning;\n    const wasEnd = isEnd;\n    if (translatesDiff === 0) {\n        progress = 0;\n        isBeginning = true;\n        isEnd = true;\n    } else {\n        progress = (translate - swiper.minTranslate()) / translatesDiff;\n        const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n        const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n        isBeginning = isBeginningRounded || progress <= 0;\n        isEnd = isEndRounded || progress >= 1;\n        if (isBeginningRounded) progress = 0;\n        if (isEndRounded) progress = 1;\n    }\n    if (params.loop) {\n        const firstSlideIndex = swiper.getSlideIndexByData(0);\n        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n        const translateAbs = Math.abs(translate);\n        if (translateAbs >= firstSlideTranslate) {\n            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n        } else {\n            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n        }\n        if (progressLoop > 1) progressLoop -= 1;\n    }\n    Object.assign(swiper, {\n        progress,\n        progressLoop,\n        isBeginning,\n        isEnd\n    });\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n    if (isBeginning && !wasBeginning) {\n        swiper.emit(\"reachBeginning toEdge\");\n    }\n    if (isEnd && !wasEnd) {\n        swiper.emit(\"reachEnd toEdge\");\n    }\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n        swiper.emit(\"fromEdge\");\n    }\n    swiper.emit(\"progress\", progress);\n}\nfunction updateSlidesClasses() {\n    const swiper = this;\n    const { slides, params, slidesEl, activeIndex } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    const getFilteredSlide = (selector)=>{\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n    };\n    slides.forEach((slideEl)=>{\n        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n    });\n    let activeSlide;\n    let prevSlide;\n    let nextSlide;\n    if (isVirtual) {\n        if (params.loop) {\n            let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n            activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n        } else {\n            activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n        }\n    } else {\n        if (gridEnabled) {\n            activeSlide = slides.filter((slideEl)=>slideEl.column === activeIndex)[0];\n            nextSlide = slides.filter((slideEl)=>slideEl.column === activeIndex + 1)[0];\n            prevSlide = slides.filter((slideEl)=>slideEl.column === activeIndex - 1)[0];\n        } else {\n            activeSlide = slides[activeIndex];\n        }\n    }\n    if (activeSlide) {\n        // Active classes\n        activeSlide.classList.add(params.slideActiveClass);\n        if (gridEnabled) {\n            if (nextSlide) {\n                nextSlide.classList.add(params.slideNextClass);\n            }\n            if (prevSlide) {\n                prevSlide.classList.add(params.slidePrevClass);\n            }\n        } else {\n            // Next Slide\n            nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !nextSlide) {\n                nextSlide = slides[0];\n            }\n            if (nextSlide) {\n                nextSlide.classList.add(params.slideNextClass);\n            }\n            // Prev Slide\n            prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n            if (params.loop && !prevSlide === 0) {\n                prevSlide = slides[slides.length - 1];\n            }\n            if (prevSlide) {\n                prevSlide.classList.add(params.slidePrevClass);\n            }\n        }\n    }\n    swiper.emitSlidesClasses();\n}\nconst processLazyPreloader = (swiper, imageEl)=>{\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    const slideEl = imageEl.closest(slideSelector());\n    if (slideEl) {\n        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n        if (!lazyEl && swiper.isElement) {\n            if (slideEl.shadowRoot) {\n                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            } else {\n                // init later\n                requestAnimationFrame(()=>{\n                    if (slideEl.shadowRoot) {\n                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n                        if (lazyEl) lazyEl.remove();\n                    }\n                });\n            }\n        }\n        if (lazyEl) lazyEl.remove();\n    }\n};\nconst unlazy = (swiper, index)=>{\n    if (!swiper.slides[index]) return;\n    const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n    if (imageEl) imageEl.removeAttribute(\"loading\");\n};\nconst preload = (swiper)=>{\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    let amount = swiper.params.lazyPreloadPrevNext;\n    const len = swiper.slides.length;\n    if (!len || !amount || amount < 0) return;\n    amount = Math.min(amount, len);\n    const slidesPerView = swiper.params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n    const activeIndex = swiper.activeIndex;\n    if (swiper.params.grid && swiper.params.grid.rows > 1) {\n        const activeColumn = activeIndex;\n        const preloadColumns = [\n            activeColumn - amount\n        ];\n        preloadColumns.push(...Array.from({\n            length: amount\n        }).map((_, i)=>{\n            return activeColumn + slidesPerView + i;\n        }));\n        swiper.slides.forEach((slideEl, i)=>{\n            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n        });\n        return;\n    }\n    const slideIndexLastInView = activeIndex + slidesPerView - 1;\n    if (swiper.params.rewind || swiper.params.loop) {\n        for(let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1){\n            const realIndex = (i % len + len) % len;\n            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n        }\n    } else {\n        for(let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1){\n            if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n                unlazy(swiper, i);\n            }\n        }\n    }\n};\nfunction getActiveIndexByTranslate(swiper) {\n    const { slidesGrid, params } = swiper;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    let activeIndex;\n    for(let i = 0; i < slidesGrid.length; i += 1){\n        if (typeof slidesGrid[i + 1] !== \"undefined\") {\n            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n                activeIndex = i;\n            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n                activeIndex = i + 1;\n            }\n        } else if (translate >= slidesGrid[i]) {\n            activeIndex = i;\n        }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === \"undefined\") activeIndex = 0;\n    }\n    return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n    const swiper = this;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    const { snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;\n    let activeIndex = newActiveIndex;\n    let snapIndex;\n    const getVirtualRealIndex = (aIndex)=>{\n        let realIndex = aIndex - swiper.virtual.slidesBefore;\n        if (realIndex < 0) {\n            realIndex = swiper.virtual.slides.length + realIndex;\n        }\n        if (realIndex >= swiper.virtual.slides.length) {\n            realIndex -= swiper.virtual.slides.length;\n        }\n        return realIndex;\n    };\n    if (typeof activeIndex === \"undefined\") {\n        activeIndex = getActiveIndexByTranslate(swiper);\n    }\n    if (snapGrid.indexOf(translate) >= 0) {\n        snapIndex = snapGrid.indexOf(translate);\n    } else {\n        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    if (activeIndex === previousIndex && !swiper.params.loop) {\n        if (snapIndex !== previousSnapIndex) {\n            swiper.snapIndex = snapIndex;\n            swiper.emit(\"snapIndexChange\");\n        }\n        return;\n    }\n    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.realIndex = getVirtualRealIndex(activeIndex);\n        return;\n    }\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    // Get real index\n    let realIndex;\n    if (swiper.virtual && params.virtual.enabled && params.loop) {\n        realIndex = getVirtualRealIndex(activeIndex);\n    } else if (gridEnabled) {\n        const firstSlideInColumn = swiper.slides.filter((slideEl)=>slideEl.column === activeIndex)[0];\n        let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (Number.isNaN(activeSlideIndex)) {\n            activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n        }\n        realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n    } else if (swiper.slides[activeIndex]) {\n        const slideIndex = swiper.slides[activeIndex].getAttribute(\"data-swiper-slide-index\");\n        if (slideIndex) {\n            realIndex = parseInt(slideIndex, 10);\n        } else {\n            realIndex = activeIndex;\n        }\n    } else {\n        realIndex = activeIndex;\n    }\n    Object.assign(swiper, {\n        previousSnapIndex,\n        snapIndex,\n        previousRealIndex,\n        realIndex,\n        previousIndex,\n        activeIndex\n    });\n    if (swiper.initialized) {\n        preload(swiper);\n    }\n    swiper.emit(\"activeIndexChange\");\n    swiper.emit(\"snapIndexChange\");\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n        if (previousRealIndex !== realIndex) {\n            swiper.emit(\"realIndexChange\");\n        }\n        swiper.emit(\"slideChange\");\n    }\n}\nfunction updateClickedSlide(el, path) {\n    const swiper = this;\n    const params = swiper.params;\n    let slide = el.closest(`.${params.slideClass}, swiper-slide`);\n    if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n        [\n            ...path.slice(path.indexOf(el) + 1, path.length)\n        ].forEach((pathEl)=>{\n            if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n                slide = pathEl;\n            }\n        });\n    }\n    let slideFound = false;\n    let slideIndex;\n    if (slide) {\n        for(let i = 0; i < swiper.slides.length; i += 1){\n            if (swiper.slides[i] === slide) {\n                slideFound = true;\n                slideIndex = i;\n                break;\n            }\n        }\n    }\n    if (slide && slideFound) {\n        swiper.clickedSlide = slide;\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.clickedIndex = parseInt(slide.getAttribute(\"data-swiper-slide-index\"), 10);\n        } else {\n            swiper.clickedIndex = slideIndex;\n        }\n    } else {\n        swiper.clickedSlide = undefined;\n        swiper.clickedIndex = undefined;\n        return;\n    }\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n        swiper.slideToClickedSlide();\n    }\n}\nvar update = {\n    updateSize,\n    updateSlides,\n    updateAutoHeight,\n    updateSlidesOffset,\n    updateSlidesProgress,\n    updateProgress,\n    updateSlidesClasses,\n    updateActiveIndex,\n    updateClickedSlide\n};\nfunction getSwiperTranslate(axis) {\n    if (axis === void 0) {\n        axis = this.isHorizontal() ? \"x\" : \"y\";\n    }\n    const swiper = this;\n    const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;\n    if (params.virtualTranslate) {\n        return rtl ? -translate : translate;\n    }\n    if (params.cssMode) {\n        return translate;\n    }\n    let currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.i)(wrapperEl, axis);\n    currentTranslate += swiper.cssOverflowAdjustment();\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n}\nfunction setTranslate(translate, byController) {\n    const swiper = this;\n    const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;\n    let x = 0;\n    let y = 0;\n    const z = 0;\n    if (swiper.isHorizontal()) {\n        x = rtl ? -translate : translate;\n    } else {\n        y = translate;\n    }\n    if (params.roundLengths) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n    }\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y;\n    if (params.cssMode) {\n        wrapperEl[swiper.isHorizontal() ? \"scrollLeft\" : \"scrollTop\"] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n        if (swiper.isHorizontal()) {\n            x -= swiper.cssOverflowAdjustment();\n        } else {\n            y -= swiper.cssOverflowAdjustment();\n        }\n        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n    }\n    // Check if we need to update progress\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== progress) {\n        swiper.updateProgress(translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, byController);\n}\nfunction minTranslate() {\n    return -this.snapGrid[0];\n}\nfunction maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n}\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n        translate = 0;\n    }\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (translateBounds === void 0) {\n        translateBounds = true;\n    }\n    const swiper = this;\n    const { params, wrapperEl } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return false;\n    }\n    const minTranslate = swiper.minTranslate();\n    const maxTranslate = swiper.maxTranslate();\n    let newTranslate;\n    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n    else newTranslate = translate;\n    // Update progress\n    swiper.updateProgress(newTranslate);\n    if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        if (speed === 0) {\n            wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = -newTranslate;\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({\n                    swiper,\n                    targetPosition: -newTranslate,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            wrapperEl.scrollTo({\n                [isH ? \"left\" : \"top\"]: -newTranslate,\n                behavior: \"smooth\"\n            });\n        }\n        return true;\n    }\n    if (speed === 0) {\n        swiper.setTransition(0);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionEnd\");\n        }\n    } else {\n        swiper.setTransition(speed);\n        swiper.setTranslate(newTranslate);\n        if (runCallbacks) {\n            swiper.emit(\"beforeTransitionStart\", speed, internal);\n            swiper.emit(\"transitionStart\");\n        }\n        if (!swiper.animating) {\n            swiper.animating = true;\n            if (!swiper.onTranslateToWrapperTransitionEnd) {\n                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n                    if (!swiper || swiper.destroyed) return;\n                    if (e.target !== this) return;\n                    swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n                    swiper.onTranslateToWrapperTransitionEnd = null;\n                    delete swiper.onTranslateToWrapperTransitionEnd;\n                    if (runCallbacks) {\n                        swiper.emit(\"transitionEnd\");\n                    }\n                };\n            }\n            swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onTranslateToWrapperTransitionEnd);\n        }\n    }\n    return true;\n}\nvar translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate,\n    minTranslate,\n    maxTranslate,\n    translateTo\n};\nfunction setTransition(duration, byController) {\n    const swiper = this;\n    if (!swiper.params.cssMode) {\n        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : \"\";\n    }\n    swiper.emit(\"setTransition\", duration, byController);\n}\nfunction transitionEmit(_ref) {\n    let { swiper, runCallbacks, direction, step } = _ref;\n    const { activeIndex, previousIndex } = swiper;\n    let dir = direction;\n    if (!dir) {\n        if (activeIndex > previousIndex) dir = \"next\";\n        else if (activeIndex < previousIndex) dir = \"prev\";\n        else dir = \"reset\";\n    }\n    swiper.emit(`transition${step}`);\n    if (runCallbacks && activeIndex !== previousIndex) {\n        if (dir === \"reset\") {\n            swiper.emit(`slideResetTransition${step}`);\n            return;\n        }\n        swiper.emit(`slideChangeTransition${step}`);\n        if (dir === \"next\") {\n            swiper.emit(`slideNextTransition${step}`);\n        } else {\n            swiper.emit(`slidePrevTransition${step}`);\n        }\n    }\n}\nfunction transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params } = swiper;\n    if (params.cssMode) return;\n    if (params.autoHeight) {\n        swiper.updateAutoHeight();\n    }\n    transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"Start\"\n    });\n}\nfunction transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params } = swiper;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n        swiper,\n        runCallbacks,\n        direction,\n        step: \"End\"\n    });\n}\nvar transition = {\n    setTransition,\n    transitionStart,\n    transitionEnd\n};\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        index = parseInt(index, 10);\n    }\n    const swiper = this;\n    let slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n        return false;\n    }\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    const translate = -snapGrid[snapIndex];\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n        for(let i = 0; i < slidesGrid.length; i += 1){\n            const normalizedTranslate = -Math.floor(translate * 100);\n            const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n            const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n            if (typeof slidesGrid[i + 1] !== \"undefined\") {\n                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n                    slideIndex = i;\n                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n                    slideIndex = i + 1;\n                }\n            } else if (normalizedTranslate >= normalizedGrid) {\n                slideIndex = i;\n            }\n        }\n    }\n    // Directions locks\n    if (swiper.initialized && slideIndex !== activeIndex) {\n        if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n            return false;\n        }\n        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n            if ((activeIndex || 0) !== slideIndex) {\n                return false;\n            }\n        }\n    }\n    if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n        swiper.emit(\"beforeSlideChangeStart\");\n    }\n    // Update progress\n    swiper.updateProgress(translate);\n    let direction;\n    if (slideIndex > activeIndex) direction = \"next\";\n    else if (slideIndex < activeIndex) direction = \"prev\";\n    else direction = \"reset\";\n    // Update Index\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n        swiper.updateActiveIndex(slideIndex);\n        // Update Height\n        if (params.autoHeight) {\n            swiper.updateAutoHeight();\n        }\n        swiper.updateSlidesClasses();\n        if (params.effect !== \"slide\") {\n            swiper.setTranslate(translate);\n        }\n        if (direction !== \"reset\") {\n            swiper.transitionStart(runCallbacks, direction);\n            swiper.transitionEnd(runCallbacks, direction);\n        }\n        return false;\n    }\n    if (params.cssMode) {\n        const isH = swiper.isHorizontal();\n        const t = rtl ? translate : -translate;\n        if (speed === 0) {\n            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n            if (isVirtual) {\n                swiper.wrapperEl.style.scrollSnapType = \"none\";\n                swiper._immediateVirtual = true;\n            }\n            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n                swiper._cssModeVirtualInitialSet = true;\n                requestAnimationFrame(()=>{\n                    wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n                });\n            } else {\n                wrapperEl[isH ? \"scrollLeft\" : \"scrollTop\"] = t;\n            }\n            if (isVirtual) {\n                requestAnimationFrame(()=>{\n                    swiper.wrapperEl.style.scrollSnapType = \"\";\n                    swiper._immediateVirtual = false;\n                });\n            }\n        } else {\n            if (!swiper.support.smoothScroll) {\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({\n                    swiper,\n                    targetPosition: t,\n                    side: isH ? \"left\" : \"top\"\n                });\n                return true;\n            }\n            wrapperEl.scrollTo({\n                [isH ? \"left\" : \"top\"]: t,\n                behavior: \"smooth\"\n            });\n        }\n        return true;\n    }\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit(\"beforeTransitionStart\", speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (speed === 0) {\n        swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onSlideToWrapperTransitionEnd) {\n            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n                if (!swiper || swiper.destroyed) return;\n                if (e.target !== this) return;\n                swiper.wrapperEl.removeEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n                swiper.onSlideToWrapperTransitionEnd = null;\n                delete swiper.onSlideToWrapperTransitionEnd;\n                swiper.transitionEnd(runCallbacks, direction);\n            };\n        }\n        swiper.wrapperEl.addEventListener(\"transitionend\", swiper.onSlideToWrapperTransitionEnd);\n    }\n    return true;\n}\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n        index = 0;\n    }\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (typeof index === \"string\") {\n        const indexAsNumber = parseInt(index, 10);\n        index = indexAsNumber;\n    }\n    const swiper = this;\n    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n    let newIndex = index;\n    if (swiper.params.loop) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n            // eslint-disable-next-line\n            newIndex = newIndex + swiper.virtual.slidesBefore;\n        } else {\n            let targetSlideIndex;\n            if (gridEnabled) {\n                const slideIndex = newIndex * swiper.params.grid.rows;\n                targetSlideIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n            } else {\n                targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n            }\n            const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n            const { centeredSlides } = swiper.params;\n            let slidesPerView = swiper.params.slidesPerView;\n            if (slidesPerView === \"auto\") {\n                slidesPerView = swiper.slidesPerViewDynamic();\n            } else {\n                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n                if (centeredSlides && slidesPerView % 2 === 0) {\n                    slidesPerView = slidesPerView + 1;\n                }\n            }\n            let needLoopFix = cols - targetSlideIndex < slidesPerView;\n            if (centeredSlides) {\n                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n            }\n            if (needLoopFix) {\n                const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? \"prev\" : \"next\" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? \"next\" : \"prev\";\n                swiper.loopFix({\n                    direction,\n                    slideTo: true,\n                    activeSlideIndex: direction === \"next\" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n                    slideRealIndex: direction === \"next\" ? swiper.realIndex : undefined\n                });\n            }\n            if (gridEnabled) {\n                const slideIndex = newIndex * swiper.params.grid.rows;\n                newIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === slideIndex)[0].column;\n            } else {\n                newIndex = swiper.getSlideIndexByData(newIndex);\n            }\n        }\n    }\n    requestAnimationFrame(()=>{\n        swiper.slideTo(newIndex, speed, runCallbacks, internal);\n    });\n    return swiper;\n}\n/* eslint no-unused-vars: \"off\" */ function slideNext(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { enabled, params, animating } = swiper;\n    if (!enabled) return swiper;\n    let perGroup = params.slidesPerGroup;\n    if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        perGroup = Math.max(swiper.slidesPerViewDynamic(\"current\", true), 1);\n    }\n    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"next\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n            requestAnimationFrame(()=>{\n                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n            });\n            return true;\n        }\n    }\n    if (params.rewind && swiper.isEnd) {\n        return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slidePrev(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;\n    if (!enabled) return swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n        if (animating && !isVirtual && params.loopPreventsSliding) return false;\n        swiper.loopFix({\n            direction: \"prev\"\n        });\n        // eslint-disable-next-line\n        swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n    function normalize(val) {\n        if (val < 0) return -Math.floor(Math.abs(val));\n        return Math.floor(val);\n    }\n    const normalizedTranslate = normalize(translate);\n    const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));\n    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n    if (typeof prevSnap === \"undefined\" && params.cssMode) {\n        let prevSnapIndex;\n        snapGrid.forEach((snap, snapIndex)=>{\n            if (normalizedTranslate >= snap) {\n                // prevSnap = snap;\n                prevSnapIndex = snapIndex;\n            }\n        });\n        if (typeof prevSnapIndex !== \"undefined\") {\n            prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n        }\n    }\n    let prevIndex = 0;\n    if (typeof prevSnap !== \"undefined\") {\n        prevIndex = slidesGrid.indexOf(prevSnap);\n        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n        if (params.slidesPerView === \"auto\" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n            prevIndex = prevIndex - swiper.slidesPerViewDynamic(\"previous\", true) + 1;\n            prevIndex = Math.max(prevIndex, 0);\n        }\n    }\n    if (params.rewind && swiper.isBeginning) {\n        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n        requestAnimationFrame(()=>{\n            swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n        });\n        return true;\n    }\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideReset(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    const swiper = this;\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n/* eslint no-unused-vars: \"off\" */ function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (speed === void 0) {\n        speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n        runCallbacks = true;\n    }\n    if (threshold === void 0) {\n        threshold = 0.5;\n    }\n    const swiper = this;\n    let index = swiper.activeIndex;\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    if (translate >= swiper.snapGrid[snapIndex]) {\n        // The current translate is on or after the current snap index, so the choice\n        // is between the current index and the one after it.\n        const currentSnap = swiper.snapGrid[snapIndex];\n        const nextSnap = swiper.snapGrid[snapIndex + 1];\n        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n            index += swiper.params.slidesPerGroup;\n        }\n    } else {\n        // The current translate is before the current snap index, so the choice\n        // is between the current index and the one before it.\n        const prevSnap = swiper.snapGrid[snapIndex - 1];\n        const currentSnap = swiper.snapGrid[snapIndex];\n        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n            index -= swiper.params.slidesPerGroup;\n        }\n    }\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n}\nfunction slideToClickedSlide() {\n    const swiper = this;\n    const { params, slidesEl } = swiper;\n    const slidesPerView = params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    let slideToIndex = swiper.clickedIndex;\n    let realIndex;\n    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n    if (params.loop) {\n        if (swiper.animating) return;\n        realIndex = parseInt(swiper.clickedSlide.getAttribute(\"data-swiper-slide-index\"), 10);\n        if (params.centeredSlides) {\n            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n                swiper.loopFix();\n                slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n                (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n                    swiper.slideTo(slideToIndex);\n                });\n            } else {\n                swiper.slideTo(slideToIndex);\n            }\n        } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n            swiper.loopFix();\n            slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n                swiper.slideTo(slideToIndex);\n            });\n        } else {\n            swiper.slideTo(slideToIndex);\n        }\n    } else {\n        swiper.slideTo(slideToIndex);\n    }\n}\nvar slide = {\n    slideTo,\n    slideToLoop,\n    slideNext,\n    slidePrev,\n    slideReset,\n    slideToClosest,\n    slideToClickedSlide\n};\nfunction loopCreate(slideRealIndex) {\n    const swiper = this;\n    const { params, slidesEl } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    const initSlides = ()=>{\n        const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n        slides.forEach((el, index)=>{\n            el.setAttribute(\"data-swiper-slide-index\", index);\n        });\n    };\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n    const addBlankSlides = (amountOfSlides)=>{\n        for(let i = 0; i < amountOfSlides; i += 1){\n            const slideEl = swiper.isElement ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"swiper-slide\", [\n                params.slideBlankClass\n            ]) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", [\n                params.slideClass,\n                params.slideBlankClass\n            ]);\n            swiper.slidesEl.append(slideEl);\n        }\n    };\n    if (shouldFillGroup) {\n        if (params.loopAddBlankSlides) {\n            const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n            addBlankSlides(slidesToAdd);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(\"Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else if (shouldFillGrid) {\n        if (params.loopAddBlankSlides) {\n            const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n            addBlankSlides(slidesToAdd);\n            swiper.recalcSlides();\n            swiper.updateSlides();\n        } else {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(\"Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)\");\n        }\n        initSlides();\n    } else {\n        initSlides();\n    }\n    swiper.loopFix({\n        slideRealIndex,\n        direction: params.centeredSlides ? undefined : \"next\"\n    });\n}\nfunction loopFix(_temp) {\n    let { slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel } = _temp === void 0 ? {} : _temp;\n    const swiper = this;\n    if (!swiper.params.loop) return;\n    swiper.emit(\"beforeLoopFix\");\n    const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;\n    const { centeredSlides } = params;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    if (swiper.virtual && params.virtual.enabled) {\n        if (slideTo) {\n            if (!params.centeredSlides && swiper.snapIndex === 0) {\n                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n            }\n        }\n        swiper.allowSlidePrev = allowSlidePrev;\n        swiper.allowSlideNext = allowSlideNext;\n        swiper.emit(\"loopFix\");\n        return;\n    }\n    let slidesPerView = params.slidesPerView;\n    if (slidesPerView === \"auto\") {\n        slidesPerView = swiper.slidesPerViewDynamic();\n    } else {\n        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n        if (centeredSlides && slidesPerView % 2 === 0) {\n            slidesPerView = slidesPerView + 1;\n        }\n    }\n    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n    let loopedSlides = slidesPerGroup;\n    if (loopedSlides % slidesPerGroup !== 0) {\n        loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n    }\n    loopedSlides += params.loopAdditionalSlides;\n    swiper.loopedSlides = loopedSlides;\n    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n    if (slides.length < slidesPerView + loopedSlides) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(\"Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters\");\n    } else if (gridEnabled && params.grid.fill === \"row\") {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(\"Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`\");\n    }\n    const prependSlidesIndexes = [];\n    const appendSlidesIndexes = [];\n    let activeIndex = swiper.activeIndex;\n    if (typeof activeSlideIndex === \"undefined\") {\n        activeSlideIndex = swiper.getSlideIndex(slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);\n    } else {\n        activeIndex = activeSlideIndex;\n    }\n    const isNext = direction === \"next\" || !direction;\n    const isPrev = direction === \"prev\" || !direction;\n    let slidesPrepended = 0;\n    let slidesAppended = 0;\n    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === \"undefined\" ? -slidesPerView / 2 + 0.5 : 0);\n    // prepend last slides before start\n    if (activeColIndexWithShift < loopedSlides) {\n        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n        for(let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1){\n            const index = i - Math.floor(i / cols) * cols;\n            if (gridEnabled) {\n                const colIndexToPrepend = cols - index - 1;\n                for(let i = slides.length - 1; i >= 0; i -= 1){\n                    if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n                }\n            // slides.forEach((slide, slideIndex) => {\n            //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n            // });\n            } else {\n                prependSlidesIndexes.push(cols - index - 1);\n            }\n        }\n    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n        for(let i = 0; i < slidesAppended; i += 1){\n            const index = i - Math.floor(i / cols) * cols;\n            if (gridEnabled) {\n                slides.forEach((slide, slideIndex)=>{\n                    if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n                });\n            } else {\n                appendSlidesIndexes.push(index);\n            }\n        }\n    }\n    swiper.__preventObserver__ = true;\n    requestAnimationFrame(()=>{\n        swiper.__preventObserver__ = false;\n    });\n    if (isPrev) {\n        prependSlidesIndexes.forEach((index)=>{\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.prepend(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    if (isNext) {\n        appendSlidesIndexes.forEach((index)=>{\n            slides[index].swiperLoopMoveDOM = true;\n            slidesEl.append(slides[index]);\n            slides[index].swiperLoopMoveDOM = false;\n        });\n    }\n    swiper.recalcSlides();\n    if (params.slidesPerView === \"auto\") {\n        swiper.updateSlides();\n    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n        swiper.slides.forEach((slide, slideIndex)=>{\n            swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n        });\n    }\n    if (params.watchSlidesProgress) {\n        swiper.updateSlidesOffset();\n    }\n    if (slideTo) {\n        if (prependSlidesIndexes.length > 0 && isPrev) {\n            if (typeof slideRealIndex === \"undefined\") {\n                const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n                const diff = newSlideTranslate - currentSlideTranslate;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff);\n                } else {\n                    swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n                    if (setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                    }\n                }\n            } else {\n                if (setTranslate) {\n                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n                    swiper.touchEventsData.currentTranslate = swiper.translate;\n                }\n            }\n        } else if (appendSlidesIndexes.length > 0 && isNext) {\n            if (typeof slideRealIndex === \"undefined\") {\n                const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n                const diff = newSlideTranslate - currentSlideTranslate;\n                if (byMousewheel) {\n                    swiper.setTranslate(swiper.translate - diff);\n                } else {\n                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n                    if (setTranslate) {\n                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n                    }\n                }\n            } else {\n                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n            }\n        }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.controller && swiper.controller.control && !byController) {\n        const loopParams = {\n            slideRealIndex,\n            direction,\n            setTranslate,\n            activeSlideIndex,\n            byController: true\n        };\n        if (Array.isArray(swiper.controller.control)) {\n            swiper.controller.control.forEach((c)=>{\n                if (!c.destroyed && c.params.loop) c.loopFix({\n                    ...loopParams,\n                    slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n                });\n            });\n        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n            swiper.controller.control.loopFix({\n                ...loopParams,\n                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n            });\n        }\n    }\n    swiper.emit(\"loopFix\");\n}\nfunction loopDestroy() {\n    const swiper = this;\n    const { params, slidesEl } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    swiper.recalcSlides();\n    const newSlidesOrder = [];\n    swiper.slides.forEach((slideEl)=>{\n        const index = typeof slideEl.swiperSlideIndex === \"undefined\" ? slideEl.getAttribute(\"data-swiper-slide-index\") * 1 : slideEl.swiperSlideIndex;\n        newSlidesOrder[index] = slideEl;\n    });\n    swiper.slides.forEach((slideEl)=>{\n        slideEl.removeAttribute(\"data-swiper-slide-index\");\n    });\n    newSlidesOrder.forEach((slideEl)=>{\n        slidesEl.append(slideEl);\n    });\n    swiper.recalcSlides();\n    swiper.slideTo(swiper.realIndex, 0);\n}\nvar loop = {\n    loopCreate,\n    loopFix,\n    loopDestroy\n};\nfunction setGrabCursor(moving) {\n    const swiper = this;\n    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n    const el = swiper.params.touchEventsTarget === \"container\" ? swiper.el : swiper.wrapperEl;\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    el.style.cursor = \"move\";\n    el.style.cursor = moving ? \"grabbing\" : \"grab\";\n    if (swiper.isElement) {\n        requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nfunction unsetGrabCursor() {\n    const swiper = this;\n    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n        return;\n    }\n    if (swiper.isElement) {\n        swiper.__preventObserver__ = true;\n    }\n    swiper[swiper.params.touchEventsTarget === \"container\" ? \"el\" : \"wrapperEl\"].style.cursor = \"\";\n    if (swiper.isElement) {\n        requestAnimationFrame(()=>{\n            swiper.__preventObserver__ = false;\n        });\n    }\n}\nvar grabCursor = {\n    setGrabCursor,\n    unsetGrabCursor\n};\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base) {\n    if (base === void 0) {\n        base = this;\n    }\n    function __closestFrom(el) {\n        if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;\n        if (el.assignedSlot) el = el.assignedSlot;\n        const found = el.closest(selector);\n        if (!found && !el.getRootNode) {\n            return null;\n        }\n        return found || __closestFrom(el.getRootNode().host);\n    }\n    return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const { params } = swiper;\n    const edgeSwipeDetection = params.edgeSwipeDetection;\n    const edgeSwipeThreshold = params.edgeSwipeThreshold;\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window1.innerWidth - edgeSwipeThreshold)) {\n        if (edgeSwipeDetection === \"prevent\") {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\nfunction onTouchStart(event) {\n    const swiper = this;\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    const data = swiper.touchEventsData;\n    if (e.type === \"pointerdown\") {\n        if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n            return;\n        }\n        data.pointerId = e.pointerId;\n    } else if (e.type === \"touchstart\" && e.targetTouches.length === 1) {\n        data.touchId = e.targetTouches[0].identifier;\n    }\n    if (e.type === \"touchstart\") {\n        // don't proceed touch event\n        preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n        return;\n    }\n    const { params, touches, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n        return;\n    }\n    if (!swiper.animating && params.cssMode && params.loop) {\n        swiper.loopFix();\n    }\n    let targetEl = e.target;\n    if (params.touchEventsTarget === \"wrapper\") {\n        if (!swiper.wrapperEl.contains(targetEl)) return;\n    }\n    if (\"which\" in e && e.which === 3) return;\n    if (\"button\" in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return;\n    // change target el for shadow root component\n    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== \"\";\n    // eslint-disable-next-line\n    const eventPath = e.composedPath ? e.composedPath() : e.path;\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n        targetEl = eventPath[0];\n    }\n    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n    const isTargetShadow = !!(e.target && e.target.shadowRoot);\n    // use closestElement for shadow root element to get the actual closest for nested shadow root element\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n        swiper.allowClick = true;\n        return;\n    }\n    if (params.swipeHandler) {\n        if (!targetEl.closest(params.swipeHandler)) return;\n    }\n    touches.currentX = e.pageX;\n    touches.currentY = e.pageY;\n    const startX = touches.currentX;\n    const startY = touches.currentY;\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n    if (!preventEdgeSwipe(swiper, e, startX)) {\n        return;\n    }\n    Object.assign(data, {\n        isTouched: true,\n        isMoved: false,\n        allowTouchCallbacks: true,\n        isScrolling: undefined,\n        startMoving: undefined\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n    let preventDefault = true;\n    if (targetEl.matches(data.focusableElements)) {\n        preventDefault = false;\n        if (targetEl.nodeName === \"SELECT\") {\n            data.isTouched = false;\n        }\n    }\n    if (document1.activeElement && document1.activeElement.matches(data.focusableElements) && document1.activeElement !== targetEl) {\n        document1.activeElement.blur();\n    }\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n        e.preventDefault();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n        swiper.freeMode.onTouchStart();\n    }\n    swiper.emit(\"touchStart\", e);\n}\nfunction onTouchMove(event) {\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === \"mouse\") return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (e.type === \"pointermove\") {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        const id = e.pointerId;\n        if (id !== data.pointerId) return;\n    }\n    let targetTouch;\n    if (e.type === \"touchmove\") {\n        targetTouch = [\n            ...e.changedTouches\n        ].filter((t)=>t.identifier === data.touchId)[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    } else {\n        targetTouch = e;\n    }\n    if (!data.isTouched) {\n        if (data.startMoving && data.isScrolling) {\n            swiper.emit(\"touchMoveOpposite\", e);\n        }\n        return;\n    }\n    const pageX = targetTouch.pageX;\n    const pageY = targetTouch.pageY;\n    if (e.preventedByNestedSwiper) {\n        touches.startX = pageX;\n        touches.startY = pageY;\n        return;\n    }\n    if (!swiper.allowTouchMove) {\n        if (!e.target.matches(data.focusableElements)) {\n            swiper.allowClick = false;\n        }\n        if (data.isTouched) {\n            Object.assign(touches, {\n                startX: pageX,\n                startY: pageY,\n                currentX: pageX,\n                currentY: pageY\n            });\n            data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n        }\n        return;\n    }\n    if (params.touchReleaseOnEdges && !params.loop) {\n        if (swiper.isVertical()) {\n            // Vertical\n            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n                data.isTouched = false;\n                data.isMoved = false;\n                return;\n            }\n        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n            return;\n        }\n    }\n    if (document1.activeElement) {\n        if (e.target === document1.activeElement && e.target.matches(data.focusableElements)) {\n            data.isMoved = true;\n            swiper.allowClick = false;\n            return;\n        }\n    }\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchMove\", e);\n    }\n    touches.previousX = touches.currentX;\n    touches.previousY = touches.currentY;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    const diffX = touches.currentX - touches.startX;\n    const diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n    if (typeof data.isScrolling === \"undefined\") {\n        let touchAngle;\n        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n            data.isScrolling = false;\n        } else {\n            // eslint-disable-next-line\n            if (diffX * diffX + diffY * diffY >= 25) {\n                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n            }\n        }\n    }\n    if (data.isScrolling) {\n        swiper.emit(\"touchMoveOpposite\", e);\n    }\n    if (typeof data.startMoving === \"undefined\") {\n        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n            data.startMoving = true;\n        }\n    }\n    if (data.isScrolling) {\n        data.isTouched = false;\n        return;\n    }\n    if (!data.startMoving) {\n        return;\n    }\n    swiper.allowClick = false;\n    if (!params.cssMode && e.cancelable) {\n        e.preventDefault();\n    }\n    if (params.touchMoveStopPropagation && !params.nested) {\n        e.stopPropagation();\n    }\n    let diff = swiper.isHorizontal() ? diffX : diffY;\n    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n    if (params.oneWayMovement) {\n        diff = Math.abs(diff) * (rtl ? 1 : -1);\n        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n    }\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) {\n        diff = -diff;\n        touchesDiff = -touchesDiff;\n    }\n    const prevTouchesDirection = swiper.touchesDirection;\n    swiper.swipeDirection = diff > 0 ? \"prev\" : \"next\";\n    swiper.touchesDirection = touchesDiff > 0 ? \"prev\" : \"next\";\n    const isLoop = swiper.params.loop && !params.cssMode;\n    const allowLoopFix = swiper.touchesDirection === \"next\" && swiper.allowSlideNext || swiper.touchesDirection === \"prev\" && swiper.allowSlidePrev;\n    if (!data.isMoved) {\n        if (isLoop && allowLoopFix) {\n            swiper.loopFix({\n                direction: swiper.swipeDirection\n            });\n        }\n        data.startTranslate = swiper.getTranslate();\n        swiper.setTransition(0);\n        if (swiper.animating) {\n            const evt = new window.CustomEvent(\"transitionend\", {\n                bubbles: true,\n                cancelable: true\n            });\n            swiper.wrapperEl.dispatchEvent(evt);\n        }\n        data.allowMomentumBounce = false;\n        // Grab Cursor\n        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n            swiper.setGrabCursor(true);\n        }\n        swiper.emit(\"sliderFirstMove\", e);\n    }\n    let loopFixed;\n    new Date().getTime();\n    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n        Object.assign(touches, {\n            startX: pageX,\n            startY: pageY,\n            currentX: pageX,\n            currentY: pageY,\n            startTranslate: data.currentTranslate\n        });\n        data.loopSwapReset = true;\n        data.startTranslate = data.currentTranslate;\n        return;\n    }\n    swiper.emit(\"sliderMove\", e);\n    data.isMoved = true;\n    data.currentTranslate = diff + data.startTranslate;\n    let disableParentSwiper = true;\n    let resistanceRatio = params.resistanceRatio;\n    if (params.touchReleaseOnEdges) {\n        resistanceRatio = 0;\n    }\n    if (diff > 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {\n            swiper.loopFix({\n                direction: \"prev\",\n                setTranslate: true,\n                activeSlideIndex: 0\n            });\n        }\n        if (data.currentTranslate > swiper.minTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n            }\n        }\n    } else if (diff < 0) {\n        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {\n            swiper.loopFix({\n                direction: \"next\",\n                setTranslate: true,\n                activeSlideIndex: swiper.slides.length - (params.slidesPerView === \"auto\" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n            });\n        }\n        if (data.currentTranslate < swiper.maxTranslate()) {\n            disableParentSwiper = false;\n            if (params.resistance) {\n                data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n            }\n        }\n    }\n    if (disableParentSwiper) {\n        e.preventedByNestedSwiper = true;\n    }\n    // Directions locks\n    if (!swiper.allowSlideNext && swiper.swipeDirection === \"next\" && data.currentTranslate < data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === \"prev\" && data.currentTranslate > data.startTranslate) {\n        data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n        data.currentTranslate = data.startTranslate;\n    }\n    // Threshold\n    if (params.threshold > 0) {\n        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n            if (!data.allowThresholdMove) {\n                data.allowThresholdMove = true;\n                touches.startX = touches.currentX;\n                touches.startY = touches.currentY;\n                data.currentTranslate = data.startTranslate;\n                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n                return;\n            }\n        } else {\n            data.currentTranslate = data.startTranslate;\n            return;\n        }\n    }\n    if (!params.followFinger || params.cssMode) return;\n    // Update active index in free mode\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n        swiper.freeMode.onTouchMove();\n    }\n    // Update progress\n    swiper.updateProgress(data.currentTranslate);\n    // Update translate\n    swiper.setTranslate(data.currentTranslate);\n}\nfunction onTouchEnd(event) {\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    let targetTouch;\n    const isTouchEvent = e.type === \"touchend\" || e.type === \"touchcancel\";\n    if (!isTouchEvent) {\n        if (data.touchId !== null) return; // return from pointer if we use touch\n        if (e.pointerId !== data.pointerId) return;\n        targetTouch = e;\n    } else {\n        targetTouch = [\n            ...e.changedTouches\n        ].filter((t)=>t.identifier === data.touchId)[0];\n        if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n    }\n    if ([\n        \"pointercancel\",\n        \"pointerout\",\n        \"pointerleave\",\n        \"contextmenu\"\n    ].includes(e.type)) {\n        const proceed = [\n            \"pointercancel\",\n            \"contextmenu\"\n        ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n        if (!proceed) {\n            return;\n        }\n    }\n    data.pointerId = null;\n    data.touchId = null;\n    const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && e.pointerType === \"mouse\") return;\n    if (data.allowTouchCallbacks) {\n        swiper.emit(\"touchEnd\", e);\n    }\n    data.allowTouchCallbacks = false;\n    if (!data.isTouched) {\n        if (data.isMoved && params.grabCursor) {\n            swiper.setGrabCursor(false);\n        }\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    // Return Grab Cursor\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(false);\n    }\n    // Time diff\n    const touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    // Tap, doubleTap, Click\n    if (swiper.allowClick) {\n        const pathTree = e.path || e.composedPath && e.composedPath();\n        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n        swiper.emit(\"tap click\", e);\n        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n            swiper.emit(\"doubleTap doubleClick\", e);\n        }\n    }\n    data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(()=>{\n        if (!swiper.destroyed) swiper.allowClick = true;\n    });\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n        data.isTouched = false;\n        data.isMoved = false;\n        data.startMoving = false;\n        return;\n    }\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    let currentPos;\n    if (params.followFinger) {\n        currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n        currentPos = -data.currentTranslate;\n    }\n    if (params.cssMode) {\n        return;\n    }\n    if (params.freeMode && params.freeMode.enabled) {\n        swiper.freeMode.onTouchEnd({\n            currentPos\n        });\n        return;\n    }\n    // Find current slide\n    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n    let stopIndex = 0;\n    let groupSize = swiper.slidesSizesGrid[0];\n    for(let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){\n        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n        if (typeof slidesGrid[i + increment] !== \"undefined\") {\n            if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n                stopIndex = i;\n                groupSize = slidesGrid[i + increment] - slidesGrid[i];\n            }\n        } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n            stopIndex = i;\n            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n        }\n    }\n    let rewindFirstIndex = null;\n    let rewindLastIndex = null;\n    if (params.rewind) {\n        if (swiper.isBeginning) {\n            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n        } else if (swiper.isEnd) {\n            rewindFirstIndex = 0;\n        }\n    }\n    // Find current slide size\n    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (timeDiff > params.longSwipesMs) {\n        // Long touches\n        if (!params.longSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        if (swiper.swipeDirection === \"next\") {\n            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n            else swiper.slideTo(stopIndex);\n        }\n        if (swiper.swipeDirection === \"prev\") {\n            if (ratio > 1 - params.longSwipesRatio) {\n                swiper.slideTo(stopIndex + increment);\n            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n                swiper.slideTo(rewindLastIndex);\n            } else {\n                swiper.slideTo(stopIndex);\n            }\n        }\n    } else {\n        // Short swipes\n        if (!params.shortSwipes) {\n            swiper.slideTo(swiper.activeIndex);\n            return;\n        }\n        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n        if (!isNavButtonTarget) {\n            if (swiper.swipeDirection === \"next\") {\n                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n            }\n            if (swiper.swipeDirection === \"prev\") {\n                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n            }\n        } else if (e.target === swiper.navigation.nextEl) {\n            swiper.slideTo(stopIndex + increment);\n        } else {\n            swiper.slideTo(stopIndex);\n        }\n    }\n}\nfunction onResize() {\n    const swiper = this;\n    const { params, el } = swiper;\n    if (el && el.offsetWidth === 0) return;\n    // Breakpoints\n    if (params.breakpoints) {\n        swiper.setBreakpoint();\n    }\n    // Save locks\n    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    // Disable locks on resize\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n    const isVirtualLoop = isVirtual && params.loop;\n    if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n        if (swiper.params.loop && !isVirtual) {\n            swiper.slideToLoop(swiper.realIndex, 0, false, true);\n        } else {\n            swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n    }\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        clearTimeout(swiper.autoplay.resizeTimeout);\n        swiper.autoplay.resizeTimeout = setTimeout(()=>{\n            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n                swiper.autoplay.resume();\n            }\n        }, 500);\n    }\n    // Return locks after resize\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n    }\n}\nfunction onClick(e) {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    if (!swiper.allowClick) {\n        if (swiper.params.preventClicks) e.preventDefault();\n        if (swiper.params.preventClicksPropagation && swiper.animating) {\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n        }\n    }\n}\nfunction onScroll() {\n    const swiper = this;\n    const { wrapperEl, rtlTranslate, enabled } = swiper;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n    if (swiper.isHorizontal()) {\n        swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n        swiper.translate = -wrapperEl.scrollTop;\n    }\n    // eslint-disable-next-line\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n        newProgress = 0;\n    } else {\n        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== swiper.progress) {\n        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n    swiper.emit(\"setTranslate\", swiper.translate, false);\n}\nfunction onLoad(e) {\n    const swiper = this;\n    processLazyPreloader(swiper, e.target);\n    if (swiper.params.cssMode || swiper.params.slidesPerView !== \"auto\" && !swiper.params.autoHeight) {\n        return;\n    }\n    swiper.update();\n}\nfunction onDocumentTouchStart() {\n    const swiper = this;\n    if (swiper.documentTouchHandlerProceeded) return;\n    swiper.documentTouchHandlerProceeded = true;\n    if (swiper.params.touchReleaseOnEdges) {\n        swiper.el.style.touchAction = \"auto\";\n    }\n}\nconst events = (swiper, method)=>{\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const { params, el, wrapperEl, device } = swiper;\n    const capture = !!params.nested;\n    const domMethod = method === \"on\" ? \"addEventListener\" : \"removeEventListener\";\n    const swiperMethod = method;\n    // Touch Events\n    document1[domMethod](\"touchstart\", swiper.onDocumentTouchStart, {\n        passive: false,\n        capture\n    });\n    el[domMethod](\"touchstart\", swiper.onTouchStart, {\n        passive: false\n    });\n    el[domMethod](\"pointerdown\", swiper.onTouchStart, {\n        passive: false\n    });\n    document1[domMethod](\"touchmove\", swiper.onTouchMove, {\n        passive: false,\n        capture\n    });\n    document1[domMethod](\"pointermove\", swiper.onTouchMove, {\n        passive: false,\n        capture\n    });\n    document1[domMethod](\"touchend\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerup\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointercancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"touchcancel\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerout\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"pointerleave\", swiper.onTouchEnd, {\n        passive: true\n    });\n    document1[domMethod](\"contextmenu\", swiper.onTouchEnd, {\n        passive: true\n    });\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n        el[domMethod](\"click\", swiper.onClick, true);\n    }\n    if (params.cssMode) {\n        wrapperEl[domMethod](\"scroll\", swiper.onScroll);\n    }\n    // Resize handler\n    if (params.updateOnWindowResize) {\n        swiper[swiperMethod](device.ios || device.android ? \"resize orientationchange observerUpdate\" : \"resize observerUpdate\", onResize, true);\n    } else {\n        swiper[swiperMethod](\"observerUpdate\", onResize, true);\n    }\n    // Images loader\n    el[domMethod](\"load\", swiper.onLoad, {\n        capture: true\n    });\n};\nfunction attachEvents() {\n    const swiper = this;\n    const { params } = swiper;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n    if (params.cssMode) {\n        swiper.onScroll = onScroll.bind(swiper);\n    }\n    swiper.onClick = onClick.bind(swiper);\n    swiper.onLoad = onLoad.bind(swiper);\n    events(swiper, \"on\");\n}\nfunction detachEvents() {\n    const swiper = this;\n    events(swiper, \"off\");\n}\nvar events$1 = {\n    attachEvents,\n    detachEvents\n};\nconst isGridEnabled = (swiper, params)=>{\n    return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n    const swiper = this;\n    const { realIndex, initialized, params, el } = swiper;\n    const breakpoints = params.breakpoints;\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n    // Get breakpoint for window width and update parameters\n    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = isGridEnabled(swiper, params);\n    const isMultiRow = isGridEnabled(swiper, breakpointParams);\n    const wasEnabled = params.enabled;\n    if (wasMultiRow && !isMultiRow) {\n        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n        swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n        el.classList.add(`${params.containerModifierClass}grid`);\n        if (breakpointParams.grid.fill && breakpointParams.grid.fill === \"column\" || !breakpointParams.grid.fill && params.grid.fill === \"column\") {\n            el.classList.add(`${params.containerModifierClass}grid-column`);\n        }\n        swiper.emitContainerClasses();\n    }\n    // Toggle navigation, pagination, scrollbar\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach((prop)=>{\n        if (typeof breakpointParams[prop] === \"undefined\") return;\n        const wasModuleEnabled = params[prop] && params[prop].enabled;\n        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n        if (wasModuleEnabled && !isModuleEnabled) {\n            swiper[prop].disable();\n        }\n        if (!wasModuleEnabled && isModuleEnabled) {\n            swiper[prop].enable();\n        }\n    });\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n    const wasLoop = params.loop;\n    if (directionChanged && initialized) {\n        swiper.changeDirection();\n    }\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(swiper.params, breakpointParams);\n    const isEnabled = swiper.params.enabled;\n    const hasLoop = swiper.params.loop;\n    Object.assign(swiper, {\n        allowTouchMove: swiper.params.allowTouchMove,\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev\n    });\n    if (wasEnabled && !isEnabled) {\n        swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n        swiper.enable();\n    }\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit(\"_beforeBreakpoint\", breakpointParams);\n    if (initialized) {\n        if (needsReLoop) {\n            swiper.loopDestroy();\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (!wasLoop && hasLoop) {\n            swiper.loopCreate(realIndex);\n            swiper.updateSlides();\n        } else if (wasLoop && !hasLoop) {\n            swiper.loopDestroy();\n        }\n    }\n    swiper.emit(\"breakpoint\", breakpointParams);\n}\nfunction getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n        base = \"window\";\n    }\n    if (!breakpoints || base === \"container\" && !containerEl) return undefined;\n    let breakpoint = false;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const currentHeight = base === \"window\" ? window1.innerHeight : containerEl.clientHeight;\n    const points = Object.keys(breakpoints).map((point)=>{\n        if (typeof point === \"string\" && point.indexOf(\"@\") === 0) {\n            const minRatio = parseFloat(point.substr(1));\n            const value = currentHeight * minRatio;\n            return {\n                value,\n                point\n            };\n        }\n        return {\n            value: point,\n            point\n        };\n    });\n    points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));\n    for(let i = 0; i < points.length; i += 1){\n        const { point, value } = points[i];\n        if (base === \"window\") {\n            if (window1.matchMedia(`(min-width: ${value}px)`).matches) {\n                breakpoint = point;\n            }\n        } else if (value <= containerEl.clientWidth) {\n            breakpoint = point;\n        }\n    }\n    return breakpoint || \"max\";\n}\nvar breakpoints = {\n    setBreakpoint,\n    getBreakpoint\n};\nfunction prepareClasses(entries, prefix) {\n    const resultClasses = [];\n    entries.forEach((item)=>{\n        if (typeof item === \"object\") {\n            Object.keys(item).forEach((classNames)=>{\n                if (item[classNames]) {\n                    resultClasses.push(prefix + classNames);\n                }\n            });\n        } else if (typeof item === \"string\") {\n            resultClasses.push(prefix + item);\n        }\n    });\n    return resultClasses;\n}\nfunction addClasses() {\n    const swiper = this;\n    const { classNames, params, rtl, el, device } = swiper;\n    // prettier-ignore\n    const suffixes = prepareClasses([\n        \"initialized\",\n        params.direction,\n        {\n            \"free-mode\": swiper.params.freeMode && params.freeMode.enabled\n        },\n        {\n            \"autoheight\": params.autoHeight\n        },\n        {\n            \"rtl\": rtl\n        },\n        {\n            \"grid\": params.grid && params.grid.rows > 1\n        },\n        {\n            \"grid-column\": params.grid && params.grid.rows > 1 && params.grid.fill === \"column\"\n        },\n        {\n            \"android\": device.android\n        },\n        {\n            \"ios\": device.ios\n        },\n        {\n            \"css-mode\": params.cssMode\n        },\n        {\n            \"centered\": params.cssMode && params.centeredSlides\n        },\n        {\n            \"watch-progress\": params.watchSlidesProgress\n        }\n    ], params.containerModifierClass);\n    classNames.push(...suffixes);\n    el.classList.add(...classNames);\n    swiper.emitContainerClasses();\n}\nfunction removeClasses() {\n    const swiper = this;\n    const { el, classNames } = swiper;\n    el.classList.remove(...classNames);\n    swiper.emitContainerClasses();\n}\nvar classes = {\n    addClasses,\n    removeClasses\n};\nfunction checkOverflow() {\n    const swiper = this;\n    const { isLocked: wasLocked, params } = swiper;\n    const { slidesOffsetBefore } = params;\n    if (slidesOffsetBefore) {\n        const lastSlideIndex = swiper.slides.length - 1;\n        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n        swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n        swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n    if (params.allowSlideNext === true) {\n        swiper.allowSlideNext = !swiper.isLocked;\n    }\n    if (params.allowSlidePrev === true) {\n        swiper.allowSlidePrev = !swiper.isLocked;\n    }\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n        swiper.isEnd = false;\n    }\n    if (wasLocked !== swiper.isLocked) {\n        swiper.emit(swiper.isLocked ? \"lock\" : \"unlock\");\n    }\n}\nvar checkOverflow$1 = {\n    checkOverflow\n};\nvar defaults = {\n    init: true,\n    direction: \"horizontal\",\n    oneWayMovement: false,\n    touchEventsTarget: \"wrapper\",\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    eventsPrefix: \"swiper\",\n    enabled: true,\n    focusableElements: \"input, select, option, textarea, button, video, label\",\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: \"slide\",\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: \"window\",\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 5,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // loop\n    loop: false,\n    loopAddBlankSlides: true,\n    loopAdditionalSlides: 0,\n    loopPreventsSliding: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: \"swiper-no-swiping\",\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: \"swiper-\",\n    // NEW\n    slideClass: \"swiper-slide\",\n    slideBlankClass: \"swiper-slide-blank\",\n    slideActiveClass: \"swiper-slide-active\",\n    slideVisibleClass: \"swiper-slide-visible\",\n    slideFullyVisibleClass: \"swiper-slide-fully-visible\",\n    slideNextClass: \"swiper-slide-next\",\n    slidePrevClass: \"swiper-slide-prev\",\n    wrapperClass: \"swiper-wrapper\",\n    lazyPreloaderClass: \"swiper-lazy-preloader\",\n    lazyPreloadPrevNext: 0,\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false\n};\nfunction moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n        if (obj === void 0) {\n            obj = {};\n        }\n        const moduleParamName = Object.keys(obj)[0];\n        const moduleParams = obj[moduleParamName];\n        if (typeof moduleParams !== \"object\" || moduleParams === null) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(allModulesParams, obj);\n            return;\n        }\n        if (params[moduleParamName] === true) {\n            params[moduleParamName] = {\n                enabled: true\n            };\n        }\n        if (moduleParamName === \"navigation\" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n            params[moduleParamName].auto = true;\n        }\n        if ([\n            \"pagination\",\n            \"scrollbar\"\n        ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n            params[moduleParamName].auto = true;\n        }\n        if (!(moduleParamName in params && \"enabled\" in moduleParams)) {\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(allModulesParams, obj);\n            return;\n        }\n        if (typeof params[moduleParamName] === \"object\" && !(\"enabled\" in params[moduleParamName])) {\n            params[moduleParamName].enabled = true;\n        }\n        if (!params[moduleParamName]) params[moduleParamName] = {\n            enabled: false\n        };\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(allModulesParams, obj);\n    };\n}\n/* eslint no-param-reassign: \"off\" */ const prototypes = {\n    eventsEmitter,\n    update,\n    translate,\n    transition,\n    slide,\n    loop,\n    grabCursor,\n    events: events$1,\n    breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n    constructor(){\n        let el;\n        let params;\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === \"Object\") {\n            params = args[0];\n        } else {\n            [el, params] = args;\n        }\n        if (!params) params = {};\n        params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, params);\n        if (el && !params.el) params.el = el;\n        const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n        if (params.el && typeof params.el === \"string\" && document1.querySelectorAll(params.el).length > 1) {\n            const swipers = [];\n            document1.querySelectorAll(params.el).forEach((containerEl)=>{\n                const newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, params, {\n                    el: containerEl\n                });\n                swipers.push(new Swiper(newParams));\n            });\n            // eslint-disable-next-line no-constructor-return\n            return swipers;\n        }\n        // Swiper Instance\n        const swiper = this;\n        swiper.__swiper__ = true;\n        swiper.support = getSupport();\n        swiper.device = getDevice({\n            userAgent: params.userAgent\n        });\n        swiper.browser = getBrowser();\n        swiper.eventsListeners = {};\n        swiper.eventsAnyListeners = [];\n        swiper.modules = [\n            ...swiper.__modules__\n        ];\n        if (params.modules && Array.isArray(params.modules)) {\n            swiper.modules.push(...params.modules);\n        }\n        const allModulesParams = {};\n        swiper.modules.forEach((mod)=>{\n            mod({\n                params,\n                swiper,\n                extendParams: moduleExtendParams(params, allModulesParams),\n                on: swiper.on.bind(swiper),\n                once: swiper.once.bind(swiper),\n                off: swiper.off.bind(swiper),\n                emit: swiper.emit.bind(swiper)\n            });\n        });\n        // Extend defaults with modules params\n        const swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, defaults, allModulesParams);\n        // Extend defaults with passed params\n        swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, swiperParams, extendedDefaults, params);\n        swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, swiper.params);\n        swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)({}, params);\n        // add event listeners\n        if (swiper.params && swiper.params.on) {\n            Object.keys(swiper.params.on).forEach((eventName)=>{\n                swiper.on(eventName, swiper.params.on[eventName]);\n            });\n        }\n        if (swiper.params && swiper.params.onAny) {\n            swiper.onAny(swiper.params.onAny);\n        }\n        // Extend Swiper\n        Object.assign(swiper, {\n            enabled: swiper.params.enabled,\n            el,\n            // Classes\n            classNames: [],\n            // Slides\n            slides: [],\n            slidesGrid: [],\n            snapGrid: [],\n            slidesSizesGrid: [],\n            // isDirection\n            isHorizontal () {\n                return swiper.params.direction === \"horizontal\";\n            },\n            isVertical () {\n                return swiper.params.direction === \"vertical\";\n            },\n            // Indexes\n            activeIndex: 0,\n            realIndex: 0,\n            //\n            isBeginning: true,\n            isEnd: false,\n            // Props\n            translate: 0,\n            previousTranslate: 0,\n            progress: 0,\n            velocity: 0,\n            animating: false,\n            cssOverflowAdjustment () {\n                // Returns 0 unless `translate` is > 2**23\n                // Should be subtracted from css values to prevent overflow\n                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n            },\n            // Locks\n            allowSlideNext: swiper.params.allowSlideNext,\n            allowSlidePrev: swiper.params.allowSlidePrev,\n            // Touch Events\n            touchEventsData: {\n                isTouched: undefined,\n                isMoved: undefined,\n                allowTouchCallbacks: undefined,\n                touchStartTime: undefined,\n                isScrolling: undefined,\n                currentTranslate: undefined,\n                startTranslate: undefined,\n                allowThresholdMove: undefined,\n                // Form elements to match\n                focusableElements: swiper.params.focusableElements,\n                // Last click time\n                lastClickTime: 0,\n                clickTimeout: undefined,\n                // Velocities\n                velocities: [],\n                allowMomentumBounce: undefined,\n                startMoving: undefined,\n                pointerId: null,\n                touchId: null\n            },\n            // Clicks\n            allowClick: true,\n            // Touches\n            allowTouchMove: swiper.params.allowTouchMove,\n            touches: {\n                startX: 0,\n                startY: 0,\n                currentX: 0,\n                currentY: 0,\n                diff: 0\n            },\n            // Images\n            imagesToLoad: [],\n            imagesLoaded: 0\n        });\n        swiper.emit(\"_swiper\");\n        // Init\n        if (swiper.params.init) {\n            swiper.init();\n        }\n        // Return app instance\n        // eslint-disable-next-line no-constructor-return\n        return swiper;\n    }\n    getDirectionLabel(property) {\n        if (this.isHorizontal()) {\n            return property;\n        }\n        // prettier-ignore\n        return ({\n            \"width\": \"height\",\n            \"margin-top\": \"margin-left\",\n            \"margin-bottom \": \"margin-right\",\n            \"margin-left\": \"margin-top\",\n            \"margin-right\": \"margin-bottom\",\n            \"padding-left\": \"padding-top\",\n            \"padding-right\": \"padding-bottom\",\n            \"marginRight\": \"marginBottom\"\n        })[property];\n    }\n    getSlideIndex(slideEl) {\n        const { slidesEl, params } = this;\n        const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n        const firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(slides[0]);\n        return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(slideEl) - firstSlideIndex;\n    }\n    getSlideIndexByData(index) {\n        return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute(\"data-swiper-slide-index\") * 1 === index)[0]);\n    }\n    recalcSlides() {\n        const swiper = this;\n        const { slidesEl, params } = swiper;\n        swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n    }\n    enable() {\n        const swiper = this;\n        if (swiper.enabled) return;\n        swiper.enabled = true;\n        if (swiper.params.grabCursor) {\n            swiper.setGrabCursor();\n        }\n        swiper.emit(\"enable\");\n    }\n    disable() {\n        const swiper = this;\n        if (!swiper.enabled) return;\n        swiper.enabled = false;\n        if (swiper.params.grabCursor) {\n            swiper.unsetGrabCursor();\n        }\n        swiper.emit(\"disable\");\n    }\n    setProgress(progress, speed) {\n        const swiper = this;\n        progress = Math.min(Math.max(progress, 0), 1);\n        const min = swiper.minTranslate();\n        const max = swiper.maxTranslate();\n        const current = (max - min) * progress + min;\n        swiper.translateTo(current, typeof speed === \"undefined\" ? 0 : speed);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n    }\n    emitContainerClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const cls = swiper.el.className.split(\" \").filter((className)=>{\n            return className.indexOf(\"swiper\") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n        });\n        swiper.emit(\"_containerClasses\", cls.join(\" \"));\n    }\n    getSlideClasses(slideEl) {\n        const swiper = this;\n        if (swiper.destroyed) return \"\";\n        return slideEl.className.split(\" \").filter((className)=>{\n            return className.indexOf(\"swiper-slide\") === 0 || className.indexOf(swiper.params.slideClass) === 0;\n        }).join(\" \");\n    }\n    emitSlidesClasses() {\n        const swiper = this;\n        if (!swiper.params._emitClasses || !swiper.el) return;\n        const updates = [];\n        swiper.slides.forEach((slideEl)=>{\n            const classNames = swiper.getSlideClasses(slideEl);\n            updates.push({\n                slideEl,\n                classNames\n            });\n            swiper.emit(\"_slideClass\", slideEl, classNames);\n        });\n        swiper.emit(\"_slideClasses\", updates);\n    }\n    slidesPerViewDynamic(view, exact) {\n        if (view === void 0) {\n            view = \"current\";\n        }\n        if (exact === void 0) {\n            exact = false;\n        }\n        const swiper = this;\n        const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n        let spv = 1;\n        if (typeof params.slidesPerView === \"number\") return params.slidesPerView;\n        if (params.centeredSlides) {\n            let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n            let breakLoop;\n            for(let i = activeIndex + 1; i < slides.length; i += 1){\n                if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            }\n            for(let i = activeIndex - 1; i >= 0; i -= 1){\n                if (slides[i] && !breakLoop) {\n                    slideSize += slides[i].swiperSlideSize;\n                    spv += 1;\n                    if (slideSize > swiperSize) breakLoop = true;\n                }\n            }\n        } else {\n            // eslint-disable-next-line\n            if (view === \"current\") {\n                for(let i = activeIndex + 1; i < slides.length; i += 1){\n                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n                    if (slideInView) {\n                        spv += 1;\n                    }\n                }\n            } else {\n                // previous\n                for(let i = activeIndex - 1; i >= 0; i -= 1){\n                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n                    if (slideInView) {\n                        spv += 1;\n                    }\n                }\n            }\n        }\n        return spv;\n    }\n    update() {\n        const swiper = this;\n        if (!swiper || swiper.destroyed) return;\n        const { snapGrid, params } = swiper;\n        // Breakpoints\n        if (params.breakpoints) {\n            swiper.setBreakpoint();\n        }\n        [\n            ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n        ].forEach((imageEl)=>{\n            if (imageEl.complete) {\n                processLazyPreloader(swiper, imageEl);\n            }\n        });\n        swiper.updateSize();\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        function setTranslate() {\n            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n            swiper.setTranslate(newTranslate);\n            swiper.updateActiveIndex();\n            swiper.updateSlidesClasses();\n        }\n        let translated;\n        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n            setTranslate();\n            if (params.autoHeight) {\n                swiper.updateAutoHeight();\n            }\n        } else {\n            if ((params.slidesPerView === \"auto\" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n                translated = swiper.slideTo(slides.length - 1, 0, false, true);\n            } else {\n                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n            }\n            if (!translated) {\n                setTranslate();\n            }\n        }\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n            swiper.checkOverflow();\n        }\n        swiper.emit(\"update\");\n    }\n    changeDirection(newDirection, needUpdate) {\n        if (needUpdate === void 0) {\n            needUpdate = true;\n        }\n        const swiper = this;\n        const currentDirection = swiper.params.direction;\n        if (!newDirection) {\n            // eslint-disable-next-line\n            newDirection = currentDirection === \"horizontal\" ? \"vertical\" : \"horizontal\";\n        }\n        if (newDirection === currentDirection || newDirection !== \"horizontal\" && newDirection !== \"vertical\") {\n            return swiper;\n        }\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n        swiper.emitContainerClasses();\n        swiper.params.direction = newDirection;\n        swiper.slides.forEach((slideEl)=>{\n            if (newDirection === \"vertical\") {\n                slideEl.style.width = \"\";\n            } else {\n                slideEl.style.height = \"\";\n            }\n        });\n        swiper.emit(\"changeDirection\");\n        if (needUpdate) swiper.update();\n        return swiper;\n    }\n    changeLanguageDirection(direction) {\n        const swiper = this;\n        if (swiper.rtl && direction === \"rtl\" || !swiper.rtl && direction === \"ltr\") return;\n        swiper.rtl = direction === \"rtl\";\n        swiper.rtlTranslate = swiper.params.direction === \"horizontal\" && swiper.rtl;\n        if (swiper.rtl) {\n            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n            swiper.el.dir = \"rtl\";\n        } else {\n            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n            swiper.el.dir = \"ltr\";\n        }\n        swiper.update();\n    }\n    mount(element) {\n        const swiper = this;\n        if (swiper.mounted) return true;\n        // Find el\n        let el = element || swiper.params.el;\n        if (typeof el === \"string\") {\n            el = document.querySelector(el);\n        }\n        if (!el) {\n            return false;\n        }\n        el.swiper = swiper;\n        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === \"SWIPER-CONTAINER\") {\n            swiper.isElement = true;\n        }\n        const getWrapperSelector = ()=>{\n            return `.${(swiper.params.wrapperClass || \"\").trim().split(\" \").join(\".\")}`;\n        };\n        const getWrapper = ()=>{\n            if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n                const res = el.shadowRoot.querySelector(getWrapperSelector());\n                // Children needs to return slot items\n                return res;\n            }\n            return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];\n        };\n        // Find Wrapper\n        let wrapperEl = getWrapper();\n        if (!wrapperEl && swiper.params.createElements) {\n            wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(\"div\", swiper.params.wrapperClass);\n            el.append(wrapperEl);\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{\n                wrapperEl.append(slideEl);\n            });\n        }\n        Object.assign(swiper, {\n            el,\n            wrapperEl,\n            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n            hostEl: swiper.isElement ? el.parentNode.host : el,\n            mounted: true,\n            // RTL\n            rtl: el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"direction\") === \"rtl\",\n            rtlTranslate: swiper.params.direction === \"horizontal\" && (el.dir.toLowerCase() === \"rtl\" || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(el, \"direction\") === \"rtl\"),\n            wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(wrapperEl, \"display\") === \"-webkit-box\"\n        });\n        return true;\n    }\n    init(el) {\n        const swiper = this;\n        if (swiper.initialized) return swiper;\n        const mounted = swiper.mount(el);\n        if (mounted === false) return swiper;\n        swiper.emit(\"beforeInit\");\n        // Set breakpoint\n        if (swiper.params.breakpoints) {\n            swiper.setBreakpoint();\n        }\n        // Add Classes\n        swiper.addClasses();\n        // Update size\n        swiper.updateSize();\n        // Update slides\n        swiper.updateSlides();\n        if (swiper.params.watchOverflow) {\n            swiper.checkOverflow();\n        }\n        // Set Grab Cursor\n        if (swiper.params.grabCursor && swiper.enabled) {\n            swiper.setGrabCursor();\n        }\n        // Slide To Initial Slide\n        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n            swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n        } else {\n            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n        }\n        // Create loop\n        if (swiper.params.loop) {\n            swiper.loopCreate();\n        }\n        // Attach events\n        swiper.attachEvents();\n        const lazyElements = [\n            ...swiper.el.querySelectorAll('[loading=\"lazy\"]')\n        ];\n        if (swiper.isElement) {\n            lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n        }\n        lazyElements.forEach((imageEl)=>{\n            if (imageEl.complete) {\n                processLazyPreloader(swiper, imageEl);\n            } else {\n                imageEl.addEventListener(\"load\", (e)=>{\n                    processLazyPreloader(swiper, e.target);\n                });\n            }\n        });\n        preload(swiper);\n        // Init Flag\n        swiper.initialized = true;\n        preload(swiper);\n        // Emit\n        swiper.emit(\"init\");\n        swiper.emit(\"afterInit\");\n        return swiper;\n    }\n    destroy(deleteInstance, cleanStyles) {\n        if (deleteInstance === void 0) {\n            deleteInstance = true;\n        }\n        if (cleanStyles === void 0) {\n            cleanStyles = true;\n        }\n        const swiper = this;\n        const { params, el, wrapperEl, slides } = swiper;\n        if (typeof swiper.params === \"undefined\" || swiper.destroyed) {\n            return null;\n        }\n        swiper.emit(\"beforeDestroy\");\n        // Init Flag\n        swiper.initialized = false;\n        // Detach events\n        swiper.detachEvents();\n        // Destroy loop\n        if (params.loop) {\n            swiper.loopDestroy();\n        }\n        // Cleanup styles\n        if (cleanStyles) {\n            swiper.removeClasses();\n            el.removeAttribute(\"style\");\n            wrapperEl.removeAttribute(\"style\");\n            if (slides && slides.length) {\n                slides.forEach((slideEl)=>{\n                    slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n                    slideEl.removeAttribute(\"style\");\n                    slideEl.removeAttribute(\"data-swiper-slide-index\");\n                });\n            }\n        }\n        swiper.emit(\"destroy\");\n        // Detach emitter events\n        Object.keys(swiper.eventsListeners).forEach((eventName)=>{\n            swiper.off(eventName);\n        });\n        if (deleteInstance !== false) {\n            swiper.el.swiper = null;\n            (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.u)(swiper);\n        }\n        swiper.destroyed = true;\n        return null;\n    }\n    static extendDefaults(newDefaults) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.t)(extendedDefaults, newDefaults);\n    }\n    static get extendedDefaults() {\n        return extendedDefaults;\n    }\n    static get defaults() {\n        return defaults;\n    }\n    static installModule(mod) {\n        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n        const modules = Swiper.prototype.__modules__;\n        if (typeof mod === \"function\" && modules.indexOf(mod) < 0) {\n            modules.push(mod);\n        }\n    }\n    static use(module) {\n        if (Array.isArray(module)) {\n            module.forEach((m)=>Swiper.installModule(m));\n            return Swiper;\n        }\n        Swiper.installModule(module);\n        return Swiper;\n    }\n}\nObject.keys(prototypes).forEach((prototypeGroup)=>{\n    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{\n        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n});\nSwiper.use([\n    Resize,\n    Observer\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC9zd2lwZXItY29yZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUN3UTtBQUVoVixJQUFJa0M7QUFDSixTQUFTQztJQUNQLE1BQU1DLFVBQVNuQyxzREFBU0E7SUFDeEIsTUFBTW9DLFlBQVdsQyxzREFBV0E7SUFDNUIsT0FBTztRQUNMbUMsY0FBY0QsVUFBU0UsZUFBZSxJQUFJRixVQUFTRSxlQUFlLENBQUNDLEtBQUssSUFBSSxvQkFBb0JILFVBQVNFLGVBQWUsQ0FBQ0MsS0FBSztRQUM5SEMsT0FBTyxDQUFDLENBQUUsbUJBQWtCTCxXQUFVQSxRQUFPTSxhQUFhLElBQUlMLHFCQUFvQkQsUUFBT00sYUFBYTtJQUN4RztBQUNGO0FBQ0EsU0FBU0M7SUFDUCxJQUFJLENBQUNULFNBQVM7UUFDWkEsVUFBVUM7SUFDWjtJQUNBLE9BQU9EO0FBQ1Q7QUFFQSxJQUFJVTtBQUNKLFNBQVNDLFdBQVdDLEtBQUs7SUFDdkIsSUFBSSxFQUNGQyxTQUFTLEVBQ1YsR0FBR0QsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUM1QixNQUFNWixVQUFVUztJQUNoQixNQUFNUCxVQUFTbkMsc0RBQVNBO0lBQ3hCLE1BQU0rQyxXQUFXWixRQUFPYSxTQUFTLENBQUNELFFBQVE7SUFDMUMsTUFBTUUsS0FBS0gsYUFBYVgsUUFBT2EsU0FBUyxDQUFDRixTQUFTO0lBQ2xELE1BQU1JLFNBQVM7UUFDYkMsS0FBSztRQUNMQyxTQUFTO0lBQ1g7SUFDQSxNQUFNQyxjQUFjbEIsUUFBT21CLE1BQU0sQ0FBQ0MsS0FBSztJQUN2QyxNQUFNQyxlQUFlckIsUUFBT21CLE1BQU0sQ0FBQ0csTUFBTTtJQUN6QyxNQUFNTCxVQUFVSCxHQUFHUyxLQUFLLENBQUMsZ0NBQWdDLHNCQUFzQjtJQUMvRSxJQUFJQyxPQUFPVixHQUFHUyxLQUFLLENBQUM7SUFDcEIsTUFBTUUsT0FBT1gsR0FBR1MsS0FBSyxDQUFDO0lBQ3RCLE1B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QUN6RTtBQUNGO0FBQ0F6RCxPQUFPc0QsR0FBRyxDQUFDO0lBQUMzckI7SUFBUWlDO0NBQVM7QUFFUyIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYWdvbmFscy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3N3aXBlci1jb3JlLm1qcz9mMmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgZ2V0V2luZG93LCBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi9zc3Itd2luZG93LmVzbS5tanMnO1xuaW1wb3J0IHsgYSBhcyBlbGVtZW50UGFyZW50cywgbSBhcyBlbGVtZW50U3R5bGUsIGUgYXMgZWxlbWVudENoaWxkcmVuLCBzIGFzIHNldENTU1Byb3BlcnR5LCBmIGFzIGVsZW1lbnRPdXRlclNpemUsIG8gYXMgZWxlbWVudE5leHRBbGwsIHAgYXMgZWxlbWVudFByZXZBbGwsIGkgYXMgZ2V0VHJhbnNsYXRlLCBxIGFzIGFuaW1hdGVDU1NNb2RlU2Nyb2xsLCBuIGFzIG5leHRUaWNrLCByIGFzIHNob3dXYXJuaW5nLCBjIGFzIGNyZWF0ZUVsZW1lbnQsIGQgYXMgbm93LCB0IGFzIGV4dGVuZCwgZyBhcyBlbGVtZW50SW5kZXgsIHUgYXMgZGVsZXRlUHJvcHMgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmxldCBzdXBwb3J0O1xuZnVuY3Rpb24gY2FsY1N1cHBvcnQoKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIHJldHVybiB7XG4gICAgc21vb3RoU2Nyb2xsOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmICdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgIHRvdWNoOiAhISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuRG9jdW1lbnRUb3VjaClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1cHBvcnQoKSB7XG4gIGlmICghc3VwcG9ydCkge1xuICAgIHN1cHBvcnQgPSBjYWxjU3VwcG9ydCgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0O1xufVxuXG5sZXQgZGV2aWNlQ2FjaGVkO1xuZnVuY3Rpb24gY2FsY0RldmljZShfdGVtcCkge1xuICBsZXQge1xuICAgIHVzZXJBZ2VudFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IHN1cHBvcnQgPSBnZXRTdXBwb3J0KCk7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBjb25zdCBwbGF0Zm9ybSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm07XG4gIGNvbnN0IHVhID0gdXNlckFnZW50IHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgaW9zOiBmYWxzZSxcbiAgICBhbmRyb2lkOiBmYWxzZVxuICB9O1xuICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4ud2lkdGg7XG4gIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5zY3JlZW4uaGVpZ2h0O1xuICBjb25zdCBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGxldCBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgY29uc3QgaXBvZCA9IHVhLm1hdGNoKC8oaVBvZCkoLipPU1xccyhbXFxkX10rKSk/Lyk7XG4gIGNvbnN0IGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1N8aU9TKVxccyhbXFxkX10rKS8pO1xuICBjb25zdCB3aW5kb3dzID0gcGxhdGZvcm0gPT09ICdXaW4zMic7XG4gIGxldCBtYWNvcyA9IHBsYXRmb3JtID09PSAnTWFjSW50ZWwnO1xuXG4gIC8vIGlQYWRPcyAxMyBmaXhcbiAgY29uc3QgaVBhZFNjcmVlbnMgPSBbJzEwMjR4MTM2NicsICcxMzY2eDEwMjQnLCAnODM0eDExOTQnLCAnMTE5NHg4MzQnLCAnODM0eDExMTInLCAnMTExMng4MzQnLCAnNzY4eDEwMjQnLCAnMTAyNHg3NjgnLCAnODIweDExODAnLCAnMTE4MHg4MjAnLCAnODEweDEwODAnLCAnMTA4MHg4MTAnXTtcbiAgaWYgKCFpcGFkICYmIG1hY29zICYmIHN1cHBvcnQudG91Y2ggJiYgaVBhZFNjcmVlbnMuaW5kZXhPZihgJHtzY3JlZW5XaWR0aH14JHtzY3JlZW5IZWlnaHR9YCkgPj0gMCkge1xuICAgIGlwYWQgPSB1YS5tYXRjaCgvKFZlcnNpb24pXFwvKFtcXGQuXSspLyk7XG4gICAgaWYgKCFpcGFkKSBpcGFkID0gWzAsIDEsICcxM18wXzAnXTtcbiAgICBtYWNvcyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQW5kcm9pZFxuICBpZiAoYW5kcm9pZCAmJiAhd2luZG93cykge1xuICAgIGRldmljZS5vcyA9ICdhbmRyb2lkJztcbiAgICBkZXZpY2UuYW5kcm9pZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlwYWQgfHwgaXBob25lIHx8IGlwb2QpIHtcbiAgICBkZXZpY2Uub3MgPSAnaW9zJztcbiAgICBkZXZpY2UuaW9zID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBvYmplY3RcbiAgcmV0dXJuIGRldmljZTtcbn1cbmZ1bmN0aW9uIGdldERldmljZShvdmVycmlkZXMpIHtcbiAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnJpZGVzID0ge307XG4gIH1cbiAgaWYgKCFkZXZpY2VDYWNoZWQpIHtcbiAgICBkZXZpY2VDYWNoZWQgPSBjYWxjRGV2aWNlKG92ZXJyaWRlcyk7XG4gIH1cbiAgcmV0dXJuIGRldmljZUNhY2hlZDtcbn1cblxubGV0IGJyb3dzZXI7XG5mdW5jdGlvbiBjYWxjQnJvd3NlcigpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGxldCBuZWVkUGVyc3BlY3RpdmVGaXggPSBmYWxzZTtcbiAgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgY29uc3QgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdzYWZhcmknKSA+PSAwICYmIHVhLmluZGV4T2YoJ2Nocm9tZScpIDwgMCAmJiB1YS5pbmRleE9mKCdhbmRyb2lkJykgPCAwO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgY29uc3QgdWEgPSBTdHJpbmcod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmICh1YS5pbmNsdWRlcygnVmVyc2lvbi8nKSkge1xuICAgICAgY29uc3QgW21ham9yLCBtaW5vcl0gPSB1YS5zcGxpdCgnVmVyc2lvbi8nKVsxXS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJykubWFwKG51bSA9PiBOdW1iZXIobnVtKSk7XG4gICAgICBuZWVkUGVyc3BlY3RpdmVGaXggPSBtYWpvciA8IDE2IHx8IG1ham9yID09PSAxNiAmJiBtaW5vciA8IDI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaXNTYWZhcmk6IG5lZWRQZXJzcGVjdGl2ZUZpeCB8fCBpc1NhZmFyaSgpLFxuICAgIG5lZWRQZXJzcGVjdGl2ZUZpeCxcbiAgICBpc1dlYlZpZXc6IC8oaVBob25lfGlQb2R8aVBhZCkuKkFwcGxlV2ViS2l0KD8hLipTYWZhcmkpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJyb3dzZXIoKSB7XG4gIGlmICghYnJvd3Nlcikge1xuICAgIGJyb3dzZXIgPSBjYWxjQnJvd3NlcigpO1xuICB9XG4gIHJldHVybiBicm93c2VyO1xufVxuXG5mdW5jdGlvbiBSZXNpemUoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICBvbixcbiAgICBlbWl0XG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGFuaW1hdGlvbkZyYW1lID0gbnVsbDtcbiAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBlbWl0KCdiZWZvcmVSZXNpemUnKTtcbiAgICBlbWl0KCdyZXNpemUnKTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBhbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBzd2lwZXI7XG4gICAgICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb250ZW50Qm94U2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBzd2lwZXIuZWwpIHJldHVybjtcbiAgICAgICAgICBuZXdXaWR0aCA9IGNvbnRlbnRSZWN0ID8gY29udGVudFJlY3Qud2lkdGggOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmlubGluZVNpemU7XG4gICAgICAgICAgbmV3SGVpZ2h0ID0gY29udGVudFJlY3QgPyBjb250ZW50UmVjdC5oZWlnaHQgOiAoY29udGVudEJveFNpemVbMF0gfHwgY29udGVudEJveFNpemUpLmJsb2NrU2l6ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICByZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoc3dpcGVyLmVsKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cbiAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIudW5vYnNlcnZlICYmIHN3aXBlci5lbCkge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHN3aXBlci5lbCk7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9O1xuICBjb25zdCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgZW1pdCgnb3JpZW50YXRpb25jaGFuZ2UnKTtcbiAgfTtcbiAgb24oJ2luaXQnLCAoKSA9PiB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucmVzaXplT2JzZXJ2ZXIgJiYgdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNyZWF0ZU9ic2VydmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBvcmllbnRhdGlvbkNoYW5nZUhhbmRsZXIpO1xuICB9KTtcbiAgb24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIoKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgb3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzd2lwZXIsXG4gICAgZXh0ZW5kUGFyYW1zLFxuICAgIG9uLFxuICAgIGVtaXRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG9ic2VydmVycyA9IFtdO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3QgYXR0YWNoID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgT2JzZXJ2ZXJGdW5jID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYmtpdE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXJGdW5jKG11dGF0aW9ucyA9PiB7XG4gICAgICAvLyBUaGUgb2JzZXJ2ZXJVcGRhdGUgZXZlbnQgc2hvdWxkIG9ubHkgYmUgdHJpZ2dlcmVkXG4gICAgICAvLyBvbmNlIGRlc3BpdGUgdGhlIG51bWJlciBvZiBtdXRhdGlvbnMuICBBZGRpdGlvbmFsXG4gICAgICAvLyB0cmlnZ2VycyBhcmUgcmVkdW5kYW50IGFuZCBhcmUgdmVyeSBjb3N0bHlcbiAgICAgIGlmIChzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXykgcmV0dXJuO1xuICAgICAgaWYgKG11dGF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW1pdCgnb2JzZXJ2ZXJVcGRhdGUnLCBtdXRhdGlvbnNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvYnNlcnZlclVwZGF0ZSA9IGZ1bmN0aW9uIG9ic2VydmVyVXBkYXRlKCkge1xuICAgICAgICBlbWl0KCdvYnNlcnZlclVwZGF0ZScsIG11dGF0aW9uc1swXSk7XG4gICAgICB9O1xuICAgICAgaWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShvYnNlcnZlclVwZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChvYnNlcnZlclVwZGF0ZSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgIGNoaWxkTGlzdDogdHlwZW9mIG9wdGlvbnMuY2hpbGRMaXN0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBvcHRpb25zLmNoaWxkTGlzdCxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHR5cGVvZiBvcHRpb25zLmNoYXJhY3RlckRhdGEgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMuY2hhcmFjdGVyRGF0YVxuICAgIH0pO1xuICAgIG9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMub2JzZXJ2ZXIpIHJldHVybjtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5vYnNlcnZlUGFyZW50cykge1xuICAgICAgY29uc3QgY29udGFpbmVyUGFyZW50cyA9IGVsZW1lbnRQYXJlbnRzKHN3aXBlci5ob3N0RWwpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJQYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGF0dGFjaChjb250YWluZXJQYXJlbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT2JzZXJ2ZSBjb250YWluZXJcbiAgICBhdHRhY2goc3dpcGVyLmhvc3RFbCwge1xuICAgICAgY2hpbGRMaXN0OiBzd2lwZXIucGFyYW1zLm9ic2VydmVTbGlkZUNoaWxkcmVuXG4gICAgfSk7XG5cbiAgICAvLyBPYnNlcnZlIHdyYXBwZXJcbiAgICBhdHRhY2goc3dpcGVyLndyYXBwZXJFbCwge1xuICAgICAgYXR0cmlidXRlczogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJzLnNwbGljZSgwLCBvYnNlcnZlcnMubGVuZ3RoKTtcbiAgfTtcbiAgZXh0ZW5kUGFyYW1zKHtcbiAgICBvYnNlcnZlcjogZmFsc2UsXG4gICAgb2JzZXJ2ZVBhcmVudHM6IGZhbHNlLFxuICAgIG9ic2VydmVTbGlkZUNoaWxkcmVuOiBmYWxzZVxuICB9KTtcbiAgb24oJ2luaXQnLCBpbml0KTtcbiAgb24oJ2Rlc3Ryb3knLCBkZXN0cm95KTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cblxudmFyIGV2ZW50c0VtaXR0ZXIgPSB7XG4gIG9uKGV2ZW50cywgaGFuZGxlciwgcHJpb3JpdHkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IG1ldGhvZCA9IHByaW9yaXR5ID8gJ3Vuc2hpZnQnIDogJ3B1c2gnO1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0pIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9uY2UoZXZlbnRzLCBoYW5kbGVyLCBwcmlvcml0eSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHNlbGY7XG4gICAgZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICBzZWxmLm9mZihldmVudHMsIG9uY2VIYW5kbGVyKTtcbiAgICAgIGlmIChvbmNlSGFuZGxlci5fX2VtaXR0ZXJQcm94eSkge1xuICAgICAgICBkZWxldGUgb25jZUhhbmRsZXIuX19lbWl0dGVyUHJveHk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIG9uY2VIYW5kbGVyLl9fZW1pdHRlclByb3h5ID0gaGFuZGxlcjtcbiAgICByZXR1cm4gc2VsZi5vbihldmVudHMsIG9uY2VIYW5kbGVyLCBwcmlvcml0eSk7XG4gIH0sXG4gIG9uQW55KGhhbmRsZXIsIHByaW9yaXR5KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLmV2ZW50c0xpc3RlbmVycyB8fCBzZWxmLmRlc3Ryb3llZCkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gc2VsZjtcbiAgICBjb25zdCBtZXRob2QgPSBwcmlvcml0eSA/ICd1bnNoaWZ0JyA6ICdwdXNoJztcbiAgICBpZiAoc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKSA8IDApIHtcbiAgICAgIHNlbGYuZXZlbnRzQW55TGlzdGVuZXJzW21ldGhvZF0oaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICBvZmZBbnkoaGFuZGxlcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5ldmVudHNMaXN0ZW5lcnMgfHwgc2VsZi5kZXN0cm95ZWQpIHJldHVybiBzZWxmO1xuICAgIGlmICghc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMpIHJldHVybiBzZWxmO1xuICAgIGNvbnN0IGluZGV4ID0gc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuaW5kZXhPZihoYW5kbGVyKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIG9mZihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICBzZWxmLmV2ZW50c0xpc3RlbmVyc1tldmVudF0uZm9yRWFjaCgoZXZlbnRIYW5kbGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudEhhbmRsZXIgPT09IGhhbmRsZXIgfHwgZXZlbnRIYW5kbGVyLl9fZW1pdHRlclByb3h5ICYmIGV2ZW50SGFuZGxlci5fX2VtaXR0ZXJQcm94eSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgZW1pdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzIHx8IHNlbGYuZGVzdHJveWVkKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXNlbGYuZXZlbnRzTGlzdGVuZXJzKSByZXR1cm4gc2VsZjtcbiAgICBsZXQgZXZlbnRzO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGV2ZW50cyA9IGFyZ3NbMF07XG4gICAgICBkYXRhID0gYXJncy5zbGljZSgxLCBhcmdzLmxlbmd0aCk7XG4gICAgICBjb250ZXh0ID0gc2VsZjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gYXJnc1swXS5ldmVudHM7XG4gICAgICBkYXRhID0gYXJnc1swXS5kYXRhO1xuICAgICAgY29udGV4dCA9IGFyZ3NbMF0uY29udGV4dCB8fCBzZWxmO1xuICAgIH1cbiAgICBkYXRhLnVuc2hpZnQoY29udGV4dCk7XG4gICAgY29uc3QgZXZlbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoJyAnKTtcbiAgICBldmVudHNBcnJheS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmIChzZWxmLmV2ZW50c0FueUxpc3RlbmVycyAmJiBzZWxmLmV2ZW50c0FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZi5ldmVudHNBbnlMaXN0ZW5lcnMuZm9yRWFjaChldmVudEhhbmRsZXIgPT4ge1xuICAgICAgICAgIGV2ZW50SGFuZGxlci5hcHBseShjb250ZXh0LCBbZXZlbnQsIC4uLmRhdGFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5ldmVudHNMaXN0ZW5lcnMgJiYgc2VsZi5ldmVudHNMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICAgIHNlbGYuZXZlbnRzTGlzdGVuZXJzW2V2ZW50XS5mb3JFYWNoKGV2ZW50SGFuZGxlciA9PiB7XG4gICAgICAgICAgZXZlbnRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgaGVpZ2h0O1xuICBjb25zdCBlbCA9IHN3aXBlci5lbDtcbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBzd2lwZXIucGFyYW1zLndpZHRoICE9PSBudWxsKSB7XG4gICAgd2lkdGggPSBzd2lwZXIucGFyYW1zLndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzd2lwZXIucGFyYW1zLmhlaWdodCAhPT0gJ3VuZGVmaW5lZCcgJiYgc3dpcGVyLnBhcmFtcy5oZWlnaHQgIT09IG51bGwpIHtcbiAgICBoZWlnaHQgPSBzd2lwZXIucGFyYW1zLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHQ7XG4gIH1cbiAgaWYgKHdpZHRoID09PSAwICYmIHN3aXBlci5pc0hvcml6b250YWwoKSB8fCBoZWlnaHQgPT09IDAgJiYgc3dpcGVyLmlzVmVydGljYWwoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFN1YnRyYWN0IHBhZGRpbmdzXG4gIHdpZHRoID0gd2lkdGggLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLWxlZnQnKSB8fCAwLCAxMCkgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXJpZ2h0JykgfHwgMCwgMTApO1xuICBoZWlnaHQgPSBoZWlnaHQgLSBwYXJzZUludChlbGVtZW50U3R5bGUoZWwsICdwYWRkaW5nLXRvcCcpIHx8IDAsIDEwKSAtIHBhcnNlSW50KGVsZW1lbnRTdHlsZShlbCwgJ3BhZGRpbmctYm90dG9tJykgfHwgMCwgMTApO1xuICBpZiAoTnVtYmVyLmlzTmFOKHdpZHRoKSkgd2lkdGggPSAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKGhlaWdodCkpIGhlaWdodCA9IDA7XG4gIE9iamVjdC5hc3NpZ24oc3dpcGVyLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHNpemU6IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHdpZHRoIDogaGVpZ2h0XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGZ1bmN0aW9uIGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUobm9kZSwgbGFiZWwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChub2RlLmdldFByb3BlcnR5VmFsdWUoc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKGxhYmVsKSkgfHwgMCk7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gc3dpcGVyLnBhcmFtcztcbiAgY29uc3Qge1xuICAgIHdyYXBwZXJFbCxcbiAgICBzbGlkZXNFbCxcbiAgICBzaXplOiBzd2lwZXJTaXplLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHdyb25nUlRMXG4gIH0gPSBzd2lwZXI7XG4gIGNvbnN0IGlzVmlydHVhbCA9IHN3aXBlci52aXJ0dWFsICYmIHBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICBjb25zdCBzbGlkZXMgPSBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtzd2lwZXIucGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgY29uc3Qgc2xpZGVzTGVuZ3RoID0gaXNWaXJ0dWFsID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCA6IHNsaWRlcy5sZW5ndGg7XG4gIGxldCBzbmFwR3JpZCA9IFtdO1xuICBjb25zdCBzbGlkZXNHcmlkID0gW107XG4gIGNvbnN0IHNsaWRlc1NpemVzR3JpZCA9IFtdO1xuICBsZXQgb2Zmc2V0QmVmb3JlID0gcGFyYW1zLnNsaWRlc09mZnNldEJlZm9yZTtcbiAgaWYgKHR5cGVvZiBvZmZzZXRCZWZvcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRCZWZvcmUgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QmVmb3JlLmNhbGwoc3dpcGVyKTtcbiAgfVxuICBsZXQgb2Zmc2V0QWZ0ZXIgPSBwYXJhbXMuc2xpZGVzT2Zmc2V0QWZ0ZXI7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0QWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvZmZzZXRBZnRlciA9IHBhcmFtcy5zbGlkZXNPZmZzZXRBZnRlci5jYWxsKHN3aXBlcik7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTbmFwR3JpZExlbmd0aCA9IHN3aXBlci5zbmFwR3JpZC5sZW5ndGg7XG4gIGNvbnN0IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCA9IHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aDtcbiAgbGV0IHNwYWNlQmV0d2VlbiA9IHBhcmFtcy5zcGFjZUJldHdlZW47XG4gIGxldCBzbGlkZVBvc2l0aW9uID0gLW9mZnNldEJlZm9yZTtcbiAgbGV0IHByZXZTbGlkZVNpemUgPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAodHlwZW9mIHN3aXBlclNpemUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2Ygc3BhY2VCZXR3ZWVuID09PSAnc3RyaW5nJyAmJiBzcGFjZUJldHdlZW4uaW5kZXhPZignJScpID49IDApIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbi5yZXBsYWNlKCclJywgJycpKSAvIDEwMCAqIHN3aXBlclNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgc3dpcGVyLnZpcnR1YWxTaXplID0gLXNwYWNlQmV0d2VlbjtcblxuICAvLyByZXNldCBtYXJnaW5zXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIGlmIChydGwpIHtcbiAgICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luTGVmdCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZUVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJyc7XG4gICAgfVxuICAgIHNsaWRlRWwuc3R5bGUubWFyZ2luQm90dG9tID0gJyc7XG4gICAgc2xpZGVFbC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgfSk7XG5cbiAgLy8gcmVzZXQgY3NzTW9kZSBvZmZzZXRzXG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICBzZXRDU1NQcm9wZXJ0eSh3cmFwcGVyRWwsICctLXN3aXBlci1jZW50ZXJlZC1vZmZzZXQtYmVmb3JlJywgJycpO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsICcnKTtcbiAgfVxuICBjb25zdCBncmlkRW5hYmxlZCA9IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxICYmIHN3aXBlci5ncmlkO1xuICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICBzd2lwZXIuZ3JpZC5pbml0U2xpZGVzKHNsaWRlcyk7XG4gIH0gZWxzZSBpZiAoc3dpcGVyLmdyaWQpIHtcbiAgICBzd2lwZXIuZ3JpZC51bnNldFNsaWRlcygpO1xuICB9XG5cbiAgLy8gQ2FsYyBzbGlkZXNcbiAgbGV0IHNsaWRlU2l6ZTtcbiAgY29uc3Qgc2hvdWxkUmVzZXRTbGlkZVNpemUgPSBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5icmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhwYXJhbXMuYnJlYWtwb2ludHMpLmZpbHRlcihrZXkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW1zLmJyZWFrcG9pbnRzW2tleV0uc2xpZGVzUGVyVmlldyAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0pLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzbGlkZVNpemUgPSAwO1xuICAgIGxldCBzbGlkZTtcbiAgICBpZiAoc2xpZGVzW2ldKSBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5ncmlkLnVwZGF0ZVNsaWRlKGksIHNsaWRlLCBzbGlkZXMpO1xuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldICYmIGVsZW1lbnRTdHlsZShzbGlkZSwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgIGlmIChzaG91bGRSZXNldFNsaWRlU2l6ZSkge1xuICAgICAgICBzbGlkZXNbaV0uc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGBgO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNsaWRlKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBzbGlkZS5zdHlsZS50cmFuc2Zvcm07XG4gICAgICBjb25zdCBjdXJyZW50V2ViS2l0VHJhbnNmb3JtID0gc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHtcbiAgICAgICAgc2xpZGVTaXplID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gZWxlbWVudE91dGVyU2l6ZShzbGlkZSwgJ3dpZHRoJywgdHJ1ZSkgOiBlbGVtZW50T3V0ZXJTaXplKHNsaWRlLCAnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnd2lkdGgnKTtcbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAncGFkZGluZy1sZWZ0Jyk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IGdldERpcmVjdGlvblByb3BlcnR5VmFsdWUoc2xpZGVTdHlsZXMsICdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLWxlZnQnKTtcbiAgICAgICAgY29uc3QgbWFyZ2luUmlnaHQgPSBnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlKHNsaWRlU3R5bGVzLCAnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgIGNvbnN0IGJveFNpemluZyA9IHNsaWRlU3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2JveC1zaXppbmcnKTtcbiAgICAgICAgaWYgKGJveFNpemluZyAmJiBib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xuICAgICAgICAgIHNsaWRlU2l6ZSA9IHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoLFxuICAgICAgICAgICAgb2Zmc2V0V2lkdGhcbiAgICAgICAgICB9ID0gc2xpZGU7XG4gICAgICAgICAgc2xpZGVTaXplID0gd2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIG1hcmdpbkxlZnQgKyBtYXJnaW5SaWdodCArIChvZmZzZXRXaWR0aCAtIGNsaWVudFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50V2ViS2l0VHJhbnNmb3JtKSB7XG4gICAgICAgIHNsaWRlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGN1cnJlbnRXZWJLaXRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVTaXplID0gTWF0aC5mbG9vcihzbGlkZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbGlkZVNpemUgPSAoc3dpcGVyU2l6ZSAtIChwYXJhbXMuc2xpZGVzUGVyVmlldyAtIDEpICogc3BhY2VCZXR3ZWVuKSAvIHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlU2l6ZSA9IE1hdGguZmxvb3Ioc2xpZGVTaXplKTtcbiAgICAgIGlmIChzbGlkZXNbaV0pIHtcbiAgICAgICAgc2xpZGVzW2ldLnN0eWxlW3N3aXBlci5nZXREaXJlY3Rpb25MYWJlbCgnd2lkdGgnKV0gPSBgJHtzbGlkZVNpemV9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpZGVzW2ldKSB7XG4gICAgICBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplID0gc2xpZGVTaXplO1xuICAgIH1cbiAgICBzbGlkZXNTaXplc0dyaWQucHVzaChzbGlkZVNpemUpO1xuICAgIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgIHNsaWRlUG9zaXRpb24gPSBzbGlkZVBvc2l0aW9uICsgc2xpZGVTaXplIC8gMiArIHByZXZTbGlkZVNpemUgLyAyICsgc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKHByZXZTbGlkZVNpemUgPT09IDAgJiYgaSAhPT0gMCkgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gLSBzd2lwZXJTaXplIC8gMiAtIHNwYWNlQmV0d2VlbjtcbiAgICAgIGlmIChpID09PSAwKSBzbGlkZVBvc2l0aW9uID0gc2xpZGVQb3NpdGlvbiAtIHN3aXBlclNpemUgLyAyIC0gc3BhY2VCZXR3ZWVuO1xuICAgICAgaWYgKE1hdGguYWJzKHNsaWRlUG9zaXRpb24pIDwgMSAvIDEwMDApIHNsaWRlUG9zaXRpb24gPSAwO1xuICAgICAgaWYgKHBhcmFtcy5yb3VuZExlbmd0aHMpIHNsaWRlUG9zaXRpb24gPSBNYXRoLmZsb29yKHNsaWRlUG9zaXRpb24pO1xuICAgICAgaWYgKGluZGV4ICUgcGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykgc2xpZGVQb3NpdGlvbiA9IE1hdGguZmxvb3Ioc2xpZGVQb3NpdGlvbik7XG4gICAgICBpZiAoKGluZGV4IC0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIGluZGV4KSkgJSBzd2lwZXIucGFyYW1zLnNsaWRlc1Blckdyb3VwID09PSAwKSBzbmFwR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVzR3JpZC5wdXNoKHNsaWRlUG9zaXRpb24pO1xuICAgICAgc2xpZGVQb3NpdGlvbiA9IHNsaWRlUG9zaXRpb24gKyBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgfVxuICAgIHN3aXBlci52aXJ0dWFsU2l6ZSArPSBzbGlkZVNpemUgKyBzcGFjZUJldHdlZW47XG4gICAgcHJldlNsaWRlU2l6ZSA9IHNsaWRlU2l6ZTtcbiAgICBpbmRleCArPSAxO1xuICB9XG4gIHN3aXBlci52aXJ0dWFsU2l6ZSA9IE1hdGgubWF4KHN3aXBlci52aXJ0dWFsU2l6ZSwgc3dpcGVyU2l6ZSkgKyBvZmZzZXRBZnRlcjtcbiAgaWYgKHJ0bCAmJiB3cm9uZ1JUTCAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnY292ZXJmbG93JykpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGUud2lkdGggPSBgJHtzd2lwZXIudmlydHVhbFNpemUgKyBzcGFjZUJldHdlZW59cHhgO1xuICB9XG4gIGlmIChwYXJhbXMuc2V0V3JhcHBlclNpemUpIHtcbiAgICB3cmFwcGVyRWwuc3R5bGVbc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCd3aWR0aCcpXSA9IGAke3N3aXBlci52aXJ0dWFsU2l6ZSArIHNwYWNlQmV0d2Vlbn1weGA7XG4gIH1cbiAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgc3dpcGVyLmdyaWQudXBkYXRlV3JhcHBlclNpemUoc2xpZGVTaXplLCBzbmFwR3JpZCk7XG4gIH1cblxuICAvLyBSZW1vdmUgbGFzdCBncmlkIGVsZW1lbnRzIGRlcGVuZGluZyBvbiB3aWR0aFxuICBpZiAoIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgIGNvbnN0IG5ld1NsaWRlc0dyaWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuYXBHcmlkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgc2xpZGVzR3JpZEl0ZW0gPSBzbmFwR3JpZFtpXTtcbiAgICAgIGlmIChwYXJhbXMucm91bmRMZW5ndGhzKSBzbGlkZXNHcmlkSXRlbSA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZEl0ZW0pO1xuICAgICAgaWYgKHNuYXBHcmlkW2ldIDw9IHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIHtcbiAgICAgICAgbmV3U2xpZGVzR3JpZC5wdXNoKHNsaWRlc0dyaWRJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc25hcEdyaWQgPSBuZXdTbGlkZXNHcmlkO1xuICAgIGlmIChNYXRoLmZsb29yKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpIC0gTWF0aC5mbG9vcihzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSkgPiAxKSB7XG4gICAgICBzbmFwR3JpZC5wdXNoKHN3aXBlci52aXJ0dWFsU2l6ZSAtIHN3aXBlclNpemUpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHNsaWRlc1NpemVzR3JpZFswXSArIHNwYWNlQmV0d2VlbjtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgY29uc3QgZ3JvdXBzID0gTWF0aC5jZWlsKChzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNBZnRlcikgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICAgICAgY29uc3QgZ3JvdXBTaXplID0gc2l6ZSAqIHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpICs9IDEpIHtcbiAgICAgICAgc25hcEdyaWQucHVzaChzbmFwR3JpZFtzbmFwR3JpZC5sZW5ndGggLSAxXSArIGdyb3VwU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQmVmb3JlICsgc3dpcGVyLnZpcnR1YWwuc2xpZGVzQWZ0ZXI7IGkgKz0gMSkge1xuICAgICAgaWYgKHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgICBzbmFwR3JpZC5wdXNoKHNuYXBHcmlkW3NuYXBHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICB9XG4gICAgICBzbGlkZXNHcmlkLnB1c2goc2xpZGVzR3JpZFtzbGlkZXNHcmlkLmxlbmd0aCAtIDFdICsgc2l6ZSk7XG4gICAgICBzd2lwZXIudmlydHVhbFNpemUgKz0gc2l6ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmxlbmd0aCA9PT0gMCkgc25hcEdyaWQgPSBbMF07XG4gIGlmIChzcGFjZUJldHdlZW4gIT09IDApIHtcbiAgICBjb25zdCBrZXkgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgJiYgcnRsID8gJ21hcmdpbkxlZnQnIDogc3dpcGVyLmdldERpcmVjdGlvbkxhYmVsKCdtYXJnaW5SaWdodCcpO1xuICAgIHNsaWRlcy5maWx0ZXIoKF8sIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgIGlmICghcGFyYW1zLmNzc01vZGUgfHwgcGFyYW1zLmxvb3ApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHNsaWRlSW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICBzbGlkZUVsLnN0eWxlW2tleV0gPSBgJHtzcGFjZUJldHdlZW59cHhgO1xuICAgIH0pO1xuICB9XG4gIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgbGV0IGFsbFNsaWRlc1NpemUgPSAwO1xuICAgIHNsaWRlc1NpemVzR3JpZC5mb3JFYWNoKHNsaWRlU2l6ZVZhbHVlID0+IHtcbiAgICAgIGFsbFNsaWRlc1NpemUgKz0gc2xpZGVTaXplVmFsdWUgKyAoc3BhY2VCZXR3ZWVuIHx8IDApO1xuICAgIH0pO1xuICAgIGFsbFNsaWRlc1NpemUgLT0gc3BhY2VCZXR3ZWVuO1xuICAgIGNvbnN0IG1heFNuYXAgPSBhbGxTbGlkZXNTaXplIC0gc3dpcGVyU2l6ZTtcbiAgICBzbmFwR3JpZCA9IHNuYXBHcmlkLm1hcChzbmFwID0+IHtcbiAgICAgIGlmIChzbmFwIDw9IDApIHJldHVybiAtb2Zmc2V0QmVmb3JlO1xuICAgICAgaWYgKHNuYXAgPiBtYXhTbmFwKSByZXR1cm4gbWF4U25hcCArIG9mZnNldEFmdGVyO1xuICAgICAgcmV0dXJuIHNuYXA7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMpIHtcbiAgICBsZXQgYWxsU2xpZGVzU2l6ZSA9IDA7XG4gICAgc2xpZGVzU2l6ZXNHcmlkLmZvckVhY2goc2xpZGVTaXplVmFsdWUgPT4ge1xuICAgICAgYWxsU2xpZGVzU2l6ZSArPSBzbGlkZVNpemVWYWx1ZSArIChzcGFjZUJldHdlZW4gfHwgMCk7XG4gICAgfSk7XG4gICAgYWxsU2xpZGVzU2l6ZSAtPSBzcGFjZUJldHdlZW47XG4gICAgaWYgKGFsbFNsaWRlc1NpemUgPCBzd2lwZXJTaXplKSB7XG4gICAgICBjb25zdCBhbGxTbGlkZXNPZmZzZXQgPSAoc3dpcGVyU2l6ZSAtIGFsbFNsaWRlc1NpemUpIC8gMjtcbiAgICAgIHNuYXBHcmlkLmZvckVhY2goKHNuYXAsIHNuYXBJbmRleCkgPT4ge1xuICAgICAgICBzbmFwR3JpZFtzbmFwSW5kZXhdID0gc25hcCAtIGFsbFNsaWRlc09mZnNldDtcbiAgICAgIH0pO1xuICAgICAgc2xpZGVzR3JpZC5mb3JFYWNoKChzbmFwLCBzbmFwSW5kZXgpID0+IHtcbiAgICAgICAgc2xpZGVzR3JpZFtzbmFwSW5kZXhdID0gc25hcCArIGFsbFNsaWRlc09mZnNldDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBPYmplY3QuYXNzaWduKHN3aXBlciwge1xuICAgIHNsaWRlcyxcbiAgICBzbmFwR3JpZCxcbiAgICBzbGlkZXNHcmlkLFxuICAgIHNsaWRlc1NpemVzR3JpZFxuICB9KTtcbiAgaWYgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyAmJiBwYXJhbXMuY3NzTW9kZSAmJiAhcGFyYW1zLmNlbnRlcmVkU2xpZGVzQm91bmRzKSB7XG4gICAgc2V0Q1NTUHJvcGVydHkod3JhcHBlckVsLCAnLS1zd2lwZXItY2VudGVyZWQtb2Zmc2V0LWJlZm9yZScsIGAkey1zbmFwR3JpZFswXX1weGApO1xuICAgIHNldENTU1Byb3BlcnR5KHdyYXBwZXJFbCwgJy0tc3dpcGVyLWNlbnRlcmVkLW9mZnNldC1hZnRlcicsIGAke3N3aXBlci5zaXplIC8gMiAtIHNsaWRlc1NpemVzR3JpZFtzbGlkZXNTaXplc0dyaWQubGVuZ3RoIC0gMV0gLyAyfXB4YCk7XG4gICAgY29uc3QgYWRkVG9TbmFwR3JpZCA9IC1zd2lwZXIuc25hcEdyaWRbMF07XG4gICAgY29uc3QgYWRkVG9TbGlkZXNHcmlkID0gLXN3aXBlci5zbGlkZXNHcmlkWzBdO1xuICAgIHN3aXBlci5zbmFwR3JpZCA9IHN3aXBlci5zbmFwR3JpZC5tYXAodiA9PiB2ICsgYWRkVG9TbmFwR3JpZCk7XG4gICAgc3dpcGVyLnNsaWRlc0dyaWQgPSBzd2lwZXIuc2xpZGVzR3JpZC5tYXAodiA9PiB2ICsgYWRkVG9TbGlkZXNHcmlkKTtcbiAgfVxuICBpZiAoc2xpZGVzTGVuZ3RoICE9PSBwcmV2aW91c1NsaWRlc0xlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc25hcEdyaWQubGVuZ3RoICE9PSBwcmV2aW91c1NuYXBHcmlkTGVuZ3RoKSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdykgc3dpcGVyLmNoZWNrT3ZlcmZsb3coKTtcbiAgICBzd2lwZXIuZW1pdCgnc25hcEdyaWRMZW5ndGhDaGFuZ2UnKTtcbiAgfVxuICBpZiAoc2xpZGVzR3JpZC5sZW5ndGggIT09IHByZXZpb3VzU2xpZGVzR3JpZExlbmd0aCkge1xuICAgIHN3aXBlci5lbWl0KCdzbGlkZXNHcmlkTGVuZ3RoQ2hhbmdlJyk7XG4gIH1cbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzbGlkZXNVcGRhdGVkJyk7XG4gIGlmICghaXNWaXJ0dWFsICYmICFwYXJhbXMuY3NzTW9kZSAmJiAocGFyYW1zLmVmZmVjdCA9PT0gJ3NsaWRlJyB8fCBwYXJhbXMuZWZmZWN0ID09PSAnZmFkZScpKSB7XG4gICAgY29uc3QgYmFja0ZhY2VIaWRkZW5DbGFzcyA9IGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWJhY2tmYWNlLWhpZGRlbmA7XG4gICAgY29uc3QgaGFzQ2xhc3NCYWNrZmFjZUNsYXNzQWRkZWQgPSBzd2lwZXIuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGJhY2tGYWNlSGlkZGVuQ2xhc3MpO1xuICAgIGlmIChzbGlkZXNMZW5ndGggPD0gcGFyYW1zLm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NsYXNzQmFja2ZhY2VDbGFzc0FkZGVkKSB7XG4gICAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LnJlbW92ZShiYWNrRmFjZUhpZGRlbkNsYXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQXV0b0hlaWdodChzcGVlZCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBhY3RpdmVTbGlkZXMgPSBbXTtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQ7XG4gIGxldCBuZXdIZWlnaHQgPSAwO1xuICBsZXQgaTtcbiAgaWYgKHR5cGVvZiBzcGVlZCA9PT0gJ251bWJlcicpIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gIH0gZWxzZSBpZiAoc3BlZWQgPT09IHRydWUpIHtcbiAgICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzd2lwZXIucGFyYW1zLnNwZWVkKTtcbiAgfVxuICBjb25zdCBnZXRTbGlkZUJ5SW5kZXggPSBpbmRleCA9PiB7XG4gICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgcmV0dXJuIHN3aXBlci5zbGlkZXNbc3dpcGVyLmdldFNsaWRlSW5kZXhCeURhdGEoaW5kZXgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN3aXBlci5zbGlkZXNbaW5kZXhdO1xuICB9O1xuICAvLyBGaW5kIHNsaWRlcyBjdXJyZW50bHkgaW4gdmlld1xuICBpZiAoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSAnYXV0bycgJiYgc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID4gMSkge1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICAoc3dpcGVyLnZpc2libGVTbGlkZXMgfHwgW10pLmZvckVhY2goc2xpZGUgPT4ge1xuICAgICAgICBhY3RpdmVTbGlkZXMucHVzaChzbGlkZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IE1hdGguY2VpbChzd2lwZXIucGFyYW1zLnNsaWRlc1BlclZpZXcpOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXggKyBpO1xuICAgICAgICBpZiAoaW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAmJiAhaXNWaXJ0dWFsKSBicmVhaztcbiAgICAgICAgYWN0aXZlU2xpZGVzLnB1c2goZ2V0U2xpZGVCeUluZGV4KGluZGV4KSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFjdGl2ZVNsaWRlcy5wdXNoKGdldFNsaWRlQnlJbmRleChzd2lwZXIuYWN0aXZlSW5kZXgpKTtcbiAgfVxuXG4gIC8vIEZpbmQgbmV3IGhlaWdodCBmcm9tIGhpZ2hlc3Qgc2xpZGUgaW4gdmlld1xuICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlU2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmVTbGlkZXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBhY3RpdmVTbGlkZXNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgbmV3SGVpZ2h0ID0gaGVpZ2h0ID4gbmV3SGVpZ2h0ID8gaGVpZ2h0IDogbmV3SGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBIZWlnaHRcbiAgaWYgKG5ld0hlaWdodCB8fCBuZXdIZWlnaHQgPT09IDApIHN3aXBlci53cmFwcGVyRWwuc3R5bGUuaGVpZ2h0ID0gYCR7bmV3SGVpZ2h0fXB4YDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzT2Zmc2V0KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBzbGlkZXMgPSBzd2lwZXIuc2xpZGVzO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3QgbWludXNPZmZzZXQgPSBzd2lwZXIuaXNFbGVtZW50ID8gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gc3dpcGVyLndyYXBwZXJFbC5vZmZzZXRMZWZ0IDogc3dpcGVyLndyYXBwZXJFbC5vZmZzZXRUb3AgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHNsaWRlc1tpXS5zd2lwZXJTbGlkZU9mZnNldCA9IChzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBzbGlkZXNbaV0ub2Zmc2V0TGVmdCA6IHNsaWRlc1tpXS5vZmZzZXRUb3ApIC0gbWludXNPZmZzZXQgLSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU2xpZGVzUHJvZ3Jlc3ModHJhbnNsYXRlKSB7XG4gIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZSA9IHRoaXMgJiYgdGhpcy50cmFuc2xhdGUgfHwgMDtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHNuYXBHcmlkXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChzbGlkZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIGlmICh0eXBlb2Ygc2xpZGVzWzBdLnN3aXBlclNsaWRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICBsZXQgb2Zmc2V0Q2VudGVyID0gLXRyYW5zbGF0ZTtcbiAgaWYgKHJ0bCkgb2Zmc2V0Q2VudGVyID0gdHJhbnNsYXRlO1xuXG4gIC8vIFZpc2libGUgU2xpZGVzXG4gIHNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIHNsaWRlRWwuY2xhc3NMaXN0LnJlbW92ZShwYXJhbXMuc2xpZGVWaXNpYmxlQ2xhc3MsIHBhcmFtcy5zbGlkZUZ1bGx5VmlzaWJsZUNsYXNzKTtcbiAgfSk7XG4gIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcyA9IFtdO1xuICBzd2lwZXIudmlzaWJsZVNsaWRlcyA9IFtdO1xuICBsZXQgc3BhY2VCZXR3ZWVuID0gcGFyYW1zLnNwYWNlQmV0d2VlbjtcbiAgaWYgKHR5cGVvZiBzcGFjZUJldHdlZW4gPT09ICdzdHJpbmcnICYmIHNwYWNlQmV0d2Vlbi5pbmRleE9mKCclJykgPj0gMCkge1xuICAgIHNwYWNlQmV0d2VlbiA9IHBhcnNlRmxvYXQoc3BhY2VCZXR3ZWVuLnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwICogc3dpcGVyLnNpemU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlQmV0d2VlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBzcGFjZUJldHdlZW4gPSBwYXJzZUZsb2F0KHNwYWNlQmV0d2Vlbik7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBzbGlkZSA9IHNsaWRlc1tpXTtcbiAgICBsZXQgc2xpZGVPZmZzZXQgPSBzbGlkZS5zd2lwZXJTbGlkZU9mZnNldDtcbiAgICBpZiAocGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBzbGlkZU9mZnNldCAtPSBzbGlkZXNbMF0uc3dpcGVyU2xpZGVPZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IHNsaWRlUHJvZ3Jlc3MgPSAob2Zmc2V0Q2VudGVyICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHNwYWNlQmV0d2Vlbik7XG4gICAgY29uc3Qgb3JpZ2luYWxTbGlkZVByb2dyZXNzID0gKG9mZnNldENlbnRlciAtIHNuYXBHcmlkWzBdICsgKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSA6IDApIC0gc2xpZGVPZmZzZXQpIC8gKHNsaWRlLnN3aXBlclNsaWRlU2l6ZSArIHNwYWNlQmV0d2Vlbik7XG4gICAgY29uc3Qgc2xpZGVCZWZvcmUgPSAtKG9mZnNldENlbnRlciAtIHNsaWRlT2Zmc2V0KTtcbiAgICBjb25zdCBzbGlkZUFmdGVyID0gc2xpZGVCZWZvcmUgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2ldO1xuICAgIGNvbnN0IGlzRnVsbHlWaXNpYmxlID0gc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8PSBzd2lwZXIuc2l6ZSAtIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbaV07XG4gICAgY29uc3QgaXNWaXNpYmxlID0gc2xpZGVCZWZvcmUgPj0gMCAmJiBzbGlkZUJlZm9yZSA8IHN3aXBlci5zaXplIC0gMSB8fCBzbGlkZUFmdGVyID4gMSAmJiBzbGlkZUFmdGVyIDw9IHN3aXBlci5zaXplIHx8IHNsaWRlQmVmb3JlIDw9IDAgJiYgc2xpZGVBZnRlciA+PSBzd2lwZXIuc2l6ZTtcbiAgICBpZiAoaXNWaXNpYmxlKSB7XG4gICAgICBzd2lwZXIudmlzaWJsZVNsaWRlcy5wdXNoKHNsaWRlKTtcbiAgICAgIHN3aXBlci52aXNpYmxlU2xpZGVzSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgc2xpZGVzW2ldLmNsYXNzTGlzdC5hZGQocGFyYW1zLnNsaWRlVmlzaWJsZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGlzRnVsbHlWaXNpYmxlKSB7XG4gICAgICBzbGlkZXNbaV0uY2xhc3NMaXN0LmFkZChwYXJhbXMuc2xpZGVGdWxseVZpc2libGVDbGFzcyk7XG4gICAgfVxuICAgIHNsaWRlLnByb2dyZXNzID0gcnRsID8gLXNsaWRlUHJvZ3Jlc3MgOiBzbGlkZVByb2dyZXNzO1xuICAgIHNsaWRlLm9yaWdpbmFsUHJvZ3Jlc3MgPSBydGwgPyAtb3JpZ2luYWxTbGlkZVByb2dyZXNzIDogb3JpZ2luYWxTbGlkZVByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2dyZXNzKHRyYW5zbGF0ZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAodHlwZW9mIHRyYW5zbGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBtdWx0aXBsaWVyID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IC0xIDogMTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB0cmFuc2xhdGUgPSBzd2lwZXIgJiYgc3dpcGVyLnRyYW5zbGF0ZSAmJiBzd2lwZXIudHJhbnNsYXRlICogbXVsdGlwbGllciB8fCAwO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IHN3aXBlci5wYXJhbXM7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBsZXQge1xuICAgIHByb2dyZXNzLFxuICAgIGlzQmVnaW5uaW5nLFxuICAgIGlzRW5kLFxuICAgIHByb2dyZXNzTG9vcFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCB3YXNCZWdpbm5pbmcgPSBpc0JlZ2lubmluZztcbiAgY29uc3Qgd2FzRW5kID0gaXNFbmQ7XG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgIHByb2dyZXNzID0gMDtcbiAgICBpc0JlZ2lubmluZyA9IHRydWU7XG4gICAgaXNFbmQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHByb2dyZXNzID0gKHRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcbiAgICBjb25zdCBpc0JlZ2lubmluZ1JvdW5kZWQgPSBNYXRoLmFicyh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIDwgMTtcbiAgICBjb25zdCBpc0VuZFJvdW5kZWQgPSBNYXRoLmFicyh0cmFuc2xhdGUgLSBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIDwgMTtcbiAgICBpc0JlZ2lubmluZyA9IGlzQmVnaW5uaW5nUm91bmRlZCB8fCBwcm9ncmVzcyA8PSAwO1xuICAgIGlzRW5kID0gaXNFbmRSb3VuZGVkIHx8IHByb2dyZXNzID49IDE7XG4gICAgaWYgKGlzQmVnaW5uaW5nUm91bmRlZCkgcHJvZ3Jlc3MgPSAwO1xuICAgIGlmIChpc0VuZFJvdW5kZWQpIHByb2dyZXNzID0gMTtcbiAgfVxuICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICBjb25zdCBmaXJzdFNsaWRlSW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleEJ5RGF0YSgwKTtcbiAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgZmlyc3RTbGlkZVRyYW5zbGF0ZSA9IHN3aXBlci5zbGlkZXNHcmlkW2ZpcnN0U2xpZGVJbmRleF07XG4gICAgY29uc3QgbGFzdFNsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbbGFzdFNsaWRlSW5kZXhdO1xuICAgIGNvbnN0IHRyYW5zbGF0ZU1heCA9IHN3aXBlci5zbGlkZXNHcmlkW3N3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHRyYW5zbGF0ZUFicyA9IE1hdGguYWJzKHRyYW5zbGF0ZSk7XG4gICAgaWYgKHRyYW5zbGF0ZUFicyA+PSBmaXJzdFNsaWRlVHJhbnNsYXRlKSB7XG4gICAgICBwcm9ncmVzc0xvb3AgPSAodHJhbnNsYXRlQWJzIC0gZmlyc3RTbGlkZVRyYW5zbGF0ZSkgLyB0cmFuc2xhdGVNYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dyZXNzTG9vcCA9ICh0cmFuc2xhdGVBYnMgKyB0cmFuc2xhdGVNYXggLSBsYXN0U2xpZGVUcmFuc2xhdGUpIC8gdHJhbnNsYXRlTWF4O1xuICAgIH1cbiAgICBpZiAocHJvZ3Jlc3NMb29wID4gMSkgcHJvZ3Jlc3NMb29wIC09IDE7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBwcm9ncmVzcyxcbiAgICBwcm9ncmVzc0xvb3AsXG4gICAgaXNCZWdpbm5pbmcsXG4gICAgaXNFbmRcbiAgfSk7XG4gIGlmIChwYXJhbXMud2F0Y2hTbGlkZXNQcm9ncmVzcyB8fCBwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgcGFyYW1zLmF1dG9IZWlnaHQpIHN3aXBlci51cGRhdGVTbGlkZXNQcm9ncmVzcyh0cmFuc2xhdGUpO1xuICBpZiAoaXNCZWdpbm5pbmcgJiYgIXdhc0JlZ2lubmluZykge1xuICAgIHN3aXBlci5lbWl0KCdyZWFjaEJlZ2lubmluZyB0b0VkZ2UnKTtcbiAgfVxuICBpZiAoaXNFbmQgJiYgIXdhc0VuZCkge1xuICAgIHN3aXBlci5lbWl0KCdyZWFjaEVuZCB0b0VkZ2UnKTtcbiAgfVxuICBpZiAod2FzQmVnaW5uaW5nICYmICFpc0JlZ2lubmluZyB8fCB3YXNFbmQgJiYgIWlzRW5kKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2Zyb21FZGdlJyk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3Byb2dyZXNzJywgcHJvZ3Jlc3MpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTbGlkZXNDbGFzc2VzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbCxcbiAgICBhY3RpdmVJbmRleFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkO1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBjb25zdCBnZXRGaWx0ZXJlZFNsaWRlID0gc2VsZWN0b3IgPT4ge1xuICAgIHJldHVybiBlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAuJHtwYXJhbXMuc2xpZGVDbGFzc30ke3NlbGVjdG9yfSwgc3dpcGVyLXNsaWRlJHtzZWxlY3Rvcn1gKVswXTtcbiAgfTtcbiAgc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzLCBwYXJhbXMuc2xpZGVOZXh0Q2xhc3MsIHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gIH0pO1xuICBsZXQgYWN0aXZlU2xpZGU7XG4gIGxldCBwcmV2U2xpZGU7XG4gIGxldCBuZXh0U2xpZGU7XG4gIGlmIChpc1ZpcnR1YWwpIHtcbiAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgIGxldCBzbGlkZUluZGV4ID0gYWN0aXZlSW5kZXggLSBzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmU7XG4gICAgICBpZiAoc2xpZGVJbmRleCA8IDApIHNsaWRlSW5kZXggPSBzd2lwZXIudmlydHVhbC5zbGlkZXMubGVuZ3RoICsgc2xpZGVJbmRleDtcbiAgICAgIGlmIChzbGlkZUluZGV4ID49IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGgpIHNsaWRlSW5kZXggLT0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aDtcbiAgICAgIGFjdGl2ZVNsaWRlID0gZ2V0RmlsdGVyZWRTbGlkZShgW2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtzbGlkZUluZGV4fVwiXWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVTbGlkZSA9IGdldEZpbHRlcmVkU2xpZGUoYFtkYXRhLXN3aXBlci1zbGlkZS1pbmRleD1cIiR7YWN0aXZlSW5kZXh9XCJdYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgYWN0aXZlU2xpZGUgPSBzbGlkZXMuZmlsdGVyKHNsaWRlRWwgPT4gc2xpZGVFbC5jb2x1bW4gPT09IGFjdGl2ZUluZGV4KVswXTtcbiAgICAgIG5leHRTbGlkZSA9IHNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLmNvbHVtbiA9PT0gYWN0aXZlSW5kZXggKyAxKVswXTtcbiAgICAgIHByZXZTbGlkZSA9IHNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLmNvbHVtbiA9PT0gYWN0aXZlSW5kZXggLSAxKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlU2xpZGUgPSBzbGlkZXNbYWN0aXZlSW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoYWN0aXZlU2xpZGUpIHtcbiAgICAvLyBBY3RpdmUgY2xhc3Nlc1xuICAgIGFjdGl2ZVNsaWRlLmNsYXNzTGlzdC5hZGQocGFyYW1zLnNsaWRlQWN0aXZlQ2xhc3MpO1xuICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgaWYgKG5leHRTbGlkZSkge1xuICAgICAgICBuZXh0U2xpZGUuY2xhc3NMaXN0LmFkZChwYXJhbXMuc2xpZGVOZXh0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZTbGlkZSkge1xuICAgICAgICBwcmV2U2xpZGUuY2xhc3NMaXN0LmFkZChwYXJhbXMuc2xpZGVQcmV2Q2xhc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZXh0IFNsaWRlXG4gICAgICBuZXh0U2xpZGUgPSBlbGVtZW50TmV4dEFsbChhY3RpdmVTbGlkZSwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYClbMF07XG4gICAgICBpZiAocGFyYW1zLmxvb3AgJiYgIW5leHRTbGlkZSkge1xuICAgICAgICBuZXh0U2xpZGUgPSBzbGlkZXNbMF07XG4gICAgICB9XG4gICAgICBpZiAobmV4dFNsaWRlKSB7XG4gICAgICAgIG5leHRTbGlkZS5jbGFzc0xpc3QuYWRkKHBhcmFtcy5zbGlkZU5leHRDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXYgU2xpZGVcbiAgICAgIHByZXZTbGlkZSA9IGVsZW1lbnRQcmV2QWxsKGFjdGl2ZVNsaWRlLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKVswXTtcbiAgICAgIGlmIChwYXJhbXMubG9vcCAmJiAhcHJldlNsaWRlID09PSAwKSB7XG4gICAgICAgIHByZXZTbGlkZSA9IHNsaWRlc1tzbGlkZXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAocHJldlNsaWRlKSB7XG4gICAgICAgIHByZXZTbGlkZS5jbGFzc0xpc3QuYWRkKHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN3aXBlci5lbWl0U2xpZGVzQ2xhc3NlcygpO1xufVxuXG5jb25zdCBwcm9jZXNzTGF6eVByZWxvYWRlciA9IChzd2lwZXIsIGltYWdlRWwpID0+IHtcbiAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLnBhcmFtcykgcmV0dXJuO1xuICBjb25zdCBzbGlkZVNlbGVjdG9yID0gKCkgPT4gc3dpcGVyLmlzRWxlbWVudCA/IGBzd2lwZXItc2xpZGVgIDogYC4ke3N3aXBlci5wYXJhbXMuc2xpZGVDbGFzc31gO1xuICBjb25zdCBzbGlkZUVsID0gaW1hZ2VFbC5jbG9zZXN0KHNsaWRlU2VsZWN0b3IoKSk7XG4gIGlmIChzbGlkZUVsKSB7XG4gICAgbGV0IGxhenlFbCA9IHNsaWRlRWwucXVlcnlTZWxlY3RvcihgLiR7c3dpcGVyLnBhcmFtcy5sYXp5UHJlbG9hZGVyQ2xhc3N9YCk7XG4gICAgaWYgKCFsYXp5RWwgJiYgc3dpcGVyLmlzRWxlbWVudCkge1xuICAgICAgaWYgKHNsaWRlRWwuc2hhZG93Um9vdCkge1xuICAgICAgICBsYXp5RWwgPSBzbGlkZUVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihgLiR7c3dpcGVyLnBhcmFtcy5sYXp5UHJlbG9hZGVyQ2xhc3N9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbml0IGxhdGVyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHNsaWRlRWwuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgbGF6eUVsID0gc2xpZGVFbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoYC4ke3N3aXBlci5wYXJhbXMubGF6eVByZWxvYWRlckNsYXNzfWApO1xuICAgICAgICAgICAgaWYgKGxhenlFbCkgbGF6eUVsLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXp5RWwpIGxhenlFbC5yZW1vdmUoKTtcbiAgfVxufTtcbmNvbnN0IHVubGF6eSA9IChzd2lwZXIsIGluZGV4KSA9PiB7XG4gIGlmICghc3dpcGVyLnNsaWRlc1tpbmRleF0pIHJldHVybjtcbiAgY29uc3QgaW1hZ2VFbCA9IHN3aXBlci5zbGlkZXNbaW5kZXhdLnF1ZXJ5U2VsZWN0b3IoJ1tsb2FkaW5nPVwibGF6eVwiXScpO1xuICBpZiAoaW1hZ2VFbCkgaW1hZ2VFbC5yZW1vdmVBdHRyaWJ1dGUoJ2xvYWRpbmcnKTtcbn07XG5jb25zdCBwcmVsb2FkID0gc3dpcGVyID0+IHtcbiAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCB8fCAhc3dpcGVyLnBhcmFtcykgcmV0dXJuO1xuICBsZXQgYW1vdW50ID0gc3dpcGVyLnBhcmFtcy5sYXp5UHJlbG9hZFByZXZOZXh0O1xuICBjb25zdCBsZW4gPSBzd2lwZXIuc2xpZGVzLmxlbmd0aDtcbiAgaWYgKCFsZW4gfHwgIWFtb3VudCB8fCBhbW91bnQgPCAwKSByZXR1cm47XG4gIGFtb3VudCA9IE1hdGgubWluKGFtb3VudCwgbGVuKTtcbiAgY29uc3Qgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nID8gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCkgOiBNYXRoLmNlaWwoc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJWaWV3KTtcbiAgY29uc3QgYWN0aXZlSW5kZXggPSBzd2lwZXIuYWN0aXZlSW5kZXg7XG4gIGlmIChzd2lwZXIucGFyYW1zLmdyaWQgJiYgc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3MgPiAxKSB7XG4gICAgY29uc3QgYWN0aXZlQ29sdW1uID0gYWN0aXZlSW5kZXg7XG4gICAgY29uc3QgcHJlbG9hZENvbHVtbnMgPSBbYWN0aXZlQ29sdW1uIC0gYW1vdW50XTtcbiAgICBwcmVsb2FkQ29sdW1ucy5wdXNoKC4uLkFycmF5LmZyb20oe1xuICAgICAgbGVuZ3RoOiBhbW91bnRcbiAgICB9KS5tYXAoKF8sIGkpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVDb2x1bW4gKyBzbGlkZXNQZXJWaWV3ICsgaTtcbiAgICB9KSk7XG4gICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKChzbGlkZUVsLCBpKSA9PiB7XG4gICAgICBpZiAocHJlbG9hZENvbHVtbnMuaW5jbHVkZXMoc2xpZGVFbC5jb2x1bW4pKSB1bmxhenkoc3dpcGVyLCBpKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgc2xpZGVJbmRleExhc3RJblZpZXcgPSBhY3RpdmVJbmRleCArIHNsaWRlc1BlclZpZXcgLSAxO1xuICBpZiAoc3dpcGVyLnBhcmFtcy5yZXdpbmQgfHwgc3dpcGVyLnBhcmFtcy5sb29wKSB7XG4gICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gYW1vdW50OyBpIDw9IHNsaWRlSW5kZXhMYXN0SW5WaWV3ICsgYW1vdW50OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHJlYWxJbmRleCA9IChpICUgbGVuICsgbGVuKSAlIGxlbjtcbiAgICAgIGlmIChyZWFsSW5kZXggPCBhY3RpdmVJbmRleCB8fCByZWFsSW5kZXggPiBzbGlkZUluZGV4TGFzdEluVmlldykgdW5sYXp5KHN3aXBlciwgcmVhbEluZGV4KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KGFjdGl2ZUluZGV4IC0gYW1vdW50LCAwKTsgaSA8PSBNYXRoLm1pbihzbGlkZUluZGV4TGFzdEluVmlldyArIGFtb3VudCwgbGVuIC0gMSk7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgIT09IGFjdGl2ZUluZGV4ICYmIChpID4gc2xpZGVJbmRleExhc3RJblZpZXcgfHwgaSA8IGFjdGl2ZUluZGV4KSkge1xuICAgICAgICB1bmxhenkoc3dpcGVyLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUluZGV4QnlUcmFuc2xhdGUoc3dpcGVyKSB7XG4gIGNvbnN0IHtcbiAgICBzbGlkZXNHcmlkLFxuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCB0cmFuc2xhdGUgPSBzd2lwZXIucnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICBsZXQgYWN0aXZlSW5kZXg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0gJiYgdHJhbnNsYXRlIDwgc2xpZGVzR3JpZFtpICsgMV0gLSAoc2xpZGVzR3JpZFtpICsgMV0gLSBzbGlkZXNHcmlkW2ldKSAvIDIpIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBpO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUgPj0gc2xpZGVzR3JpZFtpXSAmJiB0cmFuc2xhdGUgPCBzbGlkZXNHcmlkW2kgKyAxXSkge1xuICAgICAgICBhY3RpdmVJbmRleCA9IGkgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHJhbnNsYXRlID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgIGFjdGl2ZUluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgLy8gTm9ybWFsaXplIHNsaWRlSW5kZXhcbiAgaWYgKHBhcmFtcy5ub3JtYWxpemVTbGlkZUluZGV4KSB7XG4gICAgaWYgKGFjdGl2ZUluZGV4IDwgMCB8fCB0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSBhY3RpdmVJbmRleCA9IDA7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUluZGV4O1xufVxuZnVuY3Rpb24gdXBkYXRlQWN0aXZlSW5kZXgobmV3QWN0aXZlSW5kZXgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgdHJhbnNsYXRlID0gc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/IHN3aXBlci50cmFuc2xhdGUgOiAtc3dpcGVyLnRyYW5zbGF0ZTtcbiAgY29uc3Qge1xuICAgIHNuYXBHcmlkLFxuICAgIHBhcmFtcyxcbiAgICBhY3RpdmVJbmRleDogcHJldmlvdXNJbmRleCxcbiAgICByZWFsSW5kZXg6IHByZXZpb3VzUmVhbEluZGV4LFxuICAgIHNuYXBJbmRleDogcHJldmlvdXNTbmFwSW5kZXhcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGFjdGl2ZUluZGV4ID0gbmV3QWN0aXZlSW5kZXg7XG4gIGxldCBzbmFwSW5kZXg7XG4gIGNvbnN0IGdldFZpcnR1YWxSZWFsSW5kZXggPSBhSW5kZXggPT4ge1xuICAgIGxldCByZWFsSW5kZXggPSBhSW5kZXggLSBzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmU7XG4gICAgaWYgKHJlYWxJbmRleCA8IDApIHtcbiAgICAgIHJlYWxJbmRleCA9IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggKyByZWFsSW5kZXg7XG4gICAgfVxuICAgIGlmIChyZWFsSW5kZXggPj0gc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCkge1xuICAgICAgcmVhbEluZGV4IC09IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZWFsSW5kZXg7XG4gIH07XG4gIGlmICh0eXBlb2YgYWN0aXZlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWN0aXZlSW5kZXggPSBnZXRBY3RpdmVJbmRleEJ5VHJhbnNsYXRlKHN3aXBlcik7XG4gIH1cbiAgaWYgKHNuYXBHcmlkLmluZGV4T2YodHJhbnNsYXRlKSA+PSAwKSB7XG4gICAgc25hcEluZGV4ID0gc25hcEdyaWQuaW5kZXhPZih0cmFuc2xhdGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNraXAgPSBNYXRoLm1pbihwYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBhY3RpdmVJbmRleCk7XG4gICAgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKGFjdGl2ZUluZGV4IC0gc2tpcCkgLyBwYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICB9XG4gIGlmIChzbmFwSW5kZXggPj0gc25hcEdyaWQubGVuZ3RoKSBzbmFwSW5kZXggPSBzbmFwR3JpZC5sZW5ndGggLSAxO1xuICBpZiAoYWN0aXZlSW5kZXggPT09IHByZXZpb3VzSW5kZXggJiYgIXN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgIGlmIChzbmFwSW5kZXggIT09IHByZXZpb3VzU25hcEluZGV4KSB7XG4gICAgICBzd2lwZXIuc25hcEluZGV4ID0gc25hcEluZGV4O1xuICAgICAgc3dpcGVyLmVtaXQoJ3NuYXBJbmRleENoYW5nZScpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFjdGl2ZUluZGV4ID09PSBwcmV2aW91c0luZGV4ICYmIHN3aXBlci5wYXJhbXMubG9vcCAmJiBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgIHN3aXBlci5yZWFsSW5kZXggPSBnZXRWaXJ0dWFsUmVhbEluZGV4KGFjdGl2ZUluZGV4KTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcblxuICAvLyBHZXQgcmVhbCBpbmRleFxuICBsZXQgcmVhbEluZGV4O1xuICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBwYXJhbXMubG9vcCkge1xuICAgIHJlYWxJbmRleCA9IGdldFZpcnR1YWxSZWFsSW5kZXgoYWN0aXZlSW5kZXgpO1xuICB9IGVsc2UgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgY29uc3QgZmlyc3RTbGlkZUluQ29sdW1uID0gc3dpcGVyLnNsaWRlcy5maWx0ZXIoc2xpZGVFbCA9PiBzbGlkZUVsLmNvbHVtbiA9PT0gYWN0aXZlSW5kZXgpWzBdO1xuICAgIGxldCBhY3RpdmVTbGlkZUluZGV4ID0gcGFyc2VJbnQoZmlyc3RTbGlkZUluQ29sdW1uLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKSwgMTApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYWN0aXZlU2xpZGVJbmRleCkpIHtcbiAgICAgIGFjdGl2ZVNsaWRlSW5kZXggPSBNYXRoLm1heChzd2lwZXIuc2xpZGVzLmluZGV4T2YoZmlyc3RTbGlkZUluQ29sdW1uKSwgMCk7XG4gICAgfVxuICAgIHJlYWxJbmRleCA9IE1hdGguZmxvb3IoYWN0aXZlU2xpZGVJbmRleCAvIHBhcmFtcy5ncmlkLnJvd3MpO1xuICB9IGVsc2UgaWYgKHN3aXBlci5zbGlkZXNbYWN0aXZlSW5kZXhdKSB7XG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXNbYWN0aXZlSW5kZXhdLmdldEF0dHJpYnV0ZSgnZGF0YS1zd2lwZXItc2xpZGUtaW5kZXgnKTtcbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc2xpZGVJbmRleCwgMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFsSW5kZXggPSBhY3RpdmVJbmRleDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVhbEluZGV4ID0gYWN0aXZlSW5kZXg7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBwcmV2aW91c1NuYXBJbmRleCxcbiAgICBzbmFwSW5kZXgsXG4gICAgcHJldmlvdXNSZWFsSW5kZXgsXG4gICAgcmVhbEluZGV4LFxuICAgIHByZXZpb3VzSW5kZXgsXG4gICAgYWN0aXZlSW5kZXhcbiAgfSk7XG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICBwcmVsb2FkKHN3aXBlcik7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ2FjdGl2ZUluZGV4Q2hhbmdlJyk7XG4gIHN3aXBlci5lbWl0KCdzbmFwSW5kZXhDaGFuZ2UnKTtcbiAgaWYgKHN3aXBlci5pbml0aWFsaXplZCB8fCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCkge1xuICAgIGlmIChwcmV2aW91c1JlYWxJbmRleCAhPT0gcmVhbEluZGV4KSB7XG4gICAgICBzd2lwZXIuZW1pdCgncmVhbEluZGV4Q2hhbmdlJyk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZUNoYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsaWNrZWRTbGlkZShlbCwgcGF0aCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBwYXJhbXMgPSBzd2lwZXIucGFyYW1zO1xuICBsZXQgc2xpZGUgPSBlbC5jbG9zZXN0KGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApO1xuICBpZiAoIXNsaWRlICYmIHN3aXBlci5pc0VsZW1lbnQgJiYgcGF0aCAmJiBwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aC5pbmNsdWRlcyhlbCkpIHtcbiAgICBbLi4ucGF0aC5zbGljZShwYXRoLmluZGV4T2YoZWwpICsgMSwgcGF0aC5sZW5ndGgpXS5mb3JFYWNoKHBhdGhFbCA9PiB7XG4gICAgICBpZiAoIXNsaWRlICYmIHBhdGhFbC5tYXRjaGVzICYmIHBhdGhFbC5tYXRjaGVzKGAuJHtwYXJhbXMuc2xpZGVDbGFzc30sIHN3aXBlci1zbGlkZWApKSB7XG4gICAgICAgIHNsaWRlID0gcGF0aEVsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxldCBzbGlkZUZvdW5kID0gZmFsc2U7XG4gIGxldCBzbGlkZUluZGV4O1xuICBpZiAoc2xpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN3aXBlci5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChzd2lwZXIuc2xpZGVzW2ldID09PSBzbGlkZSkge1xuICAgICAgICBzbGlkZUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgc2xpZGVJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2xpZGUgJiYgc2xpZGVGb3VuZCkge1xuICAgIHN3aXBlci5jbGlja2VkU2xpZGUgPSBzbGlkZTtcbiAgICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIHN3aXBlci5jbGlja2VkSW5kZXggPSBwYXJzZUludChzbGlkZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHNsaWRlSW5kZXg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXBlci5jbGlja2VkU2xpZGUgPSB1bmRlZmluZWQ7XG4gICAgc3dpcGVyLmNsaWNrZWRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy5zbGlkZVRvQ2xpY2tlZFNsaWRlICYmIHN3aXBlci5jbGlja2VkSW5kZXggIT09IHVuZGVmaW5lZCAmJiBzd2lwZXIuY2xpY2tlZEluZGV4ICE9PSBzd2lwZXIuYWN0aXZlSW5kZXgpIHtcbiAgICBzd2lwZXIuc2xpZGVUb0NsaWNrZWRTbGlkZSgpO1xuICB9XG59XG5cbnZhciB1cGRhdGUgPSB7XG4gIHVwZGF0ZVNpemUsXG4gIHVwZGF0ZVNsaWRlcyxcbiAgdXBkYXRlQXV0b0hlaWdodCxcbiAgdXBkYXRlU2xpZGVzT2Zmc2V0LFxuICB1cGRhdGVTbGlkZXNQcm9ncmVzcyxcbiAgdXBkYXRlUHJvZ3Jlc3MsXG4gIHVwZGF0ZVNsaWRlc0NsYXNzZXMsXG4gIHVwZGF0ZUFjdGl2ZUluZGV4LFxuICB1cGRhdGVDbGlja2VkU2xpZGVcbn07XG5cbmZ1bmN0aW9uIGdldFN3aXBlclRyYW5zbGF0ZShheGlzKSB7XG4gIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICBheGlzID0gdGhpcy5pc0hvcml6b250YWwoKSA/ICd4JyA6ICd5JztcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHRyYW5zbGF0ZSxcbiAgICB3cmFwcGVyRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKHBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XG4gIH1cbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgfVxuICBsZXQgY3VycmVudFRyYW5zbGF0ZSA9IGdldFRyYW5zbGF0ZSh3cmFwcGVyRWwsIGF4aXMpO1xuICBjdXJyZW50VHJhbnNsYXRlICs9IHN3aXBlci5jc3NPdmVyZmxvd0FkanVzdG1lbnQoKTtcbiAgaWYgKHJ0bCkgY3VycmVudFRyYW5zbGF0ZSA9IC1jdXJyZW50VHJhbnNsYXRlO1xuICByZXR1cm4gY3VycmVudFRyYW5zbGF0ZSB8fCAwO1xufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2xhdGUodHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIHBhcmFtcyxcbiAgICB3cmFwcGVyRWwsXG4gICAgcHJvZ3Jlc3NcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGNvbnN0IHogPSAwO1xuICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgeCA9IHJ0bCA/IC10cmFuc2xhdGUgOiB0cmFuc2xhdGU7XG4gIH0gZWxzZSB7XG4gICAgeSA9IHRyYW5zbGF0ZTtcbiAgfVxuICBpZiAocGFyYW1zLnJvdW5kTGVuZ3Rocykge1xuICAgIHggPSBNYXRoLmZsb29yKHgpO1xuICAgIHkgPSBNYXRoLmZsb29yKHkpO1xuICB9XG4gIHN3aXBlci5wcmV2aW91c1RyYW5zbGF0ZSA9IHN3aXBlci50cmFuc2xhdGU7XG4gIHN3aXBlci50cmFuc2xhdGUgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB4IDogeTtcbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgd3JhcHBlckVsW3N3aXBlci5pc0hvcml6b250YWwoKSA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IC14IDogLXk7XG4gIH0gZWxzZSBpZiAoIXBhcmFtcy52aXJ0dWFsVHJhbnNsYXRlKSB7XG4gICAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgICAgeCAtPSBzd2lwZXIuY3NzT3ZlcmZsb3dBZGp1c3RtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgLT0gc3dpcGVyLmNzc092ZXJmbG93QWRqdXN0bWVudCgpO1xuICAgIH1cbiAgICB3cmFwcGVyRWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7eH1weCwgJHt5fXB4LCAke3p9cHgpYDtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHByb2dyZXNzXG4gIGxldCBuZXdQcm9ncmVzcztcbiAgY29uc3QgdHJhbnNsYXRlc0RpZmYgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgLSBzd2lwZXIubWluVHJhbnNsYXRlKCk7XG4gIGlmICh0cmFuc2xhdGVzRGlmZiA9PT0gMCkge1xuICAgIG5ld1Byb2dyZXNzID0gMDtcbiAgfSBlbHNlIHtcbiAgICBuZXdQcm9ncmVzcyA9ICh0cmFuc2xhdGUgLSBzd2lwZXIubWluVHJhbnNsYXRlKCkpIC8gdHJhbnNsYXRlc0RpZmY7XG4gIH1cbiAgaWYgKG5ld1Byb2dyZXNzICE9PSBwcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyh0cmFuc2xhdGUpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBieUNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiBtaW5UcmFuc2xhdGUoKSB7XG4gIHJldHVybiAtdGhpcy5zbmFwR3JpZFswXTtcbn1cblxuZnVuY3Rpb24gbWF4VHJhbnNsYXRlKCkge1xuICByZXR1cm4gLXRoaXMuc25hcEdyaWRbdGhpcy5zbmFwR3JpZC5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlVG8odHJhbnNsYXRlLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCB0cmFuc2xhdGVCb3VuZHMsIGludGVybmFsKSB7XG4gIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkge1xuICAgIHRyYW5zbGF0ZSA9IDA7XG4gIH1cbiAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcbiAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHRyYW5zbGF0ZUJvdW5kcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNsYXRlQm91bmRzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHdyYXBwZXJFbFxuICB9ID0gc3dpcGVyO1xuICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG1pblRyYW5zbGF0ZSA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgY29uc3QgbWF4VHJhbnNsYXRlID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpO1xuICBsZXQgbmV3VHJhbnNsYXRlO1xuICBpZiAodHJhbnNsYXRlQm91bmRzICYmIHRyYW5zbGF0ZSA+IG1pblRyYW5zbGF0ZSkgbmV3VHJhbnNsYXRlID0gbWluVHJhbnNsYXRlO2Vsc2UgaWYgKHRyYW5zbGF0ZUJvdW5kcyAmJiB0cmFuc2xhdGUgPCBtYXhUcmFuc2xhdGUpIG5ld1RyYW5zbGF0ZSA9IG1heFRyYW5zbGF0ZTtlbHNlIG5ld1RyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcblxuICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKG5ld1RyYW5zbGF0ZSk7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkge1xuICAgIGNvbnN0IGlzSCA9IHN3aXBlci5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgIHdyYXBwZXJFbFtpc0ggPyAnc2Nyb2xsTGVmdCcgOiAnc2Nyb2xsVG9wJ10gPSAtbmV3VHJhbnNsYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN3aXBlci5zdXBwb3J0LnNtb290aFNjcm9sbCkge1xuICAgICAgICBhbmltYXRlQ1NTTW9kZVNjcm9sbCh7XG4gICAgICAgICAgc3dpcGVyLFxuICAgICAgICAgIHRhcmdldFBvc2l0aW9uOiAtbmV3VHJhbnNsYXRlLFxuICAgICAgICAgIHNpZGU6IGlzSCA/ICdsZWZ0JyA6ICd0b3AnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdyYXBwZXJFbC5zY3JvbGxUbyh7XG4gICAgICAgIFtpc0ggPyAnbGVmdCcgOiAndG9wJ106IC1uZXdUcmFuc2xhdGUsXG4gICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChzcGVlZCA9PT0gMCkge1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKDApO1xuICAgIHN3aXBlci5zZXRUcmFuc2xhdGUobmV3VHJhbnNsYXRlKTtcbiAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgICAgIHN3aXBlci5lbWl0KCd0cmFuc2l0aW9uRW5kJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXBlci5zZXRUcmFuc2l0aW9uKHNwZWVkKTtcbiAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG4gICAgaWYgKHJ1bkNhbGxiYWNrcykge1xuICAgICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVRyYW5zaXRpb25TdGFydCcsIHNwZWVkLCBpbnRlcm5hbCk7XG4gICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvblN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgICAgc3dpcGVyLmFuaW1hdGluZyA9IHRydWU7XG4gICAgICBpZiAoIXN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmQoZSkge1xuICAgICAgICAgIGlmICghc3dpcGVyIHx8IHN3aXBlci5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICBzd2lwZXIud3JhcHBlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICBzd2lwZXIub25UcmFuc2xhdGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICBkZWxldGUgc3dpcGVyLm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgICBpZiAocnVuQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBzd2lwZXIuZW1pdCgndHJhbnNpdGlvbkVuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN3aXBlci53cmFwcGVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHN3aXBlci5vblRyYW5zbGF0ZVRvV3JhcHBlclRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHRyYW5zbGF0ZSA9IHtcbiAgZ2V0VHJhbnNsYXRlOiBnZXRTd2lwZXJUcmFuc2xhdGUsXG4gIHNldFRyYW5zbGF0ZSxcbiAgbWluVHJhbnNsYXRlLFxuICBtYXhUcmFuc2xhdGUsXG4gIHRyYW5zbGF0ZVRvXG59O1xuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uKGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2R1cmF0aW9ufW1zYDtcbiAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGR1cmF0aW9uID09PSAwID8gYDBtc2AgOiAnJztcbiAgfVxuICBzd2lwZXIuZW1pdCgnc2V0VHJhbnNpdGlvbicsIGR1cmF0aW9uLCBieUNvbnRyb2xsZXIpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW1pdChfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIHJ1bkNhbGxiYWNrcyxcbiAgICBkaXJlY3Rpb24sXG4gICAgc3RlcFxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIHByZXZpb3VzSW5kZXhcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IGRpciA9IGRpcmVjdGlvbjtcbiAgaWYgKCFkaXIpIHtcbiAgICBpZiAoYWN0aXZlSW5kZXggPiBwcmV2aW91c0luZGV4KSBkaXIgPSAnbmV4dCc7ZWxzZSBpZiAoYWN0aXZlSW5kZXggPCBwcmV2aW91c0luZGV4KSBkaXIgPSAncHJldic7ZWxzZSBkaXIgPSAncmVzZXQnO1xuICB9XG4gIHN3aXBlci5lbWl0KGB0cmFuc2l0aW9uJHtzdGVwfWApO1xuICBpZiAocnVuQ2FsbGJhY2tzICYmIGFjdGl2ZUluZGV4ICE9PSBwcmV2aW91c0luZGV4KSB7XG4gICAgaWYgKGRpciA9PT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlUmVzZXRUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdChgc2xpZGVDaGFuZ2VUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgIGlmIChkaXIgPT09ICduZXh0Jykge1xuICAgICAgc3dpcGVyLmVtaXQoYHNsaWRlTmV4dFRyYW5zaXRpb24ke3N0ZXB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbWl0KGBzbGlkZVByZXZUcmFuc2l0aW9uJHtzdGVwfWApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uU3RhcnQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pIHtcbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zXG4gIH0gPSBzd2lwZXI7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICB9XG4gIHRyYW5zaXRpb25FbWl0KHtcbiAgICBzd2lwZXIsXG4gICAgcnVuQ2FsbGJhY2tzLFxuICAgIGRpcmVjdGlvbixcbiAgICBzdGVwOiAnU3RhcnQnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKSB7XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBzd2lwZXIuYW5pbWF0aW5nID0gZmFsc2U7XG4gIGlmIChwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuICBzd2lwZXIuc2V0VHJhbnNpdGlvbigwKTtcbiAgdHJhbnNpdGlvbkVtaXQoe1xuICAgIHN3aXBlcixcbiAgICBydW5DYWxsYmFja3MsXG4gICAgZGlyZWN0aW9uLFxuICAgIHN0ZXA6ICdFbmQnXG4gIH0pO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IHtcbiAgc2V0VHJhbnNpdGlvbixcbiAgdHJhbnNpdGlvblN0YXJ0LFxuICB0cmFuc2l0aW9uRW5kXG59O1xuXG5mdW5jdGlvbiBzbGlkZVRvKGluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCwgaW5pdGlhbCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBsZXQgc2xpZGVJbmRleCA9IGluZGV4O1xuICBpZiAoc2xpZGVJbmRleCA8IDApIHNsaWRlSW5kZXggPSAwO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNuYXBHcmlkLFxuICAgIHNsaWRlc0dyaWQsXG4gICAgcHJldmlvdXNJbmRleCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICB3cmFwcGVyRWwsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoc3dpcGVyLmFuaW1hdGluZyAmJiBwYXJhbXMucHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIHx8ICFlbmFibGVkICYmICFpbnRlcm5hbCAmJiAhaW5pdGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBza2lwID0gTWF0aC5taW4oc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAsIHNsaWRlSW5kZXgpO1xuICBsZXQgc25hcEluZGV4ID0gc2tpcCArIE1hdGguZmxvb3IoKHNsaWRlSW5kZXggLSBza2lwKSAvIHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXApO1xuICBpZiAoc25hcEluZGV4ID49IHNuYXBHcmlkLmxlbmd0aCkgc25hcEluZGV4ID0gc25hcEdyaWQubGVuZ3RoIC0gMTtcbiAgY29uc3QgdHJhbnNsYXRlID0gLXNuYXBHcmlkW3NuYXBJbmRleF07XG4gIC8vIE5vcm1hbGl6ZSBzbGlkZUluZGV4XG4gIGlmIChwYXJhbXMubm9ybWFsaXplU2xpZGVJbmRleCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVzR3JpZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgbm9ybWFsaXplZFRyYW5zbGF0ZSA9IC1NYXRoLmZsb29yKHRyYW5zbGF0ZSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZCA9IE1hdGguZmxvb3Ioc2xpZGVzR3JpZFtpXSAqIDEwMCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkR3JpZE5leHQgPSBNYXRoLmZsb29yKHNsaWRlc0dyaWRbaSArIDFdICogMTAwKTtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkICYmIG5vcm1hbGl6ZWRUcmFuc2xhdGUgPCBub3JtYWxpemVkR3JpZE5leHQgLSAobm9ybWFsaXplZEdyaWROZXh0IC0gbm9ybWFsaXplZEdyaWQpIC8gMikge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vcm1hbGl6ZWRUcmFuc2xhdGUgPj0gbm9ybWFsaXplZEdyaWQgJiYgbm9ybWFsaXplZFRyYW5zbGF0ZSA8IG5vcm1hbGl6ZWRHcmlkTmV4dCkge1xuICAgICAgICAgIHNsaWRlSW5kZXggPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub3JtYWxpemVkVHJhbnNsYXRlID49IG5vcm1hbGl6ZWRHcmlkKSB7XG4gICAgICAgIHNsaWRlSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmIChzd2lwZXIuaW5pdGlhbGl6ZWQgJiYgc2xpZGVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICBpZiAoIXN3aXBlci5hbGxvd1NsaWRlTmV4dCAmJiAocnRsID8gdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWluVHJhbnNsYXRlKCkgOiB0cmFuc2xhdGUgPCBzd2lwZXIudHJhbnNsYXRlICYmIHRyYW5zbGF0ZSA8IHN3aXBlci5taW5UcmFuc2xhdGUoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXIuYWxsb3dTbGlkZVByZXYgJiYgdHJhbnNsYXRlID4gc3dpcGVyLnRyYW5zbGF0ZSAmJiB0cmFuc2xhdGUgPiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGlmICgoYWN0aXZlSW5kZXggfHwgMCkgIT09IHNsaWRlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2xpZGVJbmRleCAhPT0gKHByZXZpb3VzSW5kZXggfHwgMCkgJiYgcnVuQ2FsbGJhY2tzKSB7XG4gICAgc3dpcGVyLmVtaXQoJ2JlZm9yZVNsaWRlQ2hhbmdlU3RhcnQnKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3ModHJhbnNsYXRlKTtcbiAgbGV0IGRpcmVjdGlvbjtcbiAgaWYgKHNsaWRlSW5kZXggPiBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ25leHQnO2Vsc2UgaWYgKHNsaWRlSW5kZXggPCBhY3RpdmVJbmRleCkgZGlyZWN0aW9uID0gJ3ByZXYnO2Vsc2UgZGlyZWN0aW9uID0gJ3Jlc2V0JztcblxuICAvLyBVcGRhdGUgSW5kZXhcbiAgaWYgKHJ0bCAmJiAtdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlIHx8ICFydGwgJiYgdHJhbnNsYXRlID09PSBzd2lwZXIudHJhbnNsYXRlKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIC8vIFVwZGF0ZSBIZWlnaHRcbiAgICBpZiAocGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICAgIHN3aXBlci51cGRhdGVBdXRvSGVpZ2h0KCk7XG4gICAgfVxuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgaWYgKHBhcmFtcy5lZmZlY3QgIT09ICdzbGlkZScpIHtcbiAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ3Jlc2V0Jykge1xuICAgICAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgICBzd2lwZXIudHJhbnNpdGlvbkVuZChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBjb25zdCBpc0ggPSBzd2lwZXIuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdCA9IHJ0bCA/IHRyYW5zbGF0ZSA6IC10cmFuc2xhdGU7XG4gICAgaWYgKHNwZWVkID09PSAwKSB7XG4gICAgICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgICAgICAgc3dpcGVyLl9pbW1lZGlhdGVWaXJ0dWFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZpcnR1YWwgJiYgIXN3aXBlci5fY3NzTW9kZVZpcnR1YWxJbml0aWFsU2V0ICYmIHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlID4gMCkge1xuICAgICAgICBzd2lwZXIuX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlckVsW2lzSCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnXSA9IHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICcnO1xuICAgICAgICAgIHN3aXBlci5faW1tZWRpYXRlVmlydHVhbCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzd2lwZXIuc3VwcG9ydC5zbW9vdGhTY3JvbGwpIHtcbiAgICAgICAgYW5pbWF0ZUNTU01vZGVTY3JvbGwoe1xuICAgICAgICAgIHN3aXBlcixcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogdCxcbiAgICAgICAgICBzaWRlOiBpc0ggPyAnbGVmdCcgOiAndG9wJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgICBbaXNIID8gJ2xlZnQnIDogJ3RvcCddOiB0LFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzd2lwZXIuc2V0VHJhbnNpdGlvbihzcGVlZCk7XG4gIHN3aXBlci5zZXRUcmFuc2xhdGUodHJhbnNsYXRlKTtcbiAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KHNsaWRlSW5kZXgpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBzd2lwZXIuZW1pdCgnYmVmb3JlVHJhbnNpdGlvblN0YXJ0Jywgc3BlZWQsIGludGVybmFsKTtcbiAgc3dpcGVyLnRyYW5zaXRpb25TdGFydChydW5DYWxsYmFja3MsIGRpcmVjdGlvbik7XG4gIGlmIChzcGVlZCA9PT0gMCkge1xuICAgIHN3aXBlci50cmFuc2l0aW9uRW5kKHJ1bkNhbGxiYWNrcywgZGlyZWN0aW9uKTtcbiAgfSBlbHNlIGlmICghc3dpcGVyLmFuaW1hdGluZykge1xuICAgIHN3aXBlci5hbmltYXRpbmcgPSB0cnVlO1xuICAgIGlmICghc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKSB7XG4gICAgICBzd2lwZXIub25TbGlkZVRvV3JhcHBlclRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKGUpIHtcbiAgICAgICAgaWYgKCFzd2lwZXIgfHwgc3dpcGVyLmRlc3Ryb3llZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIHN3aXBlci5vblNsaWRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgc3dpcGVyLnRyYW5zaXRpb25FbmQocnVuQ2FsbGJhY2tzLCBkaXJlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgc3dpcGVyLndyYXBwZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc3dpcGVyLm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0xvb3AoaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZXggPSAwO1xuICB9XG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgaW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgaW5kZXhBc051bWJlciA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgaW5kZXggPSBpbmRleEFzTnVtYmVyO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IGdyaWRFbmFibGVkID0gc3dpcGVyLmdyaWQgJiYgc3dpcGVyLnBhcmFtcy5ncmlkICYmIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgbGV0IG5ld0luZGV4ID0gaW5kZXg7XG4gIGlmIChzd2lwZXIucGFyYW1zLmxvb3ApIHtcbiAgICBpZiAoc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgbmV3SW5kZXggPSBuZXdJbmRleCArIHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhcmdldFNsaWRlSW5kZXg7XG4gICAgICBpZiAoZ3JpZEVuYWJsZWQpIHtcbiAgICAgICAgY29uc3Qgc2xpZGVJbmRleCA9IG5ld0luZGV4ICogc3dpcGVyLnBhcmFtcy5ncmlkLnJvd3M7XG4gICAgICAgIHRhcmdldFNsaWRlSW5kZXggPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gc2xpZGVJbmRleClbMF0uY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0U2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4QnlEYXRhKG5ld0luZGV4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHMgPSBncmlkRW5hYmxlZCA/IE1hdGguY2VpbChzd2lwZXIuc2xpZGVzLmxlbmd0aCAvIHN3aXBlci5wYXJhbXMuZ3JpZC5yb3dzKSA6IHN3aXBlci5zbGlkZXMubGVuZ3RoO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZW50ZXJlZFNsaWRlc1xuICAgICAgfSA9IHN3aXBlci5wYXJhbXM7XG4gICAgICBsZXQgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICAgIGlmIChzbGlkZXNQZXJWaWV3ID09PSAnYXV0bycpIHtcbiAgICAgICAgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xpZGVzUGVyVmlldyA9IE1hdGguY2VpbChwYXJzZUZsb2F0KHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICAgICAgaWYgKGNlbnRlcmVkU2xpZGVzICYmIHNsaWRlc1BlclZpZXcgJSAyID09PSAwKSB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldyA9IHNsaWRlc1BlclZpZXcgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgbmVlZExvb3BGaXggPSBjb2xzIC0gdGFyZ2V0U2xpZGVJbmRleCA8IHNsaWRlc1BlclZpZXc7XG4gICAgICBpZiAoY2VudGVyZWRTbGlkZXMpIHtcbiAgICAgICAgbmVlZExvb3BGaXggPSBuZWVkTG9vcEZpeCB8fCB0YXJnZXRTbGlkZUluZGV4IDwgTWF0aC5jZWlsKHNsaWRlc1BlclZpZXcgLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTG9vcEZpeCkge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBjZW50ZXJlZFNsaWRlcyA/IHRhcmdldFNsaWRlSW5kZXggPCBzd2lwZXIuYWN0aXZlSW5kZXggPyAncHJldicgOiAnbmV4dCcgOiB0YXJnZXRTbGlkZUluZGV4IC0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMSA8IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyA/ICduZXh0JyA6ICdwcmV2JztcbiAgICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICBzbGlkZVRvOiB0cnVlLFxuICAgICAgICAgIGFjdGl2ZVNsaWRlSW5kZXg6IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gdGFyZ2V0U2xpZGVJbmRleCArIDEgOiB0YXJnZXRTbGlkZUluZGV4IC0gY29scyArIDEsXG4gICAgICAgICAgc2xpZGVSZWFsSW5kZXg6IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gc3dpcGVyLnJlYWxJbmRleCA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gbmV3SW5kZXggKiBzd2lwZXIucGFyYW1zLmdyaWQucm93cztcbiAgICAgICAgbmV3SW5kZXggPSBzd2lwZXIuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gc2xpZGVJbmRleClbMF0uY29sdW1uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleEJ5RGF0YShuZXdJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgc3dpcGVyLnNsaWRlVG8obmV3SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgfSk7XG4gIHJldHVybiBzd2lwZXI7XG59XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogXCJvZmZcIiAqL1xuZnVuY3Rpb24gc2xpZGVOZXh0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKSB7XG4gIGlmIChzcGVlZCA9PT0gdm9pZCAwKSB7XG4gICAgc3BlZWQgPSB0aGlzLnBhcmFtcy5zcGVlZDtcbiAgfVxuICBpZiAocnVuQ2FsbGJhY2tzID09PSB2b2lkIDApIHtcbiAgICBydW5DYWxsYmFja3MgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkLFxuICAgIHBhcmFtcyxcbiAgICBhbmltYXRpbmdcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm4gc3dpcGVyO1xuICBsZXQgcGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gIGlmIChwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nICYmIHBhcmFtcy5zbGlkZXNQZXJHcm91cCA9PT0gMSAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvKSB7XG4gICAgcGVyR3JvdXAgPSBNYXRoLm1heChzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoJ2N1cnJlbnQnLCB0cnVlKSwgMSk7XG4gIH1cbiAgY29uc3QgaW5jcmVtZW50ID0gc3dpcGVyLmFjdGl2ZUluZGV4IDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwZXJHcm91cDtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKGFuaW1hdGluZyAmJiAhaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wUHJldmVudHNTbGlkaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgZGlyZWN0aW9uOiAnbmV4dCdcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIud3JhcHBlckVsLmNsaWVudExlZnQ7XG4gICAgaWYgKHN3aXBlci5hY3RpdmVJbmRleCA9PT0gc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggKyBpbmNyZW1lbnQsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0VuZCkge1xuICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbygwLCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCArIGluY3JlbWVudCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlUHJldihzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCkge1xuICBpZiAoc3BlZWQgPT09IHZvaWQgMCkge1xuICAgIHNwZWVkID0gdGhpcy5wYXJhbXMuc3BlZWQ7XG4gIH1cbiAgaWYgKHJ1bkNhbGxiYWNrcyA9PT0gdm9pZCAwKSB7XG4gICAgcnVuQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNuYXBHcmlkLFxuICAgIHNsaWRlc0dyaWQsXG4gICAgcnRsVHJhbnNsYXRlLFxuICAgIGVuYWJsZWQsXG4gICAgYW5pbWF0aW5nXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHN3aXBlcjtcbiAgY29uc3QgaXNWaXJ0dWFsID0gc3dpcGVyLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcbiAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgaWYgKGFuaW1hdGluZyAmJiAhaXNWaXJ0dWFsICYmIHBhcmFtcy5sb29wUHJldmVudHNTbGlkaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgZGlyZWN0aW9uOiAncHJldidcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzd2lwZXIuX2NsaWVudExlZnQgPSBzd2lwZXIud3JhcHBlckVsLmNsaWVudExlZnQ7XG4gIH1cbiAgY29uc3QgdHJhbnNsYXRlID0gcnRsVHJhbnNsYXRlID8gc3dpcGVyLnRyYW5zbGF0ZSA6IC1zd2lwZXIudHJhbnNsYXRlO1xuICBmdW5jdGlvbiBub3JtYWxpemUodmFsKSB7XG4gICAgaWYgKHZhbCA8IDApIHJldHVybiAtTWF0aC5mbG9vcihNYXRoLmFicyh2YWwpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2YWwpO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2xhdGUgPSBub3JtYWxpemUodHJhbnNsYXRlKTtcbiAgY29uc3Qgbm9ybWFsaXplZFNuYXBHcmlkID0gc25hcEdyaWQubWFwKHZhbCA9PiBub3JtYWxpemUodmFsKSk7XG4gIGxldCBwcmV2U25hcCA9IHNuYXBHcmlkW25vcm1hbGl6ZWRTbmFwR3JpZC5pbmRleE9mKG5vcm1hbGl6ZWRUcmFuc2xhdGUpIC0gMV07XG4gIGlmICh0eXBlb2YgcHJldlNuYXAgPT09ICd1bmRlZmluZWQnICYmIHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgbGV0IHByZXZTbmFwSW5kZXg7XG4gICAgc25hcEdyaWQuZm9yRWFjaCgoc25hcCwgc25hcEluZGV4KSA9PiB7XG4gICAgICBpZiAobm9ybWFsaXplZFRyYW5zbGF0ZSA+PSBzbmFwKSB7XG4gICAgICAgIC8vIHByZXZTbmFwID0gc25hcDtcbiAgICAgICAgcHJldlNuYXBJbmRleCA9IHNuYXBJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHByZXZTbmFwSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcmV2U25hcCA9IHNuYXBHcmlkW3ByZXZTbmFwSW5kZXggPiAwID8gcHJldlNuYXBJbmRleCAtIDEgOiBwcmV2U25hcEluZGV4XTtcbiAgICB9XG4gIH1cbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGlmICh0eXBlb2YgcHJldlNuYXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcHJldkluZGV4ID0gc2xpZGVzR3JpZC5pbmRleE9mKHByZXZTbmFwKTtcbiAgICBpZiAocHJldkluZGV4IDwgMCkgcHJldkluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4IC0gMTtcbiAgICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyAmJiBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgPT09IDEgJiYgcGFyYW1zLnNsaWRlc1Blckdyb3VwQXV0bykge1xuICAgICAgcHJldkluZGV4ID0gcHJldkluZGV4IC0gc3dpcGVyLnNsaWRlc1BlclZpZXdEeW5hbWljKCdwcmV2aW91cycsIHRydWUpICsgMTtcbiAgICAgIHByZXZJbmRleCA9IE1hdGgubWF4KHByZXZJbmRleCwgMCk7XG4gICAgfVxuICB9XG4gIGlmIChwYXJhbXMucmV3aW5kICYmIHN3aXBlci5pc0JlZ2lubmluZykge1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHN3aXBlci5wYXJhbXMudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBzd2lwZXIudmlydHVhbCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggLSAxIDogc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBzd2lwZXIuc2xpZGVUbyhsYXN0SW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbiAgfSBlbHNlIGlmIChwYXJhbXMubG9vcCAmJiBzd2lwZXIuYWN0aXZlSW5kZXggPT09IDAgJiYgcGFyYW1zLmNzc01vZGUpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgc3dpcGVyLnNsaWRlVG8ocHJldkluZGV4LCBzcGVlZCwgcnVuQ2FsbGJhY2tzLCBpbnRlcm5hbCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHByZXZJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlUmVzZXQoc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpIHtcbiAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcbiAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgcmV0dXJuIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCwgc3BlZWQsIHJ1bkNhbGxiYWNrcywgaW50ZXJuYWwpO1xufVxuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cbmZ1bmN0aW9uIHNsaWRlVG9DbG9zZXN0KHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsLCB0aHJlc2hvbGQpIHtcbiAgaWYgKHNwZWVkID09PSB2b2lkIDApIHtcbiAgICBzcGVlZCA9IHRoaXMucGFyYW1zLnNwZWVkO1xuICB9XG4gIGlmIChydW5DYWxsYmFja3MgPT09IHZvaWQgMCkge1xuICAgIHJ1bkNhbGxiYWNrcyA9IHRydWU7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgdGhyZXNob2xkID0gMC41O1xuICB9XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGxldCBpbmRleCA9IHN3aXBlci5hY3RpdmVJbmRleDtcbiAgY29uc3Qgc2tpcCA9IE1hdGgubWluKHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXBTa2lwLCBpbmRleCk7XG4gIGNvbnN0IHNuYXBJbmRleCA9IHNraXAgKyBNYXRoLmZsb29yKChpbmRleCAtIHNraXApIC8gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cCk7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIGlmICh0cmFuc2xhdGUgPj0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF0pIHtcbiAgICAvLyBUaGUgY3VycmVudCB0cmFuc2xhdGUgaXMgb24gb3IgYWZ0ZXIgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYWZ0ZXIgaXQuXG4gICAgY29uc3QgY3VycmVudFNuYXAgPSBzd2lwZXIuc25hcEdyaWRbc25hcEluZGV4XTtcbiAgICBjb25zdCBuZXh0U25hcCA9IHN3aXBlci5zbmFwR3JpZFtzbmFwSW5kZXggKyAxXTtcbiAgICBpZiAodHJhbnNsYXRlIC0gY3VycmVudFNuYXAgPiAobmV4dFNuYXAgLSBjdXJyZW50U25hcCkgKiB0aHJlc2hvbGQpIHtcbiAgICAgIGluZGV4ICs9IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyR3JvdXA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zbGF0ZSBpcyBiZWZvcmUgdGhlIGN1cnJlbnQgc25hcCBpbmRleCwgc28gdGhlIGNob2ljZVxuICAgIC8vIGlzIGJldHdlZW4gdGhlIGN1cnJlbnQgaW5kZXggYW5kIHRoZSBvbmUgYmVmb3JlIGl0LlxuICAgIGNvbnN0IHByZXZTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnJlbnRTbmFwID0gc3dpcGVyLnNuYXBHcmlkW3NuYXBJbmRleF07XG4gICAgaWYgKHRyYW5zbGF0ZSAtIHByZXZTbmFwIDw9IChjdXJyZW50U25hcCAtIHByZXZTbmFwKSAqIHRocmVzaG9sZCkge1xuICAgICAgaW5kZXggLT0gc3dpcGVyLnBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgICB9XG4gIH1cbiAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHN3aXBlci5zbGlkZXNHcmlkLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gc3dpcGVyLnNsaWRlVG8oaW5kZXgsIHNwZWVkLCBydW5DYWxsYmFja3MsIGludGVybmFsKTtcbn1cblxuZnVuY3Rpb24gc2xpZGVUb0NsaWNrZWRTbGlkZSgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICBzbGlkZXNFbFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBzbGlkZXNQZXJWaWV3ID0gcGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyA/IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpIDogcGFyYW1zLnNsaWRlc1BlclZpZXc7XG4gIGxldCBzbGlkZVRvSW5kZXggPSBzd2lwZXIuY2xpY2tlZEluZGV4O1xuICBsZXQgcmVhbEluZGV4O1xuICBjb25zdCBzbGlkZVNlbGVjdG9yID0gc3dpcGVyLmlzRWxlbWVudCA/IGBzd2lwZXItc2xpZGVgIDogYC4ke3BhcmFtcy5zbGlkZUNsYXNzfWA7XG4gIGlmIChwYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIuYW5pbWF0aW5nKSByZXR1cm47XG4gICAgcmVhbEluZGV4ID0gcGFyc2VJbnQoc3dpcGVyLmNsaWNrZWRTbGlkZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4JyksIDEwKTtcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBpZiAoc2xpZGVUb0luZGV4IDwgc3dpcGVyLmxvb3BlZFNsaWRlcyAtIHNsaWRlc1BlclZpZXcgLyAyIHx8IHNsaWRlVG9JbmRleCA+IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gc3dpcGVyLmxvb3BlZFNsaWRlcyArIHNsaWRlc1BlclZpZXcgLyAyKSB7XG4gICAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICAgIHNsaWRlVG9JbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYCR7c2xpZGVTZWxlY3Rvcn1bZGF0YS1zd2lwZXItc2xpZGUtaW5kZXg9XCIke3JlYWxJbmRleH1cIl1gKVswXSk7XG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzbGlkZVRvSW5kZXggPiBzd2lwZXIuc2xpZGVzLmxlbmd0aCAtIHNsaWRlc1BlclZpZXcpIHtcbiAgICAgIHN3aXBlci5sb29wRml4KCk7XG4gICAgICBzbGlkZVRvSW5kZXggPSBzd2lwZXIuZ2V0U2xpZGVJbmRleChlbGVtZW50Q2hpbGRyZW4oc2xpZGVzRWwsIGAke3NsaWRlU2VsZWN0b3J9W2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4PVwiJHtyZWFsSW5kZXh9XCJdYClbMF0pO1xuICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzbGlkZVRvSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN3aXBlci5zbGlkZVRvKHNsaWRlVG9JbmRleCk7XG4gIH1cbn1cblxudmFyIHNsaWRlID0ge1xuICBzbGlkZVRvLFxuICBzbGlkZVRvTG9vcCxcbiAgc2xpZGVOZXh0LFxuICBzbGlkZVByZXYsXG4gIHNsaWRlUmVzZXQsXG4gIHNsaWRlVG9DbG9zZXN0LFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlXG59O1xuXG5mdW5jdGlvbiBsb29wQ3JlYXRlKHNsaWRlUmVhbEluZGV4KSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgc2xpZGVzRWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFwYXJhbXMubG9vcCB8fCBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuICBjb25zdCBpbml0U2xpZGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IHNsaWRlcyA9IGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gICAgc2xpZGVzLmZvckVhY2goKGVsLCBpbmRleCkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcsIGluZGV4KTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgZ3JpZEVuYWJsZWQgPSBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcbiAgY29uc3Qgc2xpZGVzUGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXAgKiAoZ3JpZEVuYWJsZWQgPyBwYXJhbXMuZ3JpZC5yb3dzIDogMSk7XG4gIGNvbnN0IHNob3VsZEZpbGxHcm91cCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoICUgc2xpZGVzUGVyR3JvdXAgIT09IDA7XG4gIGNvbnN0IHNob3VsZEZpbGxHcmlkID0gZ3JpZEVuYWJsZWQgJiYgc3dpcGVyLnNsaWRlcy5sZW5ndGggJSBwYXJhbXMuZ3JpZC5yb3dzICE9PSAwO1xuICBjb25zdCBhZGRCbGFua1NsaWRlcyA9IGFtb3VudE9mU2xpZGVzID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudE9mU2xpZGVzOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNsaWRlRWwgPSBzd2lwZXIuaXNFbGVtZW50ID8gY3JlYXRlRWxlbWVudCgnc3dpcGVyLXNsaWRlJywgW3BhcmFtcy5zbGlkZUJsYW5rQ2xhc3NdKSA6IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIFtwYXJhbXMuc2xpZGVDbGFzcywgcGFyYW1zLnNsaWRlQmxhbmtDbGFzc10pO1xuICAgICAgc3dpcGVyLnNsaWRlc0VsLmFwcGVuZChzbGlkZUVsKTtcbiAgICB9XG4gIH07XG4gIGlmIChzaG91bGRGaWxsR3JvdXApIHtcbiAgICBpZiAocGFyYW1zLmxvb3BBZGRCbGFua1NsaWRlcykge1xuICAgICAgY29uc3Qgc2xpZGVzVG9BZGQgPSBzbGlkZXNQZXJHcm91cCAtIHN3aXBlci5zbGlkZXMubGVuZ3RoICUgc2xpZGVzUGVyR3JvdXA7XG4gICAgICBhZGRCbGFua1NsaWRlcyhzbGlkZXNUb0FkZCk7XG4gICAgICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZXZlbiB0byBzbGlkZXNQZXJHcm91cCwgbG9vcCBtb2RlIG1heSBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzLCBvciBlbXB0eSBzbGlkZXMpJyk7XG4gICAgfVxuICAgIGluaXRTbGlkZXMoKTtcbiAgfSBlbHNlIGlmIChzaG91bGRGaWxsR3JpZCkge1xuICAgIGlmIChwYXJhbXMubG9vcEFkZEJsYW5rU2xpZGVzKSB7XG4gICAgICBjb25zdCBzbGlkZXNUb0FkZCA9IHBhcmFtcy5ncmlkLnJvd3MgLSBzd2lwZXIuc2xpZGVzLmxlbmd0aCAlIHBhcmFtcy5ncmlkLnJvd3M7XG4gICAgICBhZGRCbGFua1NsaWRlcyhzbGlkZXNUb0FkZCk7XG4gICAgICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBUaGUgbnVtYmVyIG9mIHNsaWRlcyBpcyBub3QgZXZlbiB0byBncmlkLnJvd3MsIGxvb3AgbW9kZSBtYXkgbm90IGZ1bmN0aW9uIHByb3Blcmx5LiBZb3UgbmVlZCB0byBhZGQgbW9yZSBzbGlkZXMgKG9yIG1ha2UgZHVwbGljYXRlcywgb3IgZW1wdHkgc2xpZGVzKScpO1xuICAgIH1cbiAgICBpbml0U2xpZGVzKCk7XG4gIH0gZWxzZSB7XG4gICAgaW5pdFNsaWRlcygpO1xuICB9XG4gIHN3aXBlci5sb29wRml4KHtcbiAgICBzbGlkZVJlYWxJbmRleCxcbiAgICBkaXJlY3Rpb246IHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHVuZGVmaW5lZCA6ICduZXh0J1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbG9vcEZpeChfdGVtcCkge1xuICBsZXQge1xuICAgIHNsaWRlUmVhbEluZGV4LFxuICAgIHNsaWRlVG8gPSB0cnVlLFxuICAgIGRpcmVjdGlvbixcbiAgICBzZXRUcmFuc2xhdGUsXG4gICAgYWN0aXZlU2xpZGVJbmRleCxcbiAgICBieUNvbnRyb2xsZXIsXG4gICAgYnlNb3VzZXdoZWVsXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKCFzd2lwZXIucGFyYW1zLmxvb3ApIHJldHVybjtcbiAgc3dpcGVyLmVtaXQoJ2JlZm9yZUxvb3BGaXgnKTtcbiAgY29uc3Qge1xuICAgIHNsaWRlcyxcbiAgICBhbGxvd1NsaWRlUHJldixcbiAgICBhbGxvd1NsaWRlTmV4dCxcbiAgICBzbGlkZXNFbCxcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3Qge1xuICAgIGNlbnRlcmVkU2xpZGVzXG4gIH0gPSBwYXJhbXM7XG4gIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHRydWU7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHRydWU7XG4gIGlmIChzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgaWYgKHNsaWRlVG8pIHtcbiAgICAgIGlmICghcGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmIHN3aXBlci5zbmFwSW5kZXggPT09IDApIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnZpcnR1YWwuc2xpZGVzLmxlbmd0aCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2VudGVyZWRTbGlkZXMgJiYgc3dpcGVyLnNuYXBJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJWaWV3KSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggKyBzd2lwZXIuc25hcEluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN3aXBlci5zbmFwSW5kZXggPT09IHN3aXBlci5zbmFwR3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci52aXJ0dWFsLnNsaWRlc0JlZm9yZSwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSBhbGxvd1NsaWRlTmV4dDtcbiAgICBzd2lwZXIuZW1pdCgnbG9vcEZpeCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2xpZGVzUGVyVmlldyA9IHBhcmFtcy5zbGlkZXNQZXJWaWV3O1xuICBpZiAoc2xpZGVzUGVyVmlldyA9PT0gJ2F1dG8nKSB7XG4gICAgc2xpZGVzUGVyVmlldyA9IHN3aXBlci5zbGlkZXNQZXJWaWV3RHluYW1pYygpO1xuICB9IGVsc2Uge1xuICAgIHNsaWRlc1BlclZpZXcgPSBNYXRoLmNlaWwocGFyc2VGbG9hdChwYXJhbXMuc2xpZGVzUGVyVmlldywgMTApKTtcbiAgICBpZiAoY2VudGVyZWRTbGlkZXMgJiYgc2xpZGVzUGVyVmlldyAlIDIgPT09IDApIHtcbiAgICAgIHNsaWRlc1BlclZpZXcgPSBzbGlkZXNQZXJWaWV3ICsgMTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2xpZGVzUGVyR3JvdXAgPSBwYXJhbXMuc2xpZGVzUGVyR3JvdXBBdXRvID8gc2xpZGVzUGVyVmlldyA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgbGV0IGxvb3BlZFNsaWRlcyA9IHNsaWRlc1Blckdyb3VwO1xuICBpZiAobG9vcGVkU2xpZGVzICUgc2xpZGVzUGVyR3JvdXAgIT09IDApIHtcbiAgICBsb29wZWRTbGlkZXMgKz0gc2xpZGVzUGVyR3JvdXAgLSBsb29wZWRTbGlkZXMgJSBzbGlkZXNQZXJHcm91cDtcbiAgfVxuICBsb29wZWRTbGlkZXMgKz0gcGFyYW1zLmxvb3BBZGRpdGlvbmFsU2xpZGVzO1xuICBzd2lwZXIubG9vcGVkU2xpZGVzID0gbG9vcGVkU2xpZGVzO1xuICBjb25zdCBncmlkRW5hYmxlZCA9IHN3aXBlci5ncmlkICYmIHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxO1xuICBpZiAoc2xpZGVzLmxlbmd0aCA8IHNsaWRlc1BlclZpZXcgKyBsb29wZWRTbGlkZXMpIHtcbiAgICBzaG93V2FybmluZygnU3dpcGVyIExvb3AgV2FybmluZzogVGhlIG51bWJlciBvZiBzbGlkZXMgaXMgbm90IGVub3VnaCBmb3IgbG9vcCBtb2RlLCBpdCB3aWxsIGJlIGRpc2FibGVkIGFuZCBub3QgZnVuY3Rpb24gcHJvcGVybHkuIFlvdSBuZWVkIHRvIGFkZCBtb3JlIHNsaWRlcyAob3IgbWFrZSBkdXBsaWNhdGVzKSBvciBsb3dlciB0aGUgdmFsdWVzIG9mIHNsaWRlc1BlclZpZXcgYW5kIHNsaWRlc1Blckdyb3VwIHBhcmFtZXRlcnMnKTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCAmJiBwYXJhbXMuZ3JpZC5maWxsID09PSAncm93Jykge1xuICAgIHNob3dXYXJuaW5nKCdTd2lwZXIgTG9vcCBXYXJuaW5nOiBMb29wIG1vZGUgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBncmlkLmZpbGwgPSBgcm93YCcpO1xuICB9XG4gIGNvbnN0IHByZXBlbmRTbGlkZXNJbmRleGVzID0gW107XG4gIGNvbnN0IGFwcGVuZFNsaWRlc0luZGV4ZXMgPSBbXTtcbiAgbGV0IGFjdGl2ZUluZGV4ID0gc3dpcGVyLmFjdGl2ZUluZGV4O1xuICBpZiAodHlwZW9mIGFjdGl2ZVNsaWRlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYWN0aXZlU2xpZGVJbmRleCA9IHN3aXBlci5nZXRTbGlkZUluZGV4KHNsaWRlcy5maWx0ZXIoZWwgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzKSlbMF0pO1xuICB9IGVsc2Uge1xuICAgIGFjdGl2ZUluZGV4ID0gYWN0aXZlU2xpZGVJbmRleDtcbiAgfVxuICBjb25zdCBpc05leHQgPSBkaXJlY3Rpb24gPT09ICduZXh0JyB8fCAhZGlyZWN0aW9uO1xuICBjb25zdCBpc1ByZXYgPSBkaXJlY3Rpb24gPT09ICdwcmV2JyB8fCAhZGlyZWN0aW9uO1xuICBsZXQgc2xpZGVzUHJlcGVuZGVkID0gMDtcbiAgbGV0IHNsaWRlc0FwcGVuZGVkID0gMDtcbiAgY29uc3QgY29scyA9IGdyaWRFbmFibGVkID8gTWF0aC5jZWlsKHNsaWRlcy5sZW5ndGggLyBwYXJhbXMuZ3JpZC5yb3dzKSA6IHNsaWRlcy5sZW5ndGg7XG4gIGNvbnN0IGFjdGl2ZUNvbEluZGV4ID0gZ3JpZEVuYWJsZWQgPyBzbGlkZXNbYWN0aXZlU2xpZGVJbmRleF0uY29sdW1uIDogYWN0aXZlU2xpZGVJbmRleDtcbiAgY29uc3QgYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQgPSBhY3RpdmVDb2xJbmRleCArIChjZW50ZXJlZFNsaWRlcyAmJiB0eXBlb2Ygc2V0VHJhbnNsYXRlID09PSAndW5kZWZpbmVkJyA/IC1zbGlkZXNQZXJWaWV3IC8gMiArIDAuNSA6IDApO1xuICAvLyBwcmVwZW5kIGxhc3Qgc2xpZGVzIGJlZm9yZSBzdGFydFxuICBpZiAoYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQgPCBsb29wZWRTbGlkZXMpIHtcbiAgICBzbGlkZXNQcmVwZW5kZWQgPSBNYXRoLm1heChsb29wZWRTbGlkZXMgLSBhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCwgc2xpZGVzUGVyR3JvdXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9vcGVkU2xpZGVzIC0gYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgaW5kZXggPSBpIC0gTWF0aC5mbG9vcihpIC8gY29scykgKiBjb2xzO1xuICAgICAgaWYgKGdyaWRFbmFibGVkKSB7XG4gICAgICAgIGNvbnN0IGNvbEluZGV4VG9QcmVwZW5kID0gY29scyAtIGluZGV4IC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNsaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgIGlmIChzbGlkZXNbaV0uY29sdW1uID09PSBjb2xJbmRleFRvUHJlcGVuZCkgcHJlcGVuZFNsaWRlc0luZGV4ZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgLy8gICBpZiAoc2xpZGUuY29sdW1uID09PSBjb2xJbmRleFRvUHJlcGVuZCkgcHJlcGVuZFNsaWRlc0luZGV4ZXMucHVzaChzbGlkZUluZGV4KTtcbiAgICAgICAgLy8gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKGNvbHMgLSBpbmRleCAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCArIHNsaWRlc1BlclZpZXcgPiBjb2xzIC0gbG9vcGVkU2xpZGVzKSB7XG4gICAgc2xpZGVzQXBwZW5kZWQgPSBNYXRoLm1heChhY3RpdmVDb2xJbmRleFdpdGhTaGlmdCAtIChjb2xzIC0gbG9vcGVkU2xpZGVzICogMiksIHNsaWRlc1Blckdyb3VwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlc0FwcGVuZGVkOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAtIE1hdGguZmxvb3IoaSAvIGNvbHMpICogY29scztcbiAgICAgIGlmIChncmlkRW5hYmxlZCkge1xuICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUsIHNsaWRlSW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoc2xpZGUuY29sdW1uID09PSBpbmRleCkgYXBwZW5kU2xpZGVzSW5kZXhlcy5wdXNoKHNsaWRlSW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZFNsaWRlc0luZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gdHJ1ZTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IGZhbHNlO1xuICB9KTtcbiAgaWYgKGlzUHJldikge1xuICAgIHByZXBlbmRTbGlkZXNJbmRleGVzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IHRydWU7XG4gICAgICBzbGlkZXNFbC5wcmVwZW5kKHNsaWRlc1tpbmRleF0pO1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIGlmIChpc05leHQpIHtcbiAgICBhcHBlbmRTbGlkZXNJbmRleGVzLmZvckVhY2goaW5kZXggPT4ge1xuICAgICAgc2xpZGVzW2luZGV4XS5zd2lwZXJMb29wTW92ZURPTSA9IHRydWU7XG4gICAgICBzbGlkZXNFbC5hcHBlbmQoc2xpZGVzW2luZGV4XSk7XG4gICAgICBzbGlkZXNbaW5kZXhdLnN3aXBlckxvb3BNb3ZlRE9NID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBpZiAocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJykge1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgfSBlbHNlIGlmIChncmlkRW5hYmxlZCAmJiAocHJlcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoID4gMCAmJiBpc1ByZXYgfHwgYXBwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGggPiAwICYmIGlzTmV4dCkpIHtcbiAgICBzd2lwZXIuc2xpZGVzLmZvckVhY2goKHNsaWRlLCBzbGlkZUluZGV4KSA9PiB7XG4gICAgICBzd2lwZXIuZ3JpZC51cGRhdGVTbGlkZShzbGlkZUluZGV4LCBzbGlkZSwgc3dpcGVyLnNsaWRlcyk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc09mZnNldCgpO1xuICB9XG4gIGlmIChzbGlkZVRvKSB7XG4gICAgaWYgKHByZXBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCA+IDAgJiYgaXNQcmV2KSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlUmVhbEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbYWN0aXZlSW5kZXggKyBzbGlkZXNQcmVwZW5kZWRdO1xuICAgICAgICBjb25zdCBkaWZmID0gbmV3U2xpZGVUcmFuc2xhdGUgLSBjdXJyZW50U2xpZGVUcmFuc2xhdGU7XG4gICAgICAgIGlmIChieU1vdXNld2hlZWwpIHtcbiAgICAgICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKHN3aXBlci50cmFuc2xhdGUgLSBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2lwZXIuc2xpZGVUbyhhY3RpdmVJbmRleCArIHNsaWRlc1ByZXBlbmRlZCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIGlmIChzZXRUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEuc3RhcnRUcmFuc2xhdGUgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnN0YXJ0VHJhbnNsYXRlIC0gZGlmZjtcbiAgICAgICAgICAgIHN3aXBlci50b3VjaEV2ZW50c0RhdGEuY3VycmVudFRyYW5zbGF0ZSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGEuY3VycmVudFRyYW5zbGF0ZSAtIGRpZmY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2V0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2hpZnQgPSBncmlkRW5hYmxlZCA/IHByZXBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCAvIHBhcmFtcy5ncmlkLnJvd3MgOiBwcmVwZW5kU2xpZGVzSW5kZXhlcy5sZW5ndGg7XG4gICAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4ICsgc2hpZnQsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIudHJhbnNsYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcHBlbmRTbGlkZXNJbmRleGVzLmxlbmd0aCA+IDAgJiYgaXNOZXh0KSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlUmVhbEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2xpZGVUcmFuc2xhdGUgPSBzd2lwZXIuc2xpZGVzR3JpZFthY3RpdmVJbmRleF07XG4gICAgICAgIGNvbnN0IG5ld1NsaWRlVHJhbnNsYXRlID0gc3dpcGVyLnNsaWRlc0dyaWRbYWN0aXZlSW5kZXggLSBzbGlkZXNBcHBlbmRlZF07XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTbGlkZVRyYW5zbGF0ZSAtIGN1cnJlbnRTbGlkZVRyYW5zbGF0ZTtcbiAgICAgICAgaWYgKGJ5TW91c2V3aGVlbCkge1xuICAgICAgICAgIHN3aXBlci5zZXRUcmFuc2xhdGUoc3dpcGVyLnRyYW5zbGF0ZSAtIGRpZmYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3aXBlci5zbGlkZVRvKGFjdGl2ZUluZGV4IC0gc2xpZGVzQXBwZW5kZWQsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoc2V0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLnN0YXJ0VHJhbnNsYXRlID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YS5zdGFydFRyYW5zbGF0ZSAtIGRpZmY7XG4gICAgICAgICAgICBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhLmN1cnJlbnRUcmFuc2xhdGUgLSBkaWZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBncmlkRW5hYmxlZCA/IGFwcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoIC8gcGFyYW1zLmdyaWQucm93cyA6IGFwcGVuZFNsaWRlc0luZGV4ZXMubGVuZ3RoO1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXggLSBzaGlmdCwgMCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSBhbGxvd1NsaWRlUHJldjtcbiAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gYWxsb3dTbGlkZU5leHQ7XG4gIGlmIChzd2lwZXIuY29udHJvbGxlciAmJiBzd2lwZXIuY29udHJvbGxlci5jb250cm9sICYmICFieUNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBsb29wUGFyYW1zID0ge1xuICAgICAgc2xpZGVSZWFsSW5kZXgsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBzZXRUcmFuc2xhdGUsXG4gICAgICBhY3RpdmVTbGlkZUluZGV4LFxuICAgICAgYnlDb250cm9sbGVyOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzd2lwZXIuY29udHJvbGxlci5jb250cm9sKSkge1xuICAgICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbC5mb3JFYWNoKGMgPT4ge1xuICAgICAgICBpZiAoIWMuZGVzdHJveWVkICYmIGMucGFyYW1zLmxvb3ApIGMubG9vcEZpeCh7XG4gICAgICAgICAgLi4ubG9vcFBhcmFtcyxcbiAgICAgICAgICBzbGlkZVRvOiBjLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSBwYXJhbXMuc2xpZGVzUGVyVmlldyA/IHNsaWRlVG8gOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCBpbnN0YW5jZW9mIHN3aXBlci5jb25zdHJ1Y3RvciAmJiBzd2lwZXIuY29udHJvbGxlci5jb250cm9sLnBhcmFtcy5sb29wKSB7XG4gICAgICBzd2lwZXIuY29udHJvbGxlci5jb250cm9sLmxvb3BGaXgoe1xuICAgICAgICAuLi5sb29wUGFyYW1zLFxuICAgICAgICBzbGlkZVRvOiBzd2lwZXIuY29udHJvbGxlci5jb250cm9sLnBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSBwYXJhbXMuc2xpZGVzUGVyVmlldyA/IHNsaWRlVG8gOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN3aXBlci5lbWl0KCdsb29wRml4Jyk7XG59XG5cbmZ1bmN0aW9uIGxvb3BEZXN0cm95KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcGFyYW1zLFxuICAgIHNsaWRlc0VsXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghcGFyYW1zLmxvb3AgfHwgc3dpcGVyLnZpcnR1YWwgJiYgc3dpcGVyLnBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHJldHVybjtcbiAgc3dpcGVyLnJlY2FsY1NsaWRlcygpO1xuICBjb25zdCBuZXdTbGlkZXNPcmRlciA9IFtdO1xuICBzd2lwZXIuc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2Ygc2xpZGVFbC5zd2lwZXJTbGlkZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA6IHNsaWRlRWwuc3dpcGVyU2xpZGVJbmRleDtcbiAgICBuZXdTbGlkZXNPcmRlcltpbmRleF0gPSBzbGlkZUVsO1xuICB9KTtcbiAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgIHNsaWRlRWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpO1xuICB9KTtcbiAgbmV3U2xpZGVzT3JkZXIuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICBzbGlkZXNFbC5hcHBlbmQoc2xpZGVFbCk7XG4gIH0pO1xuICBzd2lwZXIucmVjYWxjU2xpZGVzKCk7XG4gIHN3aXBlci5zbGlkZVRvKHN3aXBlci5yZWFsSW5kZXgsIDApO1xufVxuXG52YXIgbG9vcCA9IHtcbiAgbG9vcENyZWF0ZSxcbiAgbG9vcEZpeCxcbiAgbG9vcERlc3Ryb3lcbn07XG5cbmZ1bmN0aW9uIHNldEdyYWJDdXJzb3IobW92aW5nKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGlmICghc3dpcGVyLnBhcmFtcy5zaW11bGF0ZVRvdWNoIHx8IHN3aXBlci5wYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzd2lwZXIuaXNMb2NrZWQgfHwgc3dpcGVyLnBhcmFtcy5jc3NNb2RlKSByZXR1cm47XG4gIGNvbnN0IGVsID0gc3dpcGVyLnBhcmFtcy50b3VjaEV2ZW50c1RhcmdldCA9PT0gJ2NvbnRhaW5lcicgPyBzd2lwZXIuZWwgOiBzd2lwZXIud3JhcHBlckVsO1xuICBpZiAoc3dpcGVyLmlzRWxlbWVudCkge1xuICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gdHJ1ZTtcbiAgfVxuICBlbC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIGVsLnN0eWxlLmN1cnNvciA9IG1vdmluZyA/ICdncmFiYmluZycgOiAnZ3JhYic7XG4gIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHN3aXBlci5fX3ByZXZlbnRPYnNlcnZlcl9fID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zZXRHcmFiQ3Vyc29yKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHN3aXBlci5pc0xvY2tlZCB8fCBzd2lwZXIucGFyYW1zLmNzc01vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICBzd2lwZXIuX19wcmV2ZW50T2JzZXJ2ZXJfXyA9IHRydWU7XG4gIH1cbiAgc3dpcGVyW3N3aXBlci5wYXJhbXMudG91Y2hFdmVudHNUYXJnZXQgPT09ICdjb250YWluZXInID8gJ2VsJyA6ICd3cmFwcGVyRWwnXS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgc3dpcGVyLl9fcHJldmVudE9ic2VydmVyX18gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZ3JhYkN1cnNvciA9IHtcbiAgc2V0R3JhYkN1cnNvcixcbiAgdW5zZXRHcmFiQ3Vyc29yXG59O1xuXG4vLyBNb2RpZmllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0NTIwNTU0L2N1c3RvbS1lbGVtZW50LWdldHJvb3Rub2RlLWNsb3Nlc3QtZnVuY3Rpb24tY3Jvc3NpbmctbXVsdGlwbGUtcGFyZW50LXNoYWRvd2RcbmZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50KHNlbGVjdG9yLCBiYXNlKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICBiYXNlID0gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBfX2Nsb3Nlc3RGcm9tKGVsKSB7XG4gICAgaWYgKCFlbCB8fCBlbCA9PT0gZ2V0RG9jdW1lbnQoKSB8fCBlbCA9PT0gZ2V0V2luZG93KCkpIHJldHVybiBudWxsO1xuICAgIGlmIChlbC5hc3NpZ25lZFNsb3QpIGVsID0gZWwuYXNzaWduZWRTbG90O1xuICAgIGNvbnN0IGZvdW5kID0gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgaWYgKCFmb3VuZCAmJiAhZWwuZ2V0Um9vdE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQgfHwgX19jbG9zZXN0RnJvbShlbC5nZXRSb290Tm9kZSgpLmhvc3QpO1xuICB9XG4gIHJldHVybiBfX2Nsb3Nlc3RGcm9tKGJhc2UpO1xufVxuZnVuY3Rpb24gcHJldmVudEVkZ2VTd2lwZShzd2lwZXIsIGV2ZW50LCBzdGFydFgpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgY29uc3QgZWRnZVN3aXBlRGV0ZWN0aW9uID0gcGFyYW1zLmVkZ2VTd2lwZURldGVjdGlvbjtcbiAgY29uc3QgZWRnZVN3aXBlVGhyZXNob2xkID0gcGFyYW1zLmVkZ2VTd2lwZVRocmVzaG9sZDtcbiAgaWYgKGVkZ2VTd2lwZURldGVjdGlvbiAmJiAoc3RhcnRYIDw9IGVkZ2VTd2lwZVRocmVzaG9sZCB8fCBzdGFydFggPj0gd2luZG93LmlubmVyV2lkdGggLSBlZGdlU3dpcGVUaHJlc2hvbGQpKSB7XG4gICAgaWYgKGVkZ2VTd2lwZURldGVjdGlvbiA9PT0gJ3ByZXZlbnQnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9uVG91Y2hTdGFydChldmVudCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGNvbnN0IGRhdGEgPSBzd2lwZXIudG91Y2hFdmVudHNEYXRhO1xuICBpZiAoZS50eXBlID09PSAncG9pbnRlcmRvd24nKSB7XG4gICAgaWYgKGRhdGEucG9pbnRlcklkICE9PSBudWxsICYmIGRhdGEucG9pbnRlcklkICE9PSBlLnBvaW50ZXJJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnBvaW50ZXJJZCA9IGUucG9pbnRlcklkO1xuICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICBkYXRhLnRvdWNoSWQgPSBlLnRhcmdldFRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgfVxuICBpZiAoZS50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAvLyBkb24ndCBwcm9jZWVkIHRvdWNoIGV2ZW50XG4gICAgcHJldmVudEVkZ2VTd2lwZShzd2lwZXIsIGUsIGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgdG91Y2hlcyxcbiAgICBlbmFibGVkXG4gIH0gPSBzd2lwZXI7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICBpZiAoIXBhcmFtcy5zaW11bGF0ZVRvdWNoICYmIGUucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHJldHVybjtcbiAgaWYgKHN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLnByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN3aXBlci5hbmltYXRpbmcgJiYgcGFyYW1zLmNzc01vZGUgJiYgcGFyYW1zLmxvb3ApIHtcbiAgICBzd2lwZXIubG9vcEZpeCgpO1xuICB9XG4gIGxldCB0YXJnZXRFbCA9IGUudGFyZ2V0O1xuICBpZiAocGFyYW1zLnRvdWNoRXZlbnRzVGFyZ2V0ID09PSAnd3JhcHBlcicpIHtcbiAgICBpZiAoIXN3aXBlci53cmFwcGVyRWwuY29udGFpbnModGFyZ2V0RWwpKSByZXR1cm47XG4gIH1cbiAgaWYgKCd3aGljaCcgaW4gZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm47XG4gIGlmICgnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uID4gMCkgcmV0dXJuO1xuICBpZiAoZGF0YS5pc1RvdWNoZWQgJiYgZGF0YS5pc01vdmVkKSByZXR1cm47XG5cbiAgLy8gY2hhbmdlIHRhcmdldCBlbCBmb3Igc2hhZG93IHJvb3QgY29tcG9uZW50XG4gIGNvbnN0IHN3aXBpbmdDbGFzc0hhc1ZhbHVlID0gISFwYXJhbXMubm9Td2lwaW5nQ2xhc3MgJiYgcGFyYW1zLm5vU3dpcGluZ0NsYXNzICE9PSAnJztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGNvbnN0IGV2ZW50UGF0aCA9IGUuY29tcG9zZWRQYXRoID8gZS5jb21wb3NlZFBhdGgoKSA6IGUucGF0aDtcbiAgaWYgKHN3aXBpbmdDbGFzc0hhc1ZhbHVlICYmIGUudGFyZ2V0ICYmIGUudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgZXZlbnRQYXRoKSB7XG4gICAgdGFyZ2V0RWwgPSBldmVudFBhdGhbMF07XG4gIH1cbiAgY29uc3Qgbm9Td2lwaW5nU2VsZWN0b3IgPSBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgPyBwYXJhbXMubm9Td2lwaW5nU2VsZWN0b3IgOiBgLiR7cGFyYW1zLm5vU3dpcGluZ0NsYXNzfWA7XG4gIGNvbnN0IGlzVGFyZ2V0U2hhZG93ID0gISEoZS50YXJnZXQgJiYgZS50YXJnZXQuc2hhZG93Um9vdCk7XG5cbiAgLy8gdXNlIGNsb3Nlc3RFbGVtZW50IGZvciBzaGFkb3cgcm9vdCBlbGVtZW50IHRvIGdldCB0aGUgYWN0dWFsIGNsb3Nlc3QgZm9yIG5lc3RlZCBzaGFkb3cgcm9vdCBlbGVtZW50XG4gIGlmIChwYXJhbXMubm9Td2lwaW5nICYmIChpc1RhcmdldFNoYWRvdyA/IGNsb3Nlc3RFbGVtZW50KG5vU3dpcGluZ1NlbGVjdG9yLCB0YXJnZXRFbCkgOiB0YXJnZXRFbC5jbG9zZXN0KG5vU3dpcGluZ1NlbGVjdG9yKSkpIHtcbiAgICBzd2lwZXIuYWxsb3dDbGljayA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuc3dpcGVIYW5kbGVyKSB7XG4gICAgaWYgKCF0YXJnZXRFbC5jbG9zZXN0KHBhcmFtcy5zd2lwZUhhbmRsZXIpKSByZXR1cm47XG4gIH1cbiAgdG91Y2hlcy5jdXJyZW50WCA9IGUucGFnZVg7XG4gIHRvdWNoZXMuY3VycmVudFkgPSBlLnBhZ2VZO1xuICBjb25zdCBzdGFydFggPSB0b3VjaGVzLmN1cnJlbnRYO1xuICBjb25zdCBzdGFydFkgPSB0b3VjaGVzLmN1cnJlbnRZO1xuXG4gIC8vIERvIE5PVCBzdGFydCBpZiBpT1MgZWRnZSBzd2lwZSBpcyBkZXRlY3RlZC4gT3RoZXJ3aXNlIGlPUyBhcHAgY2Fubm90IHN3aXBlLXRvLWdvLWJhY2sgYW55bW9yZVxuXG4gIGlmICghcHJldmVudEVkZ2VTd2lwZShzd2lwZXIsIGUsIHN0YXJ0WCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgaXNUb3VjaGVkOiB0cnVlLFxuICAgIGlzTW92ZWQ6IGZhbHNlLFxuICAgIGFsbG93VG91Y2hDYWxsYmFja3M6IHRydWUsXG4gICAgaXNTY3JvbGxpbmc6IHVuZGVmaW5lZCxcbiAgICBzdGFydE1vdmluZzogdW5kZWZpbmVkXG4gIH0pO1xuICB0b3VjaGVzLnN0YXJ0WCA9IHN0YXJ0WDtcbiAgdG91Y2hlcy5zdGFydFkgPSBzdGFydFk7XG4gIGRhdGEudG91Y2hTdGFydFRpbWUgPSBub3coKTtcbiAgc3dpcGVyLmFsbG93Q2xpY2sgPSB0cnVlO1xuICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xuICBzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPSB1bmRlZmluZWQ7XG4gIGlmIChwYXJhbXMudGhyZXNob2xkID4gMCkgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgPSBmYWxzZTtcbiAgbGV0IHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgaWYgKHRhcmdldEVsLm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIGlmICh0YXJnZXRFbC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQubWF0Y2hlcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0YXJnZXRFbCkge1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICB9XG4gIGNvbnN0IHNob3VsZFByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQgJiYgc3dpcGVyLmFsbG93VG91Y2hNb3ZlICYmIHBhcmFtcy50b3VjaFN0YXJ0UHJldmVudERlZmF1bHQ7XG4gIGlmICgocGFyYW1zLnRvdWNoU3RhcnRGb3JjZVByZXZlbnREZWZhdWx0IHx8IHNob3VsZFByZXZlbnREZWZhdWx0KSAmJiAhdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgaWYgKHBhcmFtcy5mcmVlTW9kZSAmJiBwYXJhbXMuZnJlZU1vZGUuZW5hYmxlZCAmJiBzd2lwZXIuZnJlZU1vZGUgJiYgc3dpcGVyLmFuaW1hdGluZyAmJiAhcGFyYW1zLmNzc01vZGUpIHtcbiAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaFN0YXJ0KCk7XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ3RvdWNoU3RhcnQnLCBlKTtcbn1cblxuZnVuY3Rpb24gb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCBkYXRhID0gc3dpcGVyLnRvdWNoRXZlbnRzRGF0YTtcbiAgY29uc3Qge1xuICAgIHBhcmFtcyxcbiAgICB0b3VjaGVzLFxuICAgIHJ0bFRyYW5zbGF0ZTogcnRsLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gIGlmICghcGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHJldHVybjtcbiAgbGV0IGUgPSBldmVudDtcbiAgaWYgKGUub3JpZ2luYWxFdmVudCkgZSA9IGUub3JpZ2luYWxFdmVudDtcbiAgaWYgKGUudHlwZSA9PT0gJ3BvaW50ZXJtb3ZlJykge1xuICAgIGlmIChkYXRhLnRvdWNoSWQgIT09IG51bGwpIHJldHVybjsgLy8gcmV0dXJuIGZyb20gcG9pbnRlciBpZiB3ZSB1c2UgdG91Y2hcbiAgICBjb25zdCBpZCA9IGUucG9pbnRlcklkO1xuICAgIGlmIChpZCAhPT0gZGF0YS5wb2ludGVySWQpIHJldHVybjtcbiAgfVxuICBsZXQgdGFyZ2V0VG91Y2g7XG4gIGlmIChlLnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgdGFyZ2V0VG91Y2ggPSBbLi4uZS5jaGFuZ2VkVG91Y2hlc10uZmlsdGVyKHQgPT4gdC5pZGVudGlmaWVyID09PSBkYXRhLnRvdWNoSWQpWzBdO1xuICAgIGlmICghdGFyZ2V0VG91Y2ggfHwgdGFyZ2V0VG91Y2guaWRlbnRpZmllciAhPT0gZGF0YS50b3VjaElkKSByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0VG91Y2ggPSBlO1xuICB9XG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICBpZiAoZGF0YS5zdGFydE1vdmluZyAmJiBkYXRhLmlzU2Nyb2xsaW5nKSB7XG4gICAgICBzd2lwZXIuZW1pdCgndG91Y2hNb3ZlT3Bwb3NpdGUnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhZ2VYID0gdGFyZ2V0VG91Y2gucGFnZVg7XG4gIGNvbnN0IHBhZ2VZID0gdGFyZ2V0VG91Y2gucGFnZVk7XG4gIGlmIChlLnByZXZlbnRlZEJ5TmVzdGVkU3dpcGVyKSB7XG4gICAgdG91Y2hlcy5zdGFydFggPSBwYWdlWDtcbiAgICB0b3VjaGVzLnN0YXJ0WSA9IHBhZ2VZO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXN3aXBlci5hbGxvd1RvdWNoTW92ZSkge1xuICAgIGlmICghZS50YXJnZXQubWF0Y2hlcyhkYXRhLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgICAgc3dpcGVyLmFsbG93Q2xpY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRhdGEuaXNUb3VjaGVkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRvdWNoZXMsIHtcbiAgICAgICAgc3RhcnRYOiBwYWdlWCxcbiAgICAgICAgc3RhcnRZOiBwYWdlWSxcbiAgICAgICAgY3VycmVudFg6IHBhZ2VYLFxuICAgICAgICBjdXJyZW50WTogcGFnZVlcbiAgICAgIH0pO1xuICAgICAgZGF0YS50b3VjaFN0YXJ0VGltZSA9IG5vdygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzICYmICFwYXJhbXMubG9vcCkge1xuICAgIGlmIChzd2lwZXIuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICAvLyBWZXJ0aWNhbFxuICAgICAgaWYgKHBhZ2VZIDwgdG91Y2hlcy5zdGFydFkgJiYgc3dpcGVyLnRyYW5zbGF0ZSA8PSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgfHwgcGFnZVkgPiB0b3VjaGVzLnN0YXJ0WSAmJiBzd2lwZXIudHJhbnNsYXRlID49IHN3aXBlci5taW5UcmFuc2xhdGUoKSkge1xuICAgICAgICBkYXRhLmlzVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFnZVggPCB0b3VjaGVzLnN0YXJ0WCAmJiBzd2lwZXIudHJhbnNsYXRlIDw9IHN3aXBlci5tYXhUcmFuc2xhdGUoKSB8fCBwYWdlWCA+IHRvdWNoZXMuc3RhcnRYICYmIHN3aXBlci50cmFuc2xhdGUgPj0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGUudGFyZ2V0Lm1hdGNoZXMoZGF0YS5mb2N1c2FibGVFbGVtZW50cykpIHtcbiAgICAgIGRhdGEuaXNNb3ZlZCA9IHRydWU7XG4gICAgICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3RvdWNoTW92ZScsIGUpO1xuICB9XG4gIHRvdWNoZXMucHJldmlvdXNYID0gdG91Y2hlcy5jdXJyZW50WDtcbiAgdG91Y2hlcy5wcmV2aW91c1kgPSB0b3VjaGVzLmN1cnJlbnRZO1xuICB0b3VjaGVzLmN1cnJlbnRYID0gcGFnZVg7XG4gIHRvdWNoZXMuY3VycmVudFkgPSBwYWdlWTtcbiAgY29uc3QgZGlmZlggPSB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5zdGFydFg7XG4gIGNvbnN0IGRpZmZZID0gdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMuc3RhcnRZO1xuICBpZiAoc3dpcGVyLnBhcmFtcy50aHJlc2hvbGQgJiYgTWF0aC5zcXJ0KGRpZmZYICoqIDIgKyBkaWZmWSAqKiAyKSA8IHN3aXBlci5wYXJhbXMudGhyZXNob2xkKSByZXR1cm47XG4gIGlmICh0eXBlb2YgZGF0YS5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgdG91Y2hBbmdsZTtcbiAgICBpZiAoc3dpcGVyLmlzSG9yaXpvbnRhbCgpICYmIHRvdWNoZXMuY3VycmVudFkgPT09IHRvdWNoZXMuc3RhcnRZIHx8IHN3aXBlci5pc1ZlcnRpY2FsKCkgJiYgdG91Y2hlcy5jdXJyZW50WCA9PT0gdG91Y2hlcy5zdGFydFgpIHtcbiAgICAgIGRhdGEuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkgPj0gMjUpIHtcbiAgICAgICAgdG91Y2hBbmdsZSA9IE1hdGguYXRhbjIoTWF0aC5hYnMoZGlmZlkpLCBNYXRoLmFicyhkaWZmWCkpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgZGF0YS5pc1Njcm9sbGluZyA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHRvdWNoQW5nbGUgPiBwYXJhbXMudG91Y2hBbmdsZSA6IDkwIC0gdG91Y2hBbmdsZSA+IHBhcmFtcy50b3VjaEFuZ2xlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YS5pc1Njcm9sbGluZykge1xuICAgIHN3aXBlci5lbWl0KCd0b3VjaE1vdmVPcHBvc2l0ZScsIGUpO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YS5zdGFydE1vdmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodG91Y2hlcy5jdXJyZW50WCAhPT0gdG91Y2hlcy5zdGFydFggfHwgdG91Y2hlcy5jdXJyZW50WSAhPT0gdG91Y2hlcy5zdGFydFkpIHtcbiAgICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoZGF0YS5pc1Njcm9sbGluZykge1xuICAgIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZGF0YS5zdGFydE1vdmluZykge1xuICAgIHJldHVybjtcbiAgfVxuICBzd2lwZXIuYWxsb3dDbGljayA9IGZhbHNlO1xuICBpZiAoIXBhcmFtcy5jc3NNb2RlICYmIGUuY2FuY2VsYWJsZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBpZiAocGFyYW1zLnRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiAmJiAhcGFyYW1zLm5lc3RlZCkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgbGV0IGRpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyBkaWZmWCA6IGRpZmZZO1xuICBsZXQgdG91Y2hlc0RpZmYgPSBzd2lwZXIuaXNIb3Jpem9udGFsKCkgPyB0b3VjaGVzLmN1cnJlbnRYIC0gdG91Y2hlcy5wcmV2aW91c1ggOiB0b3VjaGVzLmN1cnJlbnRZIC0gdG91Y2hlcy5wcmV2aW91c1k7XG4gIGlmIChwYXJhbXMub25lV2F5TW92ZW1lbnQpIHtcbiAgICBkaWZmID0gTWF0aC5hYnMoZGlmZikgKiAocnRsID8gMSA6IC0xKTtcbiAgICB0b3VjaGVzRGlmZiA9IE1hdGguYWJzKHRvdWNoZXNEaWZmKSAqIChydGwgPyAxIDogLTEpO1xuICB9XG4gIHRvdWNoZXMuZGlmZiA9IGRpZmY7XG4gIGRpZmYgKj0gcGFyYW1zLnRvdWNoUmF0aW87XG4gIGlmIChydGwpIHtcbiAgICBkaWZmID0gLWRpZmY7XG4gICAgdG91Y2hlc0RpZmYgPSAtdG91Y2hlc0RpZmY7XG4gIH1cbiAgY29uc3QgcHJldlRvdWNoZXNEaXJlY3Rpb24gPSBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbjtcbiAgc3dpcGVyLnN3aXBlRGlyZWN0aW9uID0gZGlmZiA+IDAgPyAncHJldicgOiAnbmV4dCc7XG4gIHN3aXBlci50b3VjaGVzRGlyZWN0aW9uID0gdG91Y2hlc0RpZmYgPiAwID8gJ3ByZXYnIDogJ25leHQnO1xuICBjb25zdCBpc0xvb3AgPSBzd2lwZXIucGFyYW1zLmxvb3AgJiYgIXBhcmFtcy5jc3NNb2RlO1xuICBjb25zdCBhbGxvd0xvb3BGaXggPSBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbiA9PT0gJ25leHQnICYmIHN3aXBlci5hbGxvd1NsaWRlTmV4dCB8fCBzd2lwZXIudG91Y2hlc0RpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIHN3aXBlci5hbGxvd1NsaWRlUHJldjtcbiAgaWYgKCFkYXRhLmlzTW92ZWQpIHtcbiAgICBpZiAoaXNMb29wICYmIGFsbG93TG9vcEZpeCkge1xuICAgICAgc3dpcGVyLmxvb3BGaXgoe1xuICAgICAgICBkaXJlY3Rpb246IHN3aXBlci5zd2lwZURpcmVjdGlvblxuICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGEuc3RhcnRUcmFuc2xhdGUgPSBzd2lwZXIuZ2V0VHJhbnNsYXRlKCk7XG4gICAgc3dpcGVyLnNldFRyYW5zaXRpb24oMCk7XG4gICAgaWYgKHN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgIGNvbnN0IGV2dCA9IG5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoJ3RyYW5zaXRpb25lbmQnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgc3dpcGVyLndyYXBwZXJFbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gICAgfVxuICAgIGRhdGEuYWxsb3dNb21lbnR1bUJvdW5jZSA9IGZhbHNlO1xuICAgIC8vIEdyYWIgQ3Vyc29yXG4gICAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIChzd2lwZXIuYWxsb3dTbGlkZU5leHQgPT09IHRydWUgfHwgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSkge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IodHJ1ZSk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdzbGlkZXJGaXJzdE1vdmUnLCBlKTtcbiAgfVxuICBsZXQgbG9vcEZpeGVkO1xuICBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgaWYgKGRhdGEuaXNNb3ZlZCAmJiBkYXRhLmFsbG93VGhyZXNob2xkTW92ZSAmJiBwcmV2VG91Y2hlc0RpcmVjdGlvbiAhPT0gc3dpcGVyLnRvdWNoZXNEaXJlY3Rpb24gJiYgaXNMb29wICYmIGFsbG93TG9vcEZpeCAmJiBNYXRoLmFicyhkaWZmKSA+PSAxKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0b3VjaGVzLCB7XG4gICAgICBzdGFydFg6IHBhZ2VYLFxuICAgICAgc3RhcnRZOiBwYWdlWSxcbiAgICAgIGN1cnJlbnRYOiBwYWdlWCxcbiAgICAgIGN1cnJlbnRZOiBwYWdlWSxcbiAgICAgIHN0YXJ0VHJhbnNsYXRlOiBkYXRhLmN1cnJlbnRUcmFuc2xhdGVcbiAgICB9KTtcbiAgICBkYXRhLmxvb3BTd2FwUmVzZXQgPSB0cnVlO1xuICAgIGRhdGEuc3RhcnRUcmFuc2xhdGUgPSBkYXRhLmN1cnJlbnRUcmFuc2xhdGU7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzbGlkZXJNb3ZlJywgZSk7XG4gIGRhdGEuaXNNb3ZlZCA9IHRydWU7XG4gIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRpZmYgKyBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICBsZXQgZGlzYWJsZVBhcmVudFN3aXBlciA9IHRydWU7XG4gIGxldCByZXNpc3RhbmNlUmF0aW8gPSBwYXJhbXMucmVzaXN0YW5jZVJhdGlvO1xuICBpZiAocGFyYW1zLnRvdWNoUmVsZWFzZU9uRWRnZXMpIHtcbiAgICByZXNpc3RhbmNlUmF0aW8gPSAwO1xuICB9XG4gIGlmIChkaWZmID4gMCkge1xuICAgIGlmIChpc0xvb3AgJiYgYWxsb3dMb29wRml4ICYmICFsb29wRml4ZWQgJiYgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgJiYgZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gKHBhcmFtcy5jZW50ZXJlZFNsaWRlcyA/IHN3aXBlci5taW5UcmFuc2xhdGUoKSAtIHN3aXBlci5zbGlkZXNTaXplc0dyaWRbc3dpcGVyLmFjdGl2ZUluZGV4ICsgMV0gOiBzd2lwZXIubWluVHJhbnNsYXRlKCkpKSB7XG4gICAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICAgIGRpcmVjdGlvbjogJ3ByZXYnLFxuICAgICAgICBzZXRUcmFuc2xhdGU6IHRydWUsXG4gICAgICAgIGFjdGl2ZVNsaWRlSW5kZXg6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jdXJyZW50VHJhbnNsYXRlID4gc3dpcGVyLm1pblRyYW5zbGF0ZSgpKSB7XG4gICAgICBkaXNhYmxlUGFyZW50U3dpcGVyID0gZmFsc2U7XG4gICAgICBpZiAocGFyYW1zLnJlc2lzdGFuY2UpIHtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpIC0gMSArICgtc3dpcGVyLm1pblRyYW5zbGF0ZSgpICsgZGF0YS5zdGFydFRyYW5zbGF0ZSArIGRpZmYpICoqIHJlc2lzdGFuY2VSYXRpbztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICBpZiAoaXNMb29wICYmIGFsbG93TG9vcEZpeCAmJiAhbG9vcEZpeGVkICYmIGRhdGEuYWxsb3dUaHJlc2hvbGRNb3ZlICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IChwYXJhbXMuY2VudGVyZWRTbGlkZXMgPyBzd2lwZXIubWF4VHJhbnNsYXRlKCkgKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW3N3aXBlci5zbGlkZXNTaXplc0dyaWQubGVuZ3RoIC0gMV0gOiBzd2lwZXIubWF4VHJhbnNsYXRlKCkpKSB7XG4gICAgICBzd2lwZXIubG9vcEZpeCh7XG4gICAgICAgIGRpcmVjdGlvbjogJ25leHQnLFxuICAgICAgICBzZXRUcmFuc2xhdGU6IHRydWUsXG4gICAgICAgIGFjdGl2ZVNsaWRlSW5kZXg6IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgPyBzd2lwZXIuc2xpZGVzUGVyVmlld0R5bmFtaWMoKSA6IE1hdGguY2VpbChwYXJzZUZsb2F0KHBhcmFtcy5zbGlkZXNQZXJWaWV3LCAxMCkpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPCBzd2lwZXIubWF4VHJhbnNsYXRlKCkpIHtcbiAgICAgIGRpc2FibGVQYXJlbnRTd2lwZXIgPSBmYWxzZTtcbiAgICAgIGlmIChwYXJhbXMucmVzaXN0YW5jZSkge1xuICAgICAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBzd2lwZXIubWF4VHJhbnNsYXRlKCkgKyAxIC0gKHN3aXBlci5tYXhUcmFuc2xhdGUoKSAtIGRhdGEuc3RhcnRUcmFuc2xhdGUgLSBkaWZmKSAqKiByZXNpc3RhbmNlUmF0aW87XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkaXNhYmxlUGFyZW50U3dpcGVyKSB7XG4gICAgZS5wcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciA9IHRydWU7XG4gIH1cblxuICAvLyBEaXJlY3Rpb25zIGxvY2tzXG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVOZXh0ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA8IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmIHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ3ByZXYnICYmIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA+IGRhdGEuc3RhcnRUcmFuc2xhdGUpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG4gIGlmICghc3dpcGVyLmFsbG93U2xpZGVQcmV2ICYmICFzd2lwZXIuYWxsb3dTbGlkZU5leHQpIHtcbiAgICBkYXRhLmN1cnJlbnRUcmFuc2xhdGUgPSBkYXRhLnN0YXJ0VHJhbnNsYXRlO1xuICB9XG5cbiAgLy8gVGhyZXNob2xkXG4gIGlmIChwYXJhbXMudGhyZXNob2xkID4gMCkge1xuICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IHBhcmFtcy50aHJlc2hvbGQgfHwgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcbiAgICAgIGlmICghZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUpIHtcbiAgICAgICAgZGF0YS5hbGxvd1RocmVzaG9sZE1vdmUgPSB0cnVlO1xuICAgICAgICB0b3VjaGVzLnN0YXJ0WCA9IHRvdWNoZXMuY3VycmVudFg7XG4gICAgICAgIHRvdWNoZXMuc3RhcnRZID0gdG91Y2hlcy5jdXJyZW50WTtcbiAgICAgICAgZGF0YS5jdXJyZW50VHJhbnNsYXRlID0gZGF0YS5zdGFydFRyYW5zbGF0ZTtcbiAgICAgICAgdG91Y2hlcy5kaWZmID0gc3dpcGVyLmlzSG9yaXpvbnRhbCgpID8gdG91Y2hlcy5jdXJyZW50WCAtIHRvdWNoZXMuc3RhcnRYIDogdG91Y2hlcy5jdXJyZW50WSAtIHRvdWNoZXMuc3RhcnRZO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9IGRhdGEuc3RhcnRUcmFuc2xhdGU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmICghcGFyYW1zLmZvbGxvd0ZpbmdlciB8fCBwYXJhbXMuY3NzTW9kZSkgcmV0dXJuO1xuXG4gIC8vIFVwZGF0ZSBhY3RpdmUgaW5kZXggaW4gZnJlZSBtb2RlXG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgc3dpcGVyLmZyZWVNb2RlIHx8IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzKSB7XG4gICAgc3dpcGVyLnVwZGF0ZUFjdGl2ZUluZGV4KCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgfVxuICBpZiAocGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkICYmIHN3aXBlci5mcmVlTW9kZSkge1xuICAgIHN3aXBlci5mcmVlTW9kZS5vblRvdWNoTW92ZSgpO1xuICB9XG4gIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICBzd2lwZXIudXBkYXRlUHJvZ3Jlc3MoZGF0YS5jdXJyZW50VHJhbnNsYXRlKTtcbiAgLy8gVXBkYXRlIHRyYW5zbGF0ZVxuICBzd2lwZXIuc2V0VHJhbnNsYXRlKGRhdGEuY3VycmVudFRyYW5zbGF0ZSk7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3QgZGF0YSA9IHN3aXBlci50b3VjaEV2ZW50c0RhdGE7XG4gIGxldCBlID0gZXZlbnQ7XG4gIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gIGxldCB0YXJnZXRUb3VjaDtcbiAgY29uc3QgaXNUb3VjaEV2ZW50ID0gZS50eXBlID09PSAndG91Y2hlbmQnIHx8IGUudHlwZSA9PT0gJ3RvdWNoY2FuY2VsJztcbiAgaWYgKCFpc1RvdWNoRXZlbnQpIHtcbiAgICBpZiAoZGF0YS50b3VjaElkICE9PSBudWxsKSByZXR1cm47IC8vIHJldHVybiBmcm9tIHBvaW50ZXIgaWYgd2UgdXNlIHRvdWNoXG4gICAgaWYgKGUucG9pbnRlcklkICE9PSBkYXRhLnBvaW50ZXJJZCkgcmV0dXJuO1xuICAgIHRhcmdldFRvdWNoID0gZTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXRUb3VjaCA9IFsuLi5lLmNoYW5nZWRUb3VjaGVzXS5maWx0ZXIodCA9PiB0LmlkZW50aWZpZXIgPT09IGRhdGEudG91Y2hJZClbMF07XG4gICAgaWYgKCF0YXJnZXRUb3VjaCB8fCB0YXJnZXRUb3VjaC5pZGVudGlmaWVyICE9PSBkYXRhLnRvdWNoSWQpIHJldHVybjtcbiAgfVxuICBpZiAoWydwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJvdXQnLCAncG9pbnRlcmxlYXZlJywgJ2NvbnRleHRtZW51J10uaW5jbHVkZXMoZS50eXBlKSkge1xuICAgIGNvbnN0IHByb2NlZWQgPSBbJ3BvaW50ZXJjYW5jZWwnLCAnY29udGV4dG1lbnUnXS5pbmNsdWRlcyhlLnR5cGUpICYmIChzd2lwZXIuYnJvd3Nlci5pc1NhZmFyaSB8fCBzd2lwZXIuYnJvd3Nlci5pc1dlYlZpZXcpO1xuICAgIGlmICghcHJvY2VlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBkYXRhLnBvaW50ZXJJZCA9IG51bGw7XG4gIGRhdGEudG91Y2hJZCA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgdG91Y2hlcyxcbiAgICBydGxUcmFuc2xhdGU6IHJ0bCxcbiAgICBzbGlkZXNHcmlkLFxuICAgIGVuYWJsZWRcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gIGlmICghcGFyYW1zLnNpbXVsYXRlVG91Y2ggJiYgZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykgcmV0dXJuO1xuICBpZiAoZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzKSB7XG4gICAgc3dpcGVyLmVtaXQoJ3RvdWNoRW5kJywgZSk7XG4gIH1cbiAgZGF0YS5hbGxvd1RvdWNoQ2FsbGJhY2tzID0gZmFsc2U7XG4gIGlmICghZGF0YS5pc1RvdWNoZWQpIHtcbiAgICBpZiAoZGF0YS5pc01vdmVkICYmIHBhcmFtcy5ncmFiQ3Vyc29yKSB7XG4gICAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcihmYWxzZSk7XG4gICAgfVxuICAgIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICAgIGRhdGEuc3RhcnRNb3ZpbmcgPSBmYWxzZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZXR1cm4gR3JhYiBDdXJzb3JcbiAgaWYgKHBhcmFtcy5ncmFiQ3Vyc29yICYmIGRhdGEuaXNNb3ZlZCAmJiBkYXRhLmlzVG91Y2hlZCAmJiAoc3dpcGVyLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlIHx8IHN3aXBlci5hbGxvd1NsaWRlUHJldiA9PT0gdHJ1ZSkpIHtcbiAgICBzd2lwZXIuc2V0R3JhYkN1cnNvcihmYWxzZSk7XG4gIH1cblxuICAvLyBUaW1lIGRpZmZcbiAgY29uc3QgdG91Y2hFbmRUaW1lID0gbm93KCk7XG4gIGNvbnN0IHRpbWVEaWZmID0gdG91Y2hFbmRUaW1lIC0gZGF0YS50b3VjaFN0YXJ0VGltZTtcblxuICAvLyBUYXAsIGRvdWJsZVRhcCwgQ2xpY2tcbiAgaWYgKHN3aXBlci5hbGxvd0NsaWNrKSB7XG4gICAgY29uc3QgcGF0aFRyZWUgPSBlLnBhdGggfHwgZS5jb21wb3NlZFBhdGggJiYgZS5jb21wb3NlZFBhdGgoKTtcbiAgICBzd2lwZXIudXBkYXRlQ2xpY2tlZFNsaWRlKHBhdGhUcmVlICYmIHBhdGhUcmVlWzBdIHx8IGUudGFyZ2V0LCBwYXRoVHJlZSk7XG4gICAgc3dpcGVyLmVtaXQoJ3RhcCBjbGljaycsIGUpO1xuICAgIGlmICh0aW1lRGlmZiA8IDMwMCAmJiB0b3VjaEVuZFRpbWUgLSBkYXRhLmxhc3RDbGlja1RpbWUgPCAzMDApIHtcbiAgICAgIHN3aXBlci5lbWl0KCdkb3VibGVUYXAgZG91YmxlQ2xpY2snLCBlKTtcbiAgICB9XG4gIH1cbiAgZGF0YS5sYXN0Q2xpY2tUaW1lID0gbm93KCk7XG4gIG5leHRUaWNrKCgpID0+IHtcbiAgICBpZiAoIXN3aXBlci5kZXN0cm95ZWQpIHN3aXBlci5hbGxvd0NsaWNrID0gdHJ1ZTtcbiAgfSk7XG4gIGlmICghZGF0YS5pc1RvdWNoZWQgfHwgIWRhdGEuaXNNb3ZlZCB8fCAhc3dpcGVyLnN3aXBlRGlyZWN0aW9uIHx8IHRvdWNoZXMuZGlmZiA9PT0gMCAmJiAhZGF0YS5sb29wU3dhcFJlc2V0IHx8IGRhdGEuY3VycmVudFRyYW5zbGF0ZSA9PT0gZGF0YS5zdGFydFRyYW5zbGF0ZSAmJiAhZGF0YS5sb29wU3dhcFJlc2V0KSB7XG4gICAgZGF0YS5pc1RvdWNoZWQgPSBmYWxzZTtcbiAgICBkYXRhLmlzTW92ZWQgPSBmYWxzZTtcbiAgICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRhdGEuaXNUb3VjaGVkID0gZmFsc2U7XG4gIGRhdGEuaXNNb3ZlZCA9IGZhbHNlO1xuICBkYXRhLnN0YXJ0TW92aW5nID0gZmFsc2U7XG4gIGxldCBjdXJyZW50UG9zO1xuICBpZiAocGFyYW1zLmZvbGxvd0Zpbmdlcikge1xuICAgIGN1cnJlbnRQb3MgPSBydGwgPyBzd2lwZXIudHJhbnNsYXRlIDogLXN3aXBlci50cmFuc2xhdGU7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudFBvcyA9IC1kYXRhLmN1cnJlbnRUcmFuc2xhdGU7XG4gIH1cbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQpIHtcbiAgICBzd2lwZXIuZnJlZU1vZGUub25Ub3VjaEVuZCh7XG4gICAgICBjdXJyZW50UG9zXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmluZCBjdXJyZW50IHNsaWRlXG4gIGNvbnN0IHN3aXBlVG9MYXN0ID0gY3VycmVudFBvcyA+PSAtc3dpcGVyLm1heFRyYW5zbGF0ZSgpICYmICFzd2lwZXIucGFyYW1zLmxvb3A7XG4gIGxldCBzdG9wSW5kZXggPSAwO1xuICBsZXQgZ3JvdXBTaXplID0gc3dpcGVyLnNsaWRlc1NpemVzR3JpZFswXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZXNHcmlkLmxlbmd0aDsgaSArPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCA/IDEgOiBwYXJhbXMuc2xpZGVzUGVyR3JvdXApIHtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBpIDwgcGFyYW1zLnNsaWRlc1Blckdyb3VwU2tpcCAtIDEgPyAxIDogcGFyYW1zLnNsaWRlc1Blckdyb3VwO1xuICAgIGlmICh0eXBlb2Ygc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChzd2lwZVRvTGFzdCB8fCBjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0gJiYgY3VycmVudFBvcyA8IHNsaWRlc0dyaWRbaSArIGluY3JlbWVudF0pIHtcbiAgICAgICAgc3RvcEluZGV4ID0gaTtcbiAgICAgICAgZ3JvdXBTaXplID0gc2xpZGVzR3JpZFtpICsgaW5jcmVtZW50XSAtIHNsaWRlc0dyaWRbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzd2lwZVRvTGFzdCB8fCBjdXJyZW50UG9zID49IHNsaWRlc0dyaWRbaV0pIHtcbiAgICAgIHN0b3BJbmRleCA9IGk7XG4gICAgICBncm91cFNpemUgPSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMV0gLSBzbGlkZXNHcmlkW3NsaWRlc0dyaWQubGVuZ3RoIC0gMl07XG4gICAgfVxuICB9XG4gIGxldCByZXdpbmRGaXJzdEluZGV4ID0gbnVsbDtcbiAgbGV0IHJld2luZExhc3RJbmRleCA9IG51bGw7XG4gIGlmIChwYXJhbXMucmV3aW5kKSB7XG4gICAgaWYgKHN3aXBlci5pc0JlZ2lubmluZykge1xuICAgICAgcmV3aW5kTGFzdEluZGV4ID0gcGFyYW1zLnZpcnR1YWwgJiYgcGFyYW1zLnZpcnR1YWwuZW5hYmxlZCAmJiBzd2lwZXIudmlydHVhbCA/IHN3aXBlci52aXJ0dWFsLnNsaWRlcy5sZW5ndGggLSAxIDogc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxO1xuICAgIH0gZWxzZSBpZiAoc3dpcGVyLmlzRW5kKSB7XG4gICAgICByZXdpbmRGaXJzdEluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCBjdXJyZW50IHNsaWRlIHNpemVcbiAgY29uc3QgcmF0aW8gPSAoY3VycmVudFBvcyAtIHNsaWRlc0dyaWRbc3RvcEluZGV4XSkgLyBncm91cFNpemU7XG4gIGNvbnN0IGluY3JlbWVudCA9IHN0b3BJbmRleCA8IHBhcmFtcy5zbGlkZXNQZXJHcm91cFNraXAgLSAxID8gMSA6IHBhcmFtcy5zbGlkZXNQZXJHcm91cDtcbiAgaWYgKHRpbWVEaWZmID4gcGFyYW1zLmxvbmdTd2lwZXNNcykge1xuICAgIC8vIExvbmcgdG91Y2hlc1xuICAgIGlmICghcGFyYW1zLmxvbmdTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgaWYgKHJhdGlvID49IHBhcmFtcy5sb25nU3dpcGVzUmF0aW8pIHN3aXBlci5zbGlkZVRvKHBhcmFtcy5yZXdpbmQgJiYgc3dpcGVyLmlzRW5kID8gcmV3aW5kRmlyc3RJbmRleCA6IHN0b3BJbmRleCArIGluY3JlbWVudCk7ZWxzZSBzd2lwZXIuc2xpZGVUbyhzdG9wSW5kZXgpO1xuICAgIH1cbiAgICBpZiAoc3dpcGVyLnN3aXBlRGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICAgIGlmIChyYXRpbyA+IDEgLSBwYXJhbXMubG9uZ1N3aXBlc1JhdGlvKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHN0b3BJbmRleCArIGluY3JlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHJld2luZExhc3RJbmRleCAhPT0gbnVsbCAmJiByYXRpbyA8IDAgJiYgTWF0aC5hYnMocmF0aW8pID4gcGFyYW1zLmxvbmdTd2lwZXNSYXRpbykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhyZXdpbmRMYXN0SW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2hvcnQgc3dpcGVzXG4gICAgaWYgKCFwYXJhbXMuc2hvcnRTd2lwZXMpIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5hY3RpdmVJbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTmF2QnV0dG9uVGFyZ2V0ID0gc3dpcGVyLm5hdmlnYXRpb24gJiYgKGUudGFyZ2V0ID09PSBzd2lwZXIubmF2aWdhdGlvbi5uZXh0RWwgfHwgZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLnByZXZFbCk7XG4gICAgaWYgKCFpc05hdkJ1dHRvblRhcmdldCkge1xuICAgICAgaWYgKHN3aXBlci5zd2lwZURpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgICAgIHN3aXBlci5zbGlkZVRvKHJld2luZEZpcnN0SW5kZXggIT09IG51bGwgPyByZXdpbmRGaXJzdEluZGV4IDogc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChzd2lwZXIuc3dpcGVEaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgICBzd2lwZXIuc2xpZGVUbyhyZXdpbmRMYXN0SW5kZXggIT09IG51bGwgPyByZXdpbmRMYXN0SW5kZXggOiBzdG9wSW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IHN3aXBlci5uYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4ICsgaW5jcmVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3RvcEluZGV4KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgZWxcbiAgfSA9IHN3aXBlcjtcbiAgaWYgKGVsICYmIGVsLm9mZnNldFdpZHRoID09PSAwKSByZXR1cm47XG5cbiAgLy8gQnJlYWtwb2ludHNcbiAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgIHN3aXBlci5zZXRCcmVha3BvaW50KCk7XG4gIH1cblxuICAvLyBTYXZlIGxvY2tzXG4gIGNvbnN0IHtcbiAgICBhbGxvd1NsaWRlTmV4dCxcbiAgICBhbGxvd1NsaWRlUHJldixcbiAgICBzbmFwR3JpZFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBpc1ZpcnR1YWwgPSBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZDtcblxuICAvLyBEaXNhYmxlIGxvY2tzIG9uIHJlc2l6ZVxuICBzd2lwZXIuYWxsb3dTbGlkZU5leHQgPSB0cnVlO1xuICBzd2lwZXIuYWxsb3dTbGlkZVByZXYgPSB0cnVlO1xuICBzd2lwZXIudXBkYXRlU2l6ZSgpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIGNvbnN0IGlzVmlydHVhbExvb3AgPSBpc1ZpcnR1YWwgJiYgcGFyYW1zLmxvb3A7XG4gIGlmICgocGFyYW1zLnNsaWRlc1BlclZpZXcgPT09ICdhdXRvJyB8fCBwYXJhbXMuc2xpZGVzUGVyVmlldyA+IDEpICYmIHN3aXBlci5pc0VuZCAmJiAhc3dpcGVyLmlzQmVnaW5uaW5nICYmICFzd2lwZXIucGFyYW1zLmNlbnRlcmVkU2xpZGVzICYmICFpc1ZpcnR1YWxMb29wKSB7XG4gICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCAmJiAhaXNWaXJ0dWFsKSB7XG4gICAgICBzd2lwZXIuc2xpZGVUb0xvb3Aoc3dpcGVyLnJlYWxJbmRleCwgMCwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2lwZXIuc2xpZGVUbyhzd2lwZXIuYWN0aXZlSW5kZXgsIDAsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN3aXBlci5hdXRvcGxheSAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZyAmJiBzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN3aXBlci5hdXRvcGxheS5yZXNpemVUaW1lb3V0KTtcbiAgICBzd2lwZXIuYXV0b3BsYXkucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHN3aXBlci5hdXRvcGxheSAmJiBzd2lwZXIuYXV0b3BsYXkucnVubmluZyAmJiBzd2lwZXIuYXV0b3BsYXkucGF1c2VkKSB7XG4gICAgICAgIHN3aXBlci5hdXRvcGxheS5yZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9LCA1MDApO1xuICB9XG4gIC8vIFJldHVybiBsb2NrcyBhZnRlciByZXNpemVcbiAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gYWxsb3dTbGlkZVByZXY7XG4gIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IGFsbG93U2xpZGVOZXh0O1xuICBpZiAoc3dpcGVyLnBhcmFtcy53YXRjaE92ZXJmbG93ICYmIHNuYXBHcmlkICE9PSBzd2lwZXIuc25hcEdyaWQpIHtcbiAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBpZiAoIXN3aXBlci5lbmFibGVkKSByZXR1cm47XG4gIGlmICghc3dpcGVyLmFsbG93Q2xpY2spIHtcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5wcmV2ZW50Q2xpY2tzKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uICYmIHN3aXBlci5hbmltYXRpbmcpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblNjcm9sbCgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgY29uc3Qge1xuICAgIHdyYXBwZXJFbCxcbiAgICBydGxUcmFuc2xhdGUsXG4gICAgZW5hYmxlZFxuICB9ID0gc3dpcGVyO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgc3dpcGVyLnByZXZpb3VzVHJhbnNsYXRlID0gc3dpcGVyLnRyYW5zbGF0ZTtcbiAgaWYgKHN3aXBlci5pc0hvcml6b250YWwoKSkge1xuICAgIHN3aXBlci50cmFuc2xhdGUgPSAtd3JhcHBlckVsLnNjcm9sbExlZnQ7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLnRyYW5zbGF0ZSA9IC13cmFwcGVyRWwuc2Nyb2xsVG9wO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAoc3dpcGVyLnRyYW5zbGF0ZSA9PT0gMCkgc3dpcGVyLnRyYW5zbGF0ZSA9IDA7XG4gIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBsZXQgbmV3UHJvZ3Jlc3M7XG4gIGNvbnN0IHRyYW5zbGF0ZXNEaWZmID0gc3dpcGVyLm1heFRyYW5zbGF0ZSgpIC0gc3dpcGVyLm1pblRyYW5zbGF0ZSgpO1xuICBpZiAodHJhbnNsYXRlc0RpZmYgPT09IDApIHtcbiAgICBuZXdQcm9ncmVzcyA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbmV3UHJvZ3Jlc3MgPSAoc3dpcGVyLnRyYW5zbGF0ZSAtIHN3aXBlci5taW5UcmFuc2xhdGUoKSkgLyB0cmFuc2xhdGVzRGlmZjtcbiAgfVxuICBpZiAobmV3UHJvZ3Jlc3MgIT09IHN3aXBlci5wcm9ncmVzcykge1xuICAgIHN3aXBlci51cGRhdGVQcm9ncmVzcyhydGxUcmFuc2xhdGUgPyAtc3dpcGVyLnRyYW5zbGF0ZSA6IHN3aXBlci50cmFuc2xhdGUpO1xuICB9XG4gIHN3aXBlci5lbWl0KCdzZXRUcmFuc2xhdGUnLCBzd2lwZXIudHJhbnNsYXRlLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIG9uTG9hZChlKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIHByb2Nlc3NMYXp5UHJlbG9hZGVyKHN3aXBlciwgZS50YXJnZXQpO1xuICBpZiAoc3dpcGVyLnBhcmFtcy5jc3NNb2RlIHx8IHN3aXBlci5wYXJhbXMuc2xpZGVzUGVyVmlldyAhPT0gJ2F1dG8nICYmICFzd2lwZXIucGFyYW1zLmF1dG9IZWlnaHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc3dpcGVyLnVwZGF0ZSgpO1xufVxuXG5mdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hTdGFydCgpIHtcbiAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgaWYgKHN3aXBlci5kb2N1bWVudFRvdWNoSGFuZGxlclByb2NlZWRlZCkgcmV0dXJuO1xuICBzd2lwZXIuZG9jdW1lbnRUb3VjaEhhbmRsZXJQcm9jZWVkZWQgPSB0cnVlO1xuICBpZiAoc3dpcGVyLnBhcmFtcy50b3VjaFJlbGVhc2VPbkVkZ2VzKSB7XG4gICAgc3dpcGVyLmVsLnN0eWxlLnRvdWNoQWN0aW9uID0gJ2F1dG8nO1xuICB9XG59XG5cbmNvbnN0IGV2ZW50cyA9IChzd2lwZXIsIG1ldGhvZCkgPT4ge1xuICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXMsXG4gICAgZWwsXG4gICAgd3JhcHBlckVsLFxuICAgIGRldmljZVxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBjYXB0dXJlID0gISFwYXJhbXMubmVzdGVkO1xuICBjb25zdCBkb21NZXRob2QgPSBtZXRob2QgPT09ICdvbicgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIGNvbnN0IHN3aXBlck1ldGhvZCA9IG1ldGhvZDtcblxuICAvLyBUb3VjaCBFdmVudHNcbiAgZG9jdW1lbnRbZG9tTWV0aG9kXSgndG91Y2hzdGFydCcsIHN3aXBlci5vbkRvY3VtZW50VG91Y2hTdGFydCwge1xuICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgIGNhcHR1cmVcbiAgfSk7XG4gIGVsW2RvbU1ldGhvZF0oJ3RvdWNoc3RhcnQnLCBzd2lwZXIub25Ub3VjaFN0YXJ0LCB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSk7XG4gIGVsW2RvbU1ldGhvZF0oJ3BvaW50ZXJkb3duJywgc3dpcGVyLm9uVG91Y2hTdGFydCwge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCd0b3VjaG1vdmUnLCBzd2lwZXIub25Ub3VjaE1vdmUsIHtcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICBjYXB0dXJlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdwb2ludGVybW92ZScsIHN3aXBlci5vblRvdWNoTW92ZSwge1xuICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgIGNhcHR1cmVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3RvdWNoZW5kJywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdwb2ludGVydXAnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3BvaW50ZXJjYW5jZWwnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ3RvdWNoY2FuY2VsJywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdwb2ludGVyb3V0Jywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuICBkb2N1bWVudFtkb21NZXRob2RdKCdwb2ludGVybGVhdmUnLCBzd2lwZXIub25Ub3VjaEVuZCwge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSk7XG4gIGRvY3VtZW50W2RvbU1ldGhvZF0oJ2NvbnRleHRtZW51Jywgc3dpcGVyLm9uVG91Y2hFbmQsIHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH0pO1xuXG4gIC8vIFByZXZlbnQgTGlua3MgQ2xpY2tzXG4gIGlmIChwYXJhbXMucHJldmVudENsaWNrcyB8fCBwYXJhbXMucHJldmVudENsaWNrc1Byb3BhZ2F0aW9uKSB7XG4gICAgZWxbZG9tTWV0aG9kXSgnY2xpY2snLCBzd2lwZXIub25DbGljaywgdHJ1ZSk7XG4gIH1cbiAgaWYgKHBhcmFtcy5jc3NNb2RlKSB7XG4gICAgd3JhcHBlckVsW2RvbU1ldGhvZF0oJ3Njcm9sbCcsIHN3aXBlci5vblNjcm9sbCk7XG4gIH1cblxuICAvLyBSZXNpemUgaGFuZGxlclxuICBpZiAocGFyYW1zLnVwZGF0ZU9uV2luZG93UmVzaXplKSB7XG4gICAgc3dpcGVyW3N3aXBlck1ldGhvZF0oZGV2aWNlLmlvcyB8fCBkZXZpY2UuYW5kcm9pZCA/ICdyZXNpemUgb3JpZW50YXRpb25jaGFuZ2Ugb2JzZXJ2ZXJVcGRhdGUnIDogJ3Jlc2l6ZSBvYnNlcnZlclVwZGF0ZScsIG9uUmVzaXplLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzd2lwZXJbc3dpcGVyTWV0aG9kXSgnb2JzZXJ2ZXJVcGRhdGUnLCBvblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBJbWFnZXMgbG9hZGVyXG4gIGVsW2RvbU1ldGhvZF0oJ2xvYWQnLCBzd2lwZXIub25Mb2FkLCB7XG4gICAgY2FwdHVyZTogdHJ1ZVxuICB9KTtcbn07XG5mdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXNcbiAgfSA9IHN3aXBlcjtcbiAgc3dpcGVyLm9uVG91Y2hTdGFydCA9IG9uVG91Y2hTdGFydC5iaW5kKHN3aXBlcik7XG4gIHN3aXBlci5vblRvdWNoTW92ZSA9IG9uVG91Y2hNb3ZlLmJpbmQoc3dpcGVyKTtcbiAgc3dpcGVyLm9uVG91Y2hFbmQgPSBvblRvdWNoRW5kLmJpbmQoc3dpcGVyKTtcbiAgc3dpcGVyLm9uRG9jdW1lbnRUb3VjaFN0YXJ0ID0gb25Eb2N1bWVudFRvdWNoU3RhcnQuYmluZChzd2lwZXIpO1xuICBpZiAocGFyYW1zLmNzc01vZGUpIHtcbiAgICBzd2lwZXIub25TY3JvbGwgPSBvblNjcm9sbC5iaW5kKHN3aXBlcik7XG4gIH1cbiAgc3dpcGVyLm9uQ2xpY2sgPSBvbkNsaWNrLmJpbmQoc3dpcGVyKTtcbiAgc3dpcGVyLm9uTG9hZCA9IG9uTG9hZC5iaW5kKHN3aXBlcik7XG4gIGV2ZW50cyhzd2lwZXIsICdvbicpO1xufVxuZnVuY3Rpb24gZGV0YWNoRXZlbnRzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBldmVudHMoc3dpcGVyLCAnb2ZmJyk7XG59XG52YXIgZXZlbnRzJDEgPSB7XG4gIGF0dGFjaEV2ZW50cyxcbiAgZGV0YWNoRXZlbnRzXG59O1xuXG5jb25zdCBpc0dyaWRFbmFibGVkID0gKHN3aXBlciwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBzd2lwZXIuZ3JpZCAmJiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMTtcbn07XG5mdW5jdGlvbiBzZXRCcmVha3BvaW50KCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgcmVhbEluZGV4LFxuICAgIGluaXRpYWxpemVkLFxuICAgIHBhcmFtcyxcbiAgICBlbFxuICB9ID0gc3dpcGVyO1xuICBjb25zdCBicmVha3BvaW50cyA9IHBhcmFtcy5icmVha3BvaW50cztcbiAgaWYgKCFicmVha3BvaW50cyB8fCBicmVha3BvaW50cyAmJiBPYmplY3Qua2V5cyhicmVha3BvaW50cykubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgLy8gR2V0IGJyZWFrcG9pbnQgZm9yIHdpbmRvdyB3aWR0aCBhbmQgdXBkYXRlIHBhcmFtZXRlcnNcbiAgY29uc3QgYnJlYWtwb2ludCA9IHN3aXBlci5nZXRCcmVha3BvaW50KGJyZWFrcG9pbnRzLCBzd2lwZXIucGFyYW1zLmJyZWFrcG9pbnRzQmFzZSwgc3dpcGVyLmVsKTtcbiAgaWYgKCFicmVha3BvaW50IHx8IHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCA9PT0gYnJlYWtwb2ludCkgcmV0dXJuO1xuICBjb25zdCBicmVha3BvaW50T25seVBhcmFtcyA9IGJyZWFrcG9pbnQgaW4gYnJlYWtwb2ludHMgPyBicmVha3BvaW50c1ticmVha3BvaW50XSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgYnJlYWtwb2ludFBhcmFtcyA9IGJyZWFrcG9pbnRPbmx5UGFyYW1zIHx8IHN3aXBlci5vcmlnaW5hbFBhcmFtcztcbiAgY29uc3Qgd2FzTXVsdGlSb3cgPSBpc0dyaWRFbmFibGVkKHN3aXBlciwgcGFyYW1zKTtcbiAgY29uc3QgaXNNdWx0aVJvdyA9IGlzR3JpZEVuYWJsZWQoc3dpcGVyLCBicmVha3BvaW50UGFyYW1zKTtcbiAgY29uc3Qgd2FzRW5hYmxlZCA9IHBhcmFtcy5lbmFibGVkO1xuICBpZiAod2FzTXVsdGlSb3cgJiYgIWlzTXVsdGlSb3cpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGAke3BhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfWdyaWRgLCBgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkLWNvbHVtbmApO1xuICAgIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xuICB9IGVsc2UgaWYgKCF3YXNNdWx0aVJvdyAmJiBpc011bHRpUm93KSB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZChgJHtwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ncmlkYCk7XG4gICAgaWYgKGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsICYmIGJyZWFrcG9pbnRQYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJyB8fCAhYnJlYWtwb2ludFBhcmFtcy5ncmlkLmZpbGwgJiYgcGFyYW1zLmdyaWQuZmlsbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYCR7cGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9Z3JpZC1jb2x1bW5gKTtcbiAgICB9XG4gICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gIH1cblxuICAvLyBUb2dnbGUgbmF2aWdhdGlvbiwgcGFnaW5hdGlvbiwgc2Nyb2xsYmFyXG4gIFsnbmF2aWdhdGlvbicsICdwYWdpbmF0aW9uJywgJ3Njcm9sbGJhciddLmZvckVhY2gocHJvcCA9PiB7XG4gICAgaWYgKHR5cGVvZiBicmVha3BvaW50UGFyYW1zW3Byb3BdID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IHdhc01vZHVsZUVuYWJsZWQgPSBwYXJhbXNbcHJvcF0gJiYgcGFyYW1zW3Byb3BdLmVuYWJsZWQ7XG4gICAgY29uc3QgaXNNb2R1bGVFbmFibGVkID0gYnJlYWtwb2ludFBhcmFtc1twcm9wXSAmJiBicmVha3BvaW50UGFyYW1zW3Byb3BdLmVuYWJsZWQ7XG4gICAgaWYgKHdhc01vZHVsZUVuYWJsZWQgJiYgIWlzTW9kdWxlRW5hYmxlZCkge1xuICAgICAgc3dpcGVyW3Byb3BdLmRpc2FibGUoKTtcbiAgICB9XG4gICAgaWYgKCF3YXNNb2R1bGVFbmFibGVkICYmIGlzTW9kdWxlRW5hYmxlZCkge1xuICAgICAgc3dpcGVyW3Byb3BdLmVuYWJsZSgpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGRpcmVjdGlvbkNoYW5nZWQgPSBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAmJiBicmVha3BvaW50UGFyYW1zLmRpcmVjdGlvbiAhPT0gcGFyYW1zLmRpcmVjdGlvbjtcbiAgY29uc3QgbmVlZHNSZUxvb3AgPSBwYXJhbXMubG9vcCAmJiAoYnJlYWtwb2ludFBhcmFtcy5zbGlkZXNQZXJWaWV3ICE9PSBwYXJhbXMuc2xpZGVzUGVyVmlldyB8fCBkaXJlY3Rpb25DaGFuZ2VkKTtcbiAgY29uc3Qgd2FzTG9vcCA9IHBhcmFtcy5sb29wO1xuICBpZiAoZGlyZWN0aW9uQ2hhbmdlZCAmJiBpbml0aWFsaXplZCkge1xuICAgIHN3aXBlci5jaGFuZ2VEaXJlY3Rpb24oKTtcbiAgfVxuICBleHRlbmQoc3dpcGVyLnBhcmFtcywgYnJlYWtwb2ludFBhcmFtcyk7XG4gIGNvbnN0IGlzRW5hYmxlZCA9IHN3aXBlci5wYXJhbXMuZW5hYmxlZDtcbiAgY29uc3QgaGFzTG9vcCA9IHN3aXBlci5wYXJhbXMubG9vcDtcbiAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICBhbGxvd1RvdWNoTW92ZTogc3dpcGVyLnBhcmFtcy5hbGxvd1RvdWNoTW92ZSxcbiAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcbiAgICBhbGxvd1NsaWRlUHJldjogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlUHJldlxuICB9KTtcbiAgaWYgKHdhc0VuYWJsZWQgJiYgIWlzRW5hYmxlZCkge1xuICAgIHN3aXBlci5kaXNhYmxlKCk7XG4gIH0gZWxzZSBpZiAoIXdhc0VuYWJsZWQgJiYgaXNFbmFibGVkKSB7XG4gICAgc3dpcGVyLmVuYWJsZSgpO1xuICB9XG4gIHN3aXBlci5jdXJyZW50QnJlYWtwb2ludCA9IGJyZWFrcG9pbnQ7XG4gIHN3aXBlci5lbWl0KCdfYmVmb3JlQnJlYWtwb2ludCcsIGJyZWFrcG9pbnRQYXJhbXMpO1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICBpZiAobmVlZHNSZUxvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wRGVzdHJveSgpO1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUocmVhbEluZGV4KTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXMoKTtcbiAgICB9IGVsc2UgaWYgKCF3YXNMb29wICYmIGhhc0xvb3ApIHtcbiAgICAgIHN3aXBlci5sb29wQ3JlYXRlKHJlYWxJbmRleCk7XG4gICAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgfSBlbHNlIGlmICh3YXNMb29wICYmICFoYXNMb29wKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgc3dpcGVyLmVtaXQoJ2JyZWFrcG9pbnQnLCBicmVha3BvaW50UGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gZ2V0QnJlYWtwb2ludChicmVha3BvaW50cywgYmFzZSwgY29udGFpbmVyRWwpIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSAnd2luZG93JztcbiAgfVxuICBpZiAoIWJyZWFrcG9pbnRzIHx8IGJhc2UgPT09ICdjb250YWluZXInICYmICFjb250YWluZXJFbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgbGV0IGJyZWFrcG9pbnQgPSBmYWxzZTtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBiYXNlID09PSAnd2luZG93JyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IGNvbnRhaW5lckVsLmNsaWVudEhlaWdodDtcbiAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLm1hcChwb2ludCA9PiB7XG4gICAgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ3N0cmluZycgJiYgcG9pbnQuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICBjb25zdCBtaW5SYXRpbyA9IHBhcnNlRmxvYXQocG9pbnQuc3Vic3RyKDEpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudEhlaWdodCAqIG1pblJhdGlvO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHBvaW50LFxuICAgICAgcG9pbnRcbiAgICB9O1xuICB9KTtcbiAgcG9pbnRzLnNvcnQoKGEsIGIpID0+IHBhcnNlSW50KGEudmFsdWUsIDEwKSAtIHBhcnNlSW50KGIudmFsdWUsIDEwKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9pbnQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBwb2ludHNbaV07XG4gICAgaWYgKGJhc2UgPT09ICd3aW5kb3cnKSB7XG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoYChtaW4td2lkdGg6ICR7dmFsdWV9cHgpYCkubWF0Y2hlcykge1xuICAgICAgICBicmVha3BvaW50ID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA8PSBjb250YWluZXJFbC5jbGllbnRXaWR0aCkge1xuICAgICAgYnJlYWtwb2ludCA9IHBvaW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnJlYWtwb2ludCB8fCAnbWF4Jztcbn1cblxudmFyIGJyZWFrcG9pbnRzID0ge1xuICBzZXRCcmVha3BvaW50LFxuICBnZXRCcmVha3BvaW50XG59O1xuXG5mdW5jdGlvbiBwcmVwYXJlQ2xhc3NlcyhlbnRyaWVzLCBwcmVmaXgpIHtcbiAgY29uc3QgcmVzdWx0Q2xhc3NlcyA9IFtdO1xuICBlbnRyaWVzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMoaXRlbSkuZm9yRWFjaChjbGFzc05hbWVzID0+IHtcbiAgICAgICAgaWYgKGl0ZW1bY2xhc3NOYW1lc10pIHtcbiAgICAgICAgICByZXN1bHRDbGFzc2VzLnB1c2gocHJlZml4ICsgY2xhc3NOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXN1bHRDbGFzc2VzLnB1c2gocHJlZml4ICsgaXRlbSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdENsYXNzZXM7XG59XG5mdW5jdGlvbiBhZGRDbGFzc2VzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgY2xhc3NOYW1lcyxcbiAgICBwYXJhbXMsXG4gICAgcnRsLFxuICAgIGVsLFxuICAgIGRldmljZVxuICB9ID0gc3dpcGVyO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgY29uc3Qgc3VmZml4ZXMgPSBwcmVwYXJlQ2xhc3NlcyhbJ2luaXRpYWxpemVkJywgcGFyYW1zLmRpcmVjdGlvbiwge1xuICAgICdmcmVlLW1vZGUnOiBzd2lwZXIucGFyYW1zLmZyZWVNb2RlICYmIHBhcmFtcy5mcmVlTW9kZS5lbmFibGVkXG4gIH0sIHtcbiAgICAnYXV0b2hlaWdodCc6IHBhcmFtcy5hdXRvSGVpZ2h0XG4gIH0sIHtcbiAgICAncnRsJzogcnRsXG4gIH0sIHtcbiAgICAnZ3JpZCc6IHBhcmFtcy5ncmlkICYmIHBhcmFtcy5ncmlkLnJvd3MgPiAxXG4gIH0sIHtcbiAgICAnZ3JpZC1jb2x1bW4nOiBwYXJhbXMuZ3JpZCAmJiBwYXJhbXMuZ3JpZC5yb3dzID4gMSAmJiBwYXJhbXMuZ3JpZC5maWxsID09PSAnY29sdW1uJ1xuICB9LCB7XG4gICAgJ2FuZHJvaWQnOiBkZXZpY2UuYW5kcm9pZFxuICB9LCB7XG4gICAgJ2lvcyc6IGRldmljZS5pb3NcbiAgfSwge1xuICAgICdjc3MtbW9kZSc6IHBhcmFtcy5jc3NNb2RlXG4gIH0sIHtcbiAgICAnY2VudGVyZWQnOiBwYXJhbXMuY3NzTW9kZSAmJiBwYXJhbXMuY2VudGVyZWRTbGlkZXNcbiAgfSwge1xuICAgICd3YXRjaC1wcm9ncmVzcyc6IHBhcmFtcy53YXRjaFNsaWRlc1Byb2dyZXNzXG4gIH1dLCBwYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcyk7XG4gIGNsYXNzTmFtZXMucHVzaCguLi5zdWZmaXhlcyk7XG4gIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gIHN3aXBlci5lbWl0Q29udGFpbmVyQ2xhc3NlcygpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzKCkge1xuICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICBjb25zdCB7XG4gICAgZWwsXG4gICAgY2xhc3NOYW1lc1xuICB9ID0gc3dpcGVyO1xuICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICBzd2lwZXIuZW1pdENvbnRhaW5lckNsYXNzZXMoKTtcbn1cblxudmFyIGNsYXNzZXMgPSB7XG4gIGFkZENsYXNzZXMsXG4gIHJlbW92ZUNsYXNzZXNcbn07XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3coKSB7XG4gIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gIGNvbnN0IHtcbiAgICBpc0xvY2tlZDogd2FzTG9ja2VkLFxuICAgIHBhcmFtc1xuICB9ID0gc3dpcGVyO1xuICBjb25zdCB7XG4gICAgc2xpZGVzT2Zmc2V0QmVmb3JlXG4gIH0gPSBwYXJhbXM7XG4gIGlmIChzbGlkZXNPZmZzZXRCZWZvcmUpIHtcbiAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHN3aXBlci5zbGlkZXMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBsYXN0U2xpZGVSaWdodEVkZ2UgPSBzd2lwZXIuc2xpZGVzR3JpZFtsYXN0U2xpZGVJbmRleF0gKyBzd2lwZXIuc2xpZGVzU2l6ZXNHcmlkW2xhc3RTbGlkZUluZGV4XSArIHNsaWRlc09mZnNldEJlZm9yZSAqIDI7XG4gICAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNpemUgPiBsYXN0U2xpZGVSaWdodEVkZ2U7XG4gIH0gZWxzZSB7XG4gICAgc3dpcGVyLmlzTG9ja2VkID0gc3dpcGVyLnNuYXBHcmlkLmxlbmd0aCA9PT0gMTtcbiAgfVxuICBpZiAocGFyYW1zLmFsbG93U2xpZGVOZXh0ID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVOZXh0ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgfVxuICBpZiAocGFyYW1zLmFsbG93U2xpZGVQcmV2ID09PSB0cnVlKSB7XG4gICAgc3dpcGVyLmFsbG93U2xpZGVQcmV2ID0gIXN3aXBlci5pc0xvY2tlZDtcbiAgfVxuICBpZiAod2FzTG9ja2VkICYmIHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgc3dpcGVyLmlzRW5kID0gZmFsc2U7XG4gIH1cbiAgaWYgKHdhc0xvY2tlZCAhPT0gc3dpcGVyLmlzTG9ja2VkKSB7XG4gICAgc3dpcGVyLmVtaXQoc3dpcGVyLmlzTG9ja2VkID8gJ2xvY2snIDogJ3VubG9jaycpO1xuICB9XG59XG52YXIgY2hlY2tPdmVyZmxvdyQxID0ge1xuICBjaGVja092ZXJmbG93XG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGluaXQ6IHRydWUsXG4gIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICBvbmVXYXlNb3ZlbWVudDogZmFsc2UsXG4gIHRvdWNoRXZlbnRzVGFyZ2V0OiAnd3JhcHBlcicsXG4gIGluaXRpYWxTbGlkZTogMCxcbiAgc3BlZWQ6IDMwMCxcbiAgY3NzTW9kZTogZmFsc2UsXG4gIHVwZGF0ZU9uV2luZG93UmVzaXplOiB0cnVlLFxuICByZXNpemVPYnNlcnZlcjogdHJ1ZSxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgY3JlYXRlRWxlbWVudHM6IGZhbHNlLFxuICBldmVudHNQcmVmaXg6ICdzd2lwZXInLFxuICBlbmFibGVkOiB0cnVlLFxuICBmb2N1c2FibGVFbGVtZW50czogJ2lucHV0LCBzZWxlY3QsIG9wdGlvbiwgdGV4dGFyZWEsIGJ1dHRvbiwgdmlkZW8sIGxhYmVsJyxcbiAgLy8gT3ZlcnJpZGVzXG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIC8vXG4gIHByZXZlbnRJbnRlcmFjdGlvbk9uVHJhbnNpdGlvbjogZmFsc2UsXG4gIC8vIHNzclxuICB1c2VyQWdlbnQ6IG51bGwsXG4gIHVybDogbnVsbCxcbiAgLy8gVG8gc3VwcG9ydCBpT1MncyBzd2lwZS10by1nby1iYWNrIGdlc3R1cmUgKHdoZW4gYmVpbmcgdXNlZCBpbi1hcHApLlxuICBlZGdlU3dpcGVEZXRlY3Rpb246IGZhbHNlLFxuICBlZGdlU3dpcGVUaHJlc2hvbGQ6IDIwLFxuICAvLyBBdXRvaGVpZ2h0XG4gIGF1dG9IZWlnaHQ6IGZhbHNlLFxuICAvLyBTZXQgd3JhcHBlciB3aWR0aFxuICBzZXRXcmFwcGVyU2l6ZTogZmFsc2UsXG4gIC8vIFZpcnR1YWwgVHJhbnNsYXRlXG4gIHZpcnR1YWxUcmFuc2xhdGU6IGZhbHNlLFxuICAvLyBFZmZlY3RzXG4gIGVmZmVjdDogJ3NsaWRlJyxcbiAgLy8gJ3NsaWRlJyBvciAnZmFkZScgb3IgJ2N1YmUnIG9yICdjb3ZlcmZsb3cnIG9yICdmbGlwJ1xuXG4gIC8vIEJyZWFrcG9pbnRzXG4gIGJyZWFrcG9pbnRzOiB1bmRlZmluZWQsXG4gIGJyZWFrcG9pbnRzQmFzZTogJ3dpbmRvdycsXG4gIC8vIFNsaWRlcyBncmlkXG4gIHNwYWNlQmV0d2VlbjogMCxcbiAgc2xpZGVzUGVyVmlldzogMSxcbiAgc2xpZGVzUGVyR3JvdXA6IDEsXG4gIHNsaWRlc1Blckdyb3VwU2tpcDogMCxcbiAgc2xpZGVzUGVyR3JvdXBBdXRvOiBmYWxzZSxcbiAgY2VudGVyZWRTbGlkZXM6IGZhbHNlLFxuICBjZW50ZXJlZFNsaWRlc0JvdW5kczogZmFsc2UsXG4gIHNsaWRlc09mZnNldEJlZm9yZTogMCxcbiAgLy8gaW4gcHhcbiAgc2xpZGVzT2Zmc2V0QWZ0ZXI6IDAsXG4gIC8vIGluIHB4XG4gIG5vcm1hbGl6ZVNsaWRlSW5kZXg6IHRydWUsXG4gIGNlbnRlckluc3VmZmljaWVudFNsaWRlczogZmFsc2UsXG4gIC8vIERpc2FibGUgc3dpcGVyIGFuZCBoaWRlIG5hdmlnYXRpb24gd2hlbiBjb250YWluZXIgbm90IG92ZXJmbG93XG4gIHdhdGNoT3ZlcmZsb3c6IHRydWUsXG4gIC8vIFJvdW5kIGxlbmd0aFxuICByb3VuZExlbmd0aHM6IGZhbHNlLFxuICAvLyBUb3VjaGVzXG4gIHRvdWNoUmF0aW86IDEsXG4gIHRvdWNoQW5nbGU6IDQ1LFxuICBzaW11bGF0ZVRvdWNoOiB0cnVlLFxuICBzaG9ydFN3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlczogdHJ1ZSxcbiAgbG9uZ1N3aXBlc1JhdGlvOiAwLjUsXG4gIGxvbmdTd2lwZXNNczogMzAwLFxuICBmb2xsb3dGaW5nZXI6IHRydWUsXG4gIGFsbG93VG91Y2hNb3ZlOiB0cnVlLFxuICB0aHJlc2hvbGQ6IDUsXG4gIHRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gIHRvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdDogdHJ1ZSxcbiAgdG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQ6IGZhbHNlLFxuICB0b3VjaFJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgLy8gVW5pcXVlIE5hdmlnYXRpb24gRWxlbWVudHNcbiAgdW5pcXVlTmF2RWxlbWVudHM6IHRydWUsXG4gIC8vIFJlc2lzdGFuY2VcbiAgcmVzaXN0YW5jZTogdHJ1ZSxcbiAgcmVzaXN0YW5jZVJhdGlvOiAwLjg1LFxuICAvLyBQcm9ncmVzc1xuICB3YXRjaFNsaWRlc1Byb2dyZXNzOiBmYWxzZSxcbiAgLy8gQ3Vyc29yXG4gIGdyYWJDdXJzb3I6IGZhbHNlLFxuICAvLyBDbGlja3NcbiAgcHJldmVudENsaWNrczogdHJ1ZSxcbiAgcHJldmVudENsaWNrc1Byb3BhZ2F0aW9uOiB0cnVlLFxuICBzbGlkZVRvQ2xpY2tlZFNsaWRlOiBmYWxzZSxcbiAgLy8gbG9vcFxuICBsb29wOiBmYWxzZSxcbiAgbG9vcEFkZEJsYW5rU2xpZGVzOiB0cnVlLFxuICBsb29wQWRkaXRpb25hbFNsaWRlczogMCxcbiAgbG9vcFByZXZlbnRzU2xpZGluZzogdHJ1ZSxcbiAgLy8gcmV3aW5kXG4gIHJld2luZDogZmFsc2UsXG4gIC8vIFN3aXBpbmcvbm8gc3dpcGluZ1xuICBhbGxvd1NsaWRlUHJldjogdHJ1ZSxcbiAgYWxsb3dTbGlkZU5leHQ6IHRydWUsXG4gIHN3aXBlSGFuZGxlcjogbnVsbCxcbiAgLy8gJy5zd2lwZS1oYW5kbGVyJyxcbiAgbm9Td2lwaW5nOiB0cnVlLFxuICBub1N3aXBpbmdDbGFzczogJ3N3aXBlci1uby1zd2lwaW5nJyxcbiAgbm9Td2lwaW5nU2VsZWN0b3I6IG51bGwsXG4gIC8vIFBhc3NpdmUgTGlzdGVuZXJzXG4gIHBhc3NpdmVMaXN0ZW5lcnM6IHRydWUsXG4gIG1heEJhY2tmYWNlSGlkZGVuU2xpZGVzOiAxMCxcbiAgLy8gTlNcbiAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3N3aXBlci0nLFxuICAvLyBORVdcbiAgc2xpZGVDbGFzczogJ3N3aXBlci1zbGlkZScsXG4gIHNsaWRlQmxhbmtDbGFzczogJ3N3aXBlci1zbGlkZS1ibGFuaycsXG4gIHNsaWRlQWN0aXZlQ2xhc3M6ICdzd2lwZXItc2xpZGUtYWN0aXZlJyxcbiAgc2xpZGVWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtdmlzaWJsZScsXG4gIHNsaWRlRnVsbHlWaXNpYmxlQ2xhc3M6ICdzd2lwZXItc2xpZGUtZnVsbHktdmlzaWJsZScsXG4gIHNsaWRlTmV4dENsYXNzOiAnc3dpcGVyLXNsaWRlLW5leHQnLFxuICBzbGlkZVByZXZDbGFzczogJ3N3aXBlci1zbGlkZS1wcmV2JyxcbiAgd3JhcHBlckNsYXNzOiAnc3dpcGVyLXdyYXBwZXInLFxuICBsYXp5UHJlbG9hZGVyQ2xhc3M6ICdzd2lwZXItbGF6eS1wcmVsb2FkZXInLFxuICBsYXp5UHJlbG9hZFByZXZOZXh0OiAwLFxuICAvLyBDYWxsYmFja3NcbiAgcnVuQ2FsbGJhY2tzT25Jbml0OiB0cnVlLFxuICAvLyBJbnRlcm5hbHNcbiAgX2VtaXRDbGFzc2VzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gbW9kdWxlRXh0ZW5kUGFyYW1zKHBhcmFtcywgYWxsTW9kdWxlc1BhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kUGFyYW1zKG9iaikge1xuICAgIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgICAgb2JqID0ge307XG4gICAgfVxuICAgIGNvbnN0IG1vZHVsZVBhcmFtTmFtZSA9IE9iamVjdC5rZXlzKG9iailbMF07XG4gICAgY29uc3QgbW9kdWxlUGFyYW1zID0gb2JqW21vZHVsZVBhcmFtTmFtZV07XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVQYXJhbXMgIT09ICdvYmplY3QnIHx8IG1vZHVsZVBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gdHJ1ZSkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtb2R1bGVQYXJhbU5hbWUgPT09ICduYXZpZ2F0aW9uJyAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSAmJiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkICYmICFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5wcmV2RWwgJiYgIXBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLm5leHRFbCkge1xuICAgICAgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uYXV0byA9IHRydWU7XG4gICAgfVxuICAgIGlmIChbJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uaW5kZXhPZihtb2R1bGVQYXJhbU5hbWUpID49IDAgJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gJiYgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZW5hYmxlZCAmJiAhcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0uZWwpIHtcbiAgICAgIHBhcmFtc1ttb2R1bGVQYXJhbU5hbWVdLmF1dG8gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIShtb2R1bGVQYXJhbU5hbWUgaW4gcGFyYW1zICYmICdlbmFibGVkJyBpbiBtb2R1bGVQYXJhbXMpKSB7XG4gICAgICBleHRlbmQoYWxsTW9kdWxlc1BhcmFtcywgb2JqKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSA9PT0gJ29iamVjdCcgJiYgISgnZW5hYmxlZCcgaW4gcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXS5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXNbbW9kdWxlUGFyYW1OYW1lXSkgcGFyYW1zW21vZHVsZVBhcmFtTmFtZV0gPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZVxuICAgIH07XG4gICAgZXh0ZW5kKGFsbE1vZHVsZXNQYXJhbXMsIG9iaik7XG4gIH07XG59XG5cbi8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogXCJvZmZcIiAqL1xuY29uc3QgcHJvdG90eXBlcyA9IHtcbiAgZXZlbnRzRW1pdHRlcixcbiAgdXBkYXRlLFxuICB0cmFuc2xhdGUsXG4gIHRyYW5zaXRpb24sXG4gIHNsaWRlLFxuICBsb29wLFxuICBncmFiQ3Vyc29yLFxuICBldmVudHM6IGV2ZW50cyQxLFxuICBicmVha3BvaW50cyxcbiAgY2hlY2tPdmVyZmxvdzogY2hlY2tPdmVyZmxvdyQxLFxuICBjbGFzc2VzXG59O1xuY29uc3QgZXh0ZW5kZWREZWZhdWx0cyA9IHt9O1xuY2xhc3MgU3dpcGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IGVsO1xuICAgIGxldCBwYXJhbXM7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXS5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnc1swXSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgcGFyYW1zID0gYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgW2VsLCBwYXJhbXNdID0gYXJncztcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgICBpZiAoZWwgJiYgIXBhcmFtcy5lbCkgcGFyYW1zLmVsID0gZWw7XG4gICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgIGlmIChwYXJhbXMuZWwgJiYgdHlwZW9mIHBhcmFtcy5lbCA9PT0gJ3N0cmluZycgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJhbXMuZWwpLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHN3aXBlcnMgPSBbXTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFyYW1zLmVsKS5mb3JFYWNoKGNvbnRhaW5lckVsID0+IHtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gZXh0ZW5kKHt9LCBwYXJhbXMsIHtcbiAgICAgICAgICBlbDogY29udGFpbmVyRWxcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXBlcnMucHVzaChuZXcgU3dpcGVyKG5ld1BhcmFtcykpO1xuICAgICAgfSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RydWN0b3ItcmV0dXJuXG4gICAgICByZXR1cm4gc3dpcGVycztcbiAgICB9XG5cbiAgICAvLyBTd2lwZXIgSW5zdGFuY2VcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIHN3aXBlci5fX3N3aXBlcl9fID0gdHJ1ZTtcbiAgICBzd2lwZXIuc3VwcG9ydCA9IGdldFN1cHBvcnQoKTtcbiAgICBzd2lwZXIuZGV2aWNlID0gZ2V0RGV2aWNlKHtcbiAgICAgIHVzZXJBZ2VudDogcGFyYW1zLnVzZXJBZ2VudFxuICAgIH0pO1xuICAgIHN3aXBlci5icm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgIHN3aXBlci5ldmVudHNMaXN0ZW5lcnMgPSB7fTtcbiAgICBzd2lwZXIuZXZlbnRzQW55TGlzdGVuZXJzID0gW107XG4gICAgc3dpcGVyLm1vZHVsZXMgPSBbLi4uc3dpcGVyLl9fbW9kdWxlc19fXTtcbiAgICBpZiAocGFyYW1zLm1vZHVsZXMgJiYgQXJyYXkuaXNBcnJheShwYXJhbXMubW9kdWxlcykpIHtcbiAgICAgIHN3aXBlci5tb2R1bGVzLnB1c2goLi4ucGFyYW1zLm1vZHVsZXMpO1xuICAgIH1cbiAgICBjb25zdCBhbGxNb2R1bGVzUGFyYW1zID0ge307XG4gICAgc3dpcGVyLm1vZHVsZXMuZm9yRWFjaChtb2QgPT4ge1xuICAgICAgbW9kKHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBzd2lwZXIsXG4gICAgICAgIGV4dGVuZFBhcmFtczogbW9kdWxlRXh0ZW5kUGFyYW1zKHBhcmFtcywgYWxsTW9kdWxlc1BhcmFtcyksXG4gICAgICAgIG9uOiBzd2lwZXIub24uYmluZChzd2lwZXIpLFxuICAgICAgICBvbmNlOiBzd2lwZXIub25jZS5iaW5kKHN3aXBlciksXG4gICAgICAgIG9mZjogc3dpcGVyLm9mZi5iaW5kKHN3aXBlciksXG4gICAgICAgIGVtaXQ6IHN3aXBlci5lbWl0LmJpbmQoc3dpcGVyKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBFeHRlbmQgZGVmYXVsdHMgd2l0aCBtb2R1bGVzIHBhcmFtc1xuICAgIGNvbnN0IHN3aXBlclBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIGFsbE1vZHVsZXNQYXJhbXMpO1xuXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzIHdpdGggcGFzc2VkIHBhcmFtc1xuICAgIHN3aXBlci5wYXJhbXMgPSBleHRlbmQoe30sIHN3aXBlclBhcmFtcywgZXh0ZW5kZWREZWZhdWx0cywgcGFyYW1zKTtcbiAgICBzd2lwZXIub3JpZ2luYWxQYXJhbXMgPSBleHRlbmQoe30sIHN3aXBlci5wYXJhbXMpO1xuICAgIHN3aXBlci5wYXNzZWRQYXJhbXMgPSBleHRlbmQoe30sIHBhcmFtcyk7XG5cbiAgICAvLyBhZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKHN3aXBlci5wYXJhbXMgJiYgc3dpcGVyLnBhcmFtcy5vbikge1xuICAgICAgT2JqZWN0LmtleXMoc3dpcGVyLnBhcmFtcy5vbikuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgICBzd2lwZXIub24oZXZlbnROYW1lLCBzd2lwZXIucGFyYW1zLm9uW2V2ZW50TmFtZV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzd2lwZXIucGFyYW1zICYmIHN3aXBlci5wYXJhbXMub25BbnkpIHtcbiAgICAgIHN3aXBlci5vbkFueShzd2lwZXIucGFyYW1zLm9uQW55KTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgU3dpcGVyXG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgIGVuYWJsZWQ6IHN3aXBlci5wYXJhbXMuZW5hYmxlZCxcbiAgICAgIGVsLFxuICAgICAgLy8gQ2xhc3Nlc1xuICAgICAgY2xhc3NOYW1lczogW10sXG4gICAgICAvLyBTbGlkZXNcbiAgICAgIHNsaWRlczogW10sXG4gICAgICBzbGlkZXNHcmlkOiBbXSxcbiAgICAgIHNuYXBHcmlkOiBbXSxcbiAgICAgIHNsaWRlc1NpemVzR3JpZDogW10sXG4gICAgICAvLyBpc0RpcmVjdGlvblxuICAgICAgaXNIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJztcbiAgICAgIH0sXG4gICAgICBpc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgICB9LFxuICAgICAgLy8gSW5kZXhlc1xuICAgICAgYWN0aXZlSW5kZXg6IDAsXG4gICAgICByZWFsSW5kZXg6IDAsXG4gICAgICAvL1xuICAgICAgaXNCZWdpbm5pbmc6IHRydWUsXG4gICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAvLyBQcm9wc1xuICAgICAgdHJhbnNsYXRlOiAwLFxuICAgICAgcHJldmlvdXNUcmFuc2xhdGU6IDAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgYW5pbWF0aW5nOiBmYWxzZSxcbiAgICAgIGNzc092ZXJmbG93QWRqdXN0bWVudCgpIHtcbiAgICAgICAgLy8gUmV0dXJucyAwIHVubGVzcyBgdHJhbnNsYXRlYCBpcyA+IDIqKjIzXG4gICAgICAgIC8vIFNob3VsZCBiZSBzdWJ0cmFjdGVkIGZyb20gY3NzIHZhbHVlcyB0byBwcmV2ZW50IG92ZXJmbG93XG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKHRoaXMudHJhbnNsYXRlIC8gMiAqKiAyMykgKiAyICoqIDIzO1xuICAgICAgfSxcbiAgICAgIC8vIExvY2tzXG4gICAgICBhbGxvd1NsaWRlTmV4dDogc3dpcGVyLnBhcmFtcy5hbGxvd1NsaWRlTmV4dCxcbiAgICAgIGFsbG93U2xpZGVQcmV2OiBzd2lwZXIucGFyYW1zLmFsbG93U2xpZGVQcmV2LFxuICAgICAgLy8gVG91Y2ggRXZlbnRzXG4gICAgICB0b3VjaEV2ZW50c0RhdGE6IHtcbiAgICAgICAgaXNUb3VjaGVkOiB1bmRlZmluZWQsXG4gICAgICAgIGlzTW92ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dUb3VjaENhbGxiYWNrczogdW5kZWZpbmVkLFxuICAgICAgICB0b3VjaFN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgICAgICBpc1Njcm9sbGluZzogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXJ0VHJhbnNsYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93VGhyZXNob2xkTW92ZTogdW5kZWZpbmVkLFxuICAgICAgICAvLyBGb3JtIGVsZW1lbnRzIHRvIG1hdGNoXG4gICAgICAgIGZvY3VzYWJsZUVsZW1lbnRzOiBzd2lwZXIucGFyYW1zLmZvY3VzYWJsZUVsZW1lbnRzLFxuICAgICAgICAvLyBMYXN0IGNsaWNrIHRpbWVcbiAgICAgICAgbGFzdENsaWNrVGltZTogMCxcbiAgICAgICAgY2xpY2tUaW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgIC8vIFZlbG9jaXRpZXNcbiAgICAgICAgdmVsb2NpdGllczogW10sXG4gICAgICAgIGFsbG93TW9tZW50dW1Cb3VuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRNb3Zpbmc6IHVuZGVmaW5lZCxcbiAgICAgICAgcG9pbnRlcklkOiBudWxsLFxuICAgICAgICB0b3VjaElkOiBudWxsXG4gICAgICB9LFxuICAgICAgLy8gQ2xpY2tzXG4gICAgICBhbGxvd0NsaWNrOiB0cnVlLFxuICAgICAgLy8gVG91Y2hlc1xuICAgICAgYWxsb3dUb3VjaE1vdmU6IHN3aXBlci5wYXJhbXMuYWxsb3dUb3VjaE1vdmUsXG4gICAgICB0b3VjaGVzOiB7XG4gICAgICAgIHN0YXJ0WDogMCxcbiAgICAgICAgc3RhcnRZOiAwLFxuICAgICAgICBjdXJyZW50WDogMCxcbiAgICAgICAgY3VycmVudFk6IDAsXG4gICAgICAgIGRpZmY6IDBcbiAgICAgIH0sXG4gICAgICAvLyBJbWFnZXNcbiAgICAgIGltYWdlc1RvTG9hZDogW10sXG4gICAgICBpbWFnZXNMb2FkZWQ6IDBcbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnX3N3aXBlcicpO1xuXG4gICAgLy8gSW5pdFxuICAgIGlmIChzd2lwZXIucGFyYW1zLmluaXQpIHtcbiAgICAgIHN3aXBlci5pbml0KCk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFwcCBpbnN0YW5jZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdHJ1Y3Rvci1yZXR1cm5cbiAgICByZXR1cm4gc3dpcGVyO1xuICB9XG4gIGdldERpcmVjdGlvbkxhYmVsKHByb3BlcnR5KSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgcmV0dXJuIHtcbiAgICAgICd3aWR0aCc6ICdoZWlnaHQnLFxuICAgICAgJ21hcmdpbi10b3AnOiAnbWFyZ2luLWxlZnQnLFxuICAgICAgJ21hcmdpbi1ib3R0b20gJzogJ21hcmdpbi1yaWdodCcsXG4gICAgICAnbWFyZ2luLWxlZnQnOiAnbWFyZ2luLXRvcCcsXG4gICAgICAnbWFyZ2luLXJpZ2h0JzogJ21hcmdpbi1ib3R0b20nLFxuICAgICAgJ3BhZGRpbmctbGVmdCc6ICdwYWRkaW5nLXRvcCcsXG4gICAgICAncGFkZGluZy1yaWdodCc6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgICAnbWFyZ2luUmlnaHQnOiAnbWFyZ2luQm90dG9tJ1xuICAgIH1bcHJvcGVydHldO1xuICB9XG4gIGdldFNsaWRlSW5kZXgoc2xpZGVFbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlc0VsLFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2xpZGVzID0gZWxlbWVudENoaWxkcmVuKHNsaWRlc0VsLCBgLiR7cGFyYW1zLnNsaWRlQ2xhc3N9LCBzd2lwZXItc2xpZGVgKTtcbiAgICBjb25zdCBmaXJzdFNsaWRlSW5kZXggPSBlbGVtZW50SW5kZXgoc2xpZGVzWzBdKTtcbiAgICByZXR1cm4gZWxlbWVudEluZGV4KHNsaWRlRWwpIC0gZmlyc3RTbGlkZUluZGV4O1xuICB9XG4gIGdldFNsaWRlSW5kZXhCeURhdGEoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTbGlkZUluZGV4KHRoaXMuc2xpZGVzLmZpbHRlcihzbGlkZUVsID0+IHNsaWRlRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXN3aXBlci1zbGlkZS1pbmRleCcpICogMSA9PT0gaW5kZXgpWzBdKTtcbiAgfVxuICByZWNhbGNTbGlkZXMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXNFbCxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBzd2lwZXI7XG4gICAgc3dpcGVyLnNsaWRlcyA9IGVsZW1lbnRDaGlsZHJlbihzbGlkZXNFbCwgYC4ke3BhcmFtcy5zbGlkZUNsYXNzfSwgc3dpcGVyLXNsaWRlYCk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKHN3aXBlci5lbmFibGVkKSByZXR1cm47XG4gICAgc3dpcGVyLmVuYWJsZWQgPSB0cnVlO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLmdyYWJDdXJzb3IpIHtcbiAgICAgIHN3aXBlci5zZXRHcmFiQ3Vyc29yKCk7XG4gICAgfVxuICAgIHN3aXBlci5lbWl0KCdlbmFibGUnKTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIuZW5hYmxlZCkgcmV0dXJuO1xuICAgIHN3aXBlci5lbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvcikge1xuICAgICAgc3dpcGVyLnVuc2V0R3JhYkN1cnNvcigpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnZGlzYWJsZScpO1xuICB9XG4gIHNldFByb2dyZXNzKHByb2dyZXNzLCBzcGVlZCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgcHJvZ3Jlc3MgPSBNYXRoLm1pbihNYXRoLm1heChwcm9ncmVzcywgMCksIDEpO1xuICAgIGNvbnN0IG1pbiA9IHN3aXBlci5taW5UcmFuc2xhdGUoKTtcbiAgICBjb25zdCBtYXggPSBzd2lwZXIubWF4VHJhbnNsYXRlKCk7XG4gICAgY29uc3QgY3VycmVudCA9IChtYXggLSBtaW4pICogcHJvZ3Jlc3MgKyBtaW47XG4gICAgc3dpcGVyLnRyYW5zbGF0ZVRvKGN1cnJlbnQsIHR5cGVvZiBzcGVlZCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogc3BlZWQpO1xuICAgIHN3aXBlci51cGRhdGVBY3RpdmVJbmRleCgpO1xuICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gIH1cbiAgZW1pdENvbnRhaW5lckNsYXNzZXMoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlci5wYXJhbXMuX2VtaXRDbGFzc2VzIHx8ICFzd2lwZXIuZWwpIHJldHVybjtcbiAgICBjb25zdCBjbHMgPSBzd2lwZXIuZWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlcicpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzcykgPT09IDA7XG4gICAgfSk7XG4gICAgc3dpcGVyLmVtaXQoJ19jb250YWluZXJDbGFzc2VzJywgY2xzLmpvaW4oJyAnKSk7XG4gIH1cbiAgZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIuZGVzdHJveWVkKSByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHNsaWRlRWwuY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoJ3N3aXBlci1zbGlkZScpID09PSAwIHx8IGNsYXNzTmFtZS5pbmRleE9mKHN3aXBlci5wYXJhbXMuc2xpZGVDbGFzcykgPT09IDA7XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIGVtaXRTbGlkZXNDbGFzc2VzKCkge1xuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgaWYgKCFzd2lwZXIucGFyYW1zLl9lbWl0Q2xhc3NlcyB8fCAhc3dpcGVyLmVsKSByZXR1cm47XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIHN3aXBlci5zbGlkZXMuZm9yRWFjaChzbGlkZUVsID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBzd2lwZXIuZ2V0U2xpZGVDbGFzc2VzKHNsaWRlRWwpO1xuICAgICAgdXBkYXRlcy5wdXNoKHtcbiAgICAgICAgc2xpZGVFbCxcbiAgICAgICAgY2xhc3NOYW1lc1xuICAgICAgfSk7XG4gICAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3MnLCBzbGlkZUVsLCBjbGFzc05hbWVzKTtcbiAgICB9KTtcbiAgICBzd2lwZXIuZW1pdCgnX3NsaWRlQ2xhc3NlcycsIHVwZGF0ZXMpO1xuICB9XG4gIHNsaWRlc1BlclZpZXdEeW5hbWljKHZpZXcsIGV4YWN0KSB7XG4gICAgaWYgKHZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgdmlldyA9ICdjdXJyZW50JztcbiAgICB9XG4gICAgaWYgKGV4YWN0ID09PSB2b2lkIDApIHtcbiAgICAgIGV4YWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN3aXBlciA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcGFyYW1zLFxuICAgICAgc2xpZGVzLFxuICAgICAgc2xpZGVzR3JpZCxcbiAgICAgIHNsaWRlc1NpemVzR3JpZCxcbiAgICAgIHNpemU6IHN3aXBlclNpemUsXG4gICAgICBhY3RpdmVJbmRleFxuICAgIH0gPSBzd2lwZXI7XG4gICAgbGV0IHNwdiA9IDE7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuc2xpZGVzUGVyVmlldyA9PT0gJ251bWJlcicpIHJldHVybiBwYXJhbXMuc2xpZGVzUGVyVmlldztcbiAgICBpZiAocGFyYW1zLmNlbnRlcmVkU2xpZGVzKSB7XG4gICAgICBsZXQgc2xpZGVTaXplID0gc2xpZGVzW2FjdGl2ZUluZGV4XSA/IHNsaWRlc1thY3RpdmVJbmRleF0uc3dpcGVyU2xpZGVTaXplIDogMDtcbiAgICAgIGxldCBicmVha0xvb3A7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggKyAxOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0gJiYgIWJyZWFrTG9vcCkge1xuICAgICAgICAgIHNsaWRlU2l6ZSArPSBzbGlkZXNbaV0uc3dpcGVyU2xpZGVTaXplO1xuICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIGlmIChzbGlkZVNpemUgPiBzd2lwZXJTaXplKSBicmVha0xvb3AgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlSW5kZXggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAoc2xpZGVzW2ldICYmICFicmVha0xvb3ApIHtcbiAgICAgICAgICBzbGlkZVNpemUgKz0gc2xpZGVzW2ldLnN3aXBlclNsaWRlU2l6ZTtcbiAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICBpZiAoc2xpZGVTaXplID4gc3dpcGVyU2l6ZSkgYnJlYWtMb29wID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGlmICh2aWV3ID09PSAnY3VycmVudCcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4ICsgMTsgaSA8IHNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGNvbnN0IHNsaWRlSW5WaWV3ID0gZXhhY3QgPyBzbGlkZXNHcmlkW2ldICsgc2xpZGVzU2l6ZXNHcmlkW2ldIC0gc2xpZGVzR3JpZFthY3RpdmVJbmRleF0gPCBzd2lwZXJTaXplIDogc2xpZGVzR3JpZFtpXSAtIHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIDwgc3dpcGVyU2l6ZTtcbiAgICAgICAgICBpZiAoc2xpZGVJblZpZXcpIHtcbiAgICAgICAgICAgIHNwdiArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJldmlvdXNcbiAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZUluZGV4IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICBjb25zdCBzbGlkZUluVmlldyA9IHNsaWRlc0dyaWRbYWN0aXZlSW5kZXhdIC0gc2xpZGVzR3JpZFtpXSA8IHN3aXBlclNpemU7XG4gICAgICAgICAgaWYgKHNsaWRlSW5WaWV3KSB7XG4gICAgICAgICAgICBzcHYgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwdjtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc25hcEdyaWQsXG4gICAgICBwYXJhbXNcbiAgICB9ID0gc3dpcGVyO1xuICAgIC8vIEJyZWFrcG9pbnRzXG4gICAgaWYgKHBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG4gICAgWy4uLnN3aXBlci5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbbG9hZGluZz1cImxhenlcIl0nKV0uZm9yRWFjaChpbWFnZUVsID0+IHtcbiAgICAgIGlmIChpbWFnZUVsLmNvbXBsZXRlKSB7XG4gICAgICAgIHByb2Nlc3NMYXp5UHJlbG9hZGVyKHN3aXBlciwgaW1hZ2VFbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3dpcGVyLnVwZGF0ZVNpemUoKTtcbiAgICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVByb2dyZXNzKCk7XG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlc0NsYXNzZXMoKTtcbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGUoKSB7XG4gICAgICBjb25zdCB0cmFuc2xhdGVWYWx1ZSA9IHN3aXBlci5ydGxUcmFuc2xhdGUgPyBzd2lwZXIudHJhbnNsYXRlICogLTEgOiBzd2lwZXIudHJhbnNsYXRlO1xuICAgICAgY29uc3QgbmV3VHJhbnNsYXRlID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNsYXRlVmFsdWUsIHN3aXBlci5tYXhUcmFuc2xhdGUoKSksIHN3aXBlci5taW5UcmFuc2xhdGUoKSk7XG4gICAgICBzd2lwZXIuc2V0VHJhbnNsYXRlKG5ld1RyYW5zbGF0ZSk7XG4gICAgICBzd2lwZXIudXBkYXRlQWN0aXZlSW5kZXgoKTtcbiAgICAgIHN3aXBlci51cGRhdGVTbGlkZXNDbGFzc2VzKCk7XG4gICAgfVxuICAgIGxldCB0cmFuc2xhdGVkO1xuICAgIGlmIChwYXJhbXMuZnJlZU1vZGUgJiYgcGFyYW1zLmZyZWVNb2RlLmVuYWJsZWQgJiYgIXBhcmFtcy5jc3NNb2RlKSB7XG4gICAgICBzZXRUcmFuc2xhdGUoKTtcbiAgICAgIGlmIChwYXJhbXMuYXV0b0hlaWdodCkge1xuICAgICAgICBzd2lwZXIudXBkYXRlQXV0b0hlaWdodCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKHBhcmFtcy5zbGlkZXNQZXJWaWV3ID09PSAnYXV0bycgfHwgcGFyYW1zLnNsaWRlc1BlclZpZXcgPiAxKSAmJiBzd2lwZXIuaXNFbmQgJiYgIXBhcmFtcy5jZW50ZXJlZFNsaWRlcykge1xuICAgICAgICBjb25zdCBzbGlkZXMgPSBzd2lwZXIudmlydHVhbCAmJiBwYXJhbXMudmlydHVhbC5lbmFibGVkID8gc3dpcGVyLnZpcnR1YWwuc2xpZGVzIDogc3dpcGVyLnNsaWRlcztcbiAgICAgICAgdHJhbnNsYXRlZCA9IHN3aXBlci5zbGlkZVRvKHNsaWRlcy5sZW5ndGggLSAxLCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2xhdGVkID0gc3dpcGVyLnNsaWRlVG8oc3dpcGVyLmFjdGl2ZUluZGV4LCAwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zbGF0ZWQpIHtcbiAgICAgICAgc2V0VHJhbnNsYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJhbXMud2F0Y2hPdmVyZmxvdyAmJiBzbmFwR3JpZCAhPT0gc3dpcGVyLnNuYXBHcmlkKSB7XG4gICAgICBzd2lwZXIuY2hlY2tPdmVyZmxvdygpO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgndXBkYXRlJyk7XG4gIH1cbiAgY2hhbmdlRGlyZWN0aW9uKG5ld0RpcmVjdGlvbiwgbmVlZFVwZGF0ZSkge1xuICAgIGlmIChuZWVkVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgIG5lZWRVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnREaXJlY3Rpb24gPSBzd2lwZXIucGFyYW1zLmRpcmVjdGlvbjtcbiAgICBpZiAoIW5ld0RpcmVjdGlvbikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBpZiAobmV3RGlyZWN0aW9uID09PSBjdXJyZW50RGlyZWN0aW9uIHx8IG5ld0RpcmVjdGlvbiAhPT0gJ2hvcml6b250YWwnICYmIG5ld0RpcmVjdGlvbiAhPT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIHN3aXBlcjtcbiAgICB9XG4gICAgc3dpcGVyLmVsLmNsYXNzTGlzdC5yZW1vdmUoYCR7c3dpcGVyLnBhcmFtcy5jb250YWluZXJNb2RpZmllckNsYXNzfSR7Y3VycmVudERpcmVjdGlvbn1gKTtcbiAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9JHtuZXdEaXJlY3Rpb259YCk7XG4gICAgc3dpcGVyLmVtaXRDb250YWluZXJDbGFzc2VzKCk7XG4gICAgc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPSBuZXdEaXJlY3Rpb247XG4gICAgc3dpcGVyLnNsaWRlcy5mb3JFYWNoKHNsaWRlRWwgPT4ge1xuICAgICAgaWYgKG5ld0RpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZUVsLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN3aXBlci5lbWl0KCdjaGFuZ2VEaXJlY3Rpb24nKTtcbiAgICBpZiAobmVlZFVwZGF0ZSkgc3dpcGVyLnVwZGF0ZSgpO1xuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2VEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLnJ0bCAmJiBkaXJlY3Rpb24gPT09ICdydGwnIHx8ICFzd2lwZXIucnRsICYmIGRpcmVjdGlvbiA9PT0gJ2x0cicpIHJldHVybjtcbiAgICBzd2lwZXIucnRsID0gZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBzd2lwZXIucnRsVHJhbnNsYXRlID0gc3dpcGVyLnBhcmFtcy5kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiBzd2lwZXIucnRsO1xuICAgIGlmIChzd2lwZXIucnRsKSB7XG4gICAgICBzd2lwZXIuZWwuY2xhc3NMaXN0LmFkZChgJHtzd2lwZXIucGFyYW1zLmNvbnRhaW5lck1vZGlmaWVyQ2xhc3N9cnRsYCk7XG4gICAgICBzd2lwZXIuZWwuZGlyID0gJ3J0bCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5lbC5jbGFzc0xpc3QucmVtb3ZlKGAke3N3aXBlci5wYXJhbXMuY29udGFpbmVyTW9kaWZpZXJDbGFzc31ydGxgKTtcbiAgICAgIHN3aXBlci5lbC5kaXIgPSAnbHRyJztcbiAgICB9XG4gICAgc3dpcGVyLnVwZGF0ZSgpO1xuICB9XG4gIG1vdW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGlmIChzd2lwZXIubW91bnRlZCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBGaW5kIGVsXG4gICAgbGV0IGVsID0gZWxlbWVudCB8fCBzd2lwZXIucGFyYW1zLmVsO1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIH1cbiAgICBpZiAoIWVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsLnN3aXBlciA9IHN3aXBlcjtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLmhvc3QgJiYgZWwucGFyZW50Tm9kZS5ob3N0Lm5vZGVOYW1lID09PSAnU1dJUEVSLUNPTlRBSU5FUicpIHtcbiAgICAgIHN3aXBlci5pc0VsZW1lbnQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBnZXRXcmFwcGVyU2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gYC4keyhzd2lwZXIucGFyYW1zLndyYXBwZXJDbGFzcyB8fCAnJykudHJpbSgpLnNwbGl0KCcgJykuam9pbignLicpfWA7XG4gICAgfTtcbiAgICBjb25zdCBnZXRXcmFwcGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGVsICYmIGVsLnNoYWRvd1Jvb3QgJiYgZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihnZXRXcmFwcGVyU2VsZWN0b3IoKSk7XG4gICAgICAgIC8vIENoaWxkcmVuIG5lZWRzIHRvIHJldHVybiBzbG90IGl0ZW1zXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudENoaWxkcmVuKGVsLCBnZXRXcmFwcGVyU2VsZWN0b3IoKSlbMF07XG4gICAgfTtcbiAgICAvLyBGaW5kIFdyYXBwZXJcbiAgICBsZXQgd3JhcHBlckVsID0gZ2V0V3JhcHBlcigpO1xuICAgIGlmICghd3JhcHBlckVsICYmIHN3aXBlci5wYXJhbXMuY3JlYXRlRWxlbWVudHMpIHtcbiAgICAgIHdyYXBwZXJFbCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHN3aXBlci5wYXJhbXMud3JhcHBlckNsYXNzKTtcbiAgICAgIGVsLmFwcGVuZCh3cmFwcGVyRWwpO1xuICAgICAgZWxlbWVudENoaWxkcmVuKGVsLCBgLiR7c3dpcGVyLnBhcmFtcy5zbGlkZUNsYXNzfWApLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgIHdyYXBwZXJFbC5hcHBlbmQoc2xpZGVFbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXIsIHtcbiAgICAgIGVsLFxuICAgICAgd3JhcHBlckVsLFxuICAgICAgc2xpZGVzRWw6IHN3aXBlci5pc0VsZW1lbnQgJiYgIWVsLnBhcmVudE5vZGUuaG9zdC5zbGlkZVNsb3RzID8gZWwucGFyZW50Tm9kZS5ob3N0IDogd3JhcHBlckVsLFxuICAgICAgaG9zdEVsOiBzd2lwZXIuaXNFbGVtZW50ID8gZWwucGFyZW50Tm9kZS5ob3N0IDogZWwsXG4gICAgICBtb3VudGVkOiB0cnVlLFxuICAgICAgLy8gUlRMXG4gICAgICBydGw6IGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCBlbGVtZW50U3R5bGUoZWwsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcsXG4gICAgICBydGxUcmFuc2xhdGU6IHN3aXBlci5wYXJhbXMuZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgKGVsLmRpci50b0xvd2VyQ2FzZSgpID09PSAncnRsJyB8fCBlbGVtZW50U3R5bGUoZWwsICdkaXJlY3Rpb24nKSA9PT0gJ3J0bCcpLFxuICAgICAgd3JvbmdSVEw6IGVsZW1lbnRTdHlsZSh3cmFwcGVyRWwsICdkaXNwbGF5JykgPT09ICctd2Via2l0LWJveCdcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbml0KGVsKSB7XG4gICAgY29uc3Qgc3dpcGVyID0gdGhpcztcbiAgICBpZiAoc3dpcGVyLmluaXRpYWxpemVkKSByZXR1cm4gc3dpcGVyO1xuICAgIGNvbnN0IG1vdW50ZWQgPSBzd2lwZXIubW91bnQoZWwpO1xuICAgIGlmIChtb3VudGVkID09PSBmYWxzZSkgcmV0dXJuIHN3aXBlcjtcbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlSW5pdCcpO1xuXG4gICAgLy8gU2V0IGJyZWFrcG9pbnRcbiAgICBpZiAoc3dpcGVyLnBhcmFtcy5icmVha3BvaW50cykge1xuICAgICAgc3dpcGVyLnNldEJyZWFrcG9pbnQoKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgQ2xhc3Nlc1xuICAgIHN3aXBlci5hZGRDbGFzc2VzKCk7XG5cbiAgICAvLyBVcGRhdGUgc2l6ZVxuICAgIHN3aXBlci51cGRhdGVTaXplKCk7XG5cbiAgICAvLyBVcGRhdGUgc2xpZGVzXG4gICAgc3dpcGVyLnVwZGF0ZVNsaWRlcygpO1xuICAgIGlmIChzd2lwZXIucGFyYW1zLndhdGNoT3ZlcmZsb3cpIHtcbiAgICAgIHN3aXBlci5jaGVja092ZXJmbG93KCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IEdyYWIgQ3Vyc29yXG4gICAgaWYgKHN3aXBlci5wYXJhbXMuZ3JhYkN1cnNvciAmJiBzd2lwZXIuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyLnNldEdyYWJDdXJzb3IoKTtcbiAgICB9XG5cbiAgICAvLyBTbGlkZSBUbyBJbml0aWFsIFNsaWRlXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCAmJiBzd2lwZXIudmlydHVhbCAmJiBzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgICAgc3dpcGVyLnNsaWRlVG8oc3dpcGVyLnBhcmFtcy5pbml0aWFsU2xpZGUgKyBzd2lwZXIudmlydHVhbC5zbGlkZXNCZWZvcmUsIDAsIHN3aXBlci5wYXJhbXMucnVuQ2FsbGJhY2tzT25Jbml0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXBlci5zbGlkZVRvKHN3aXBlci5wYXJhbXMuaW5pdGlhbFNsaWRlLCAwLCBzd2lwZXIucGFyYW1zLnJ1bkNhbGxiYWNrc09uSW5pdCwgZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBsb29wXG4gICAgaWYgKHN3aXBlci5wYXJhbXMubG9vcCkge1xuICAgICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggZXZlbnRzXG4gICAgc3dpcGVyLmF0dGFjaEV2ZW50cygpO1xuICAgIGNvbnN0IGxhenlFbGVtZW50cyA9IFsuLi5zd2lwZXIuZWwucXVlcnlTZWxlY3RvckFsbCgnW2xvYWRpbmc9XCJsYXp5XCJdJyldO1xuICAgIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgICBsYXp5RWxlbWVudHMucHVzaCguLi5zd2lwZXIuaG9zdEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsb2FkaW5nPVwibGF6eVwiXScpKTtcbiAgICB9XG4gICAgbGF6eUVsZW1lbnRzLmZvckVhY2goaW1hZ2VFbCA9PiB7XG4gICAgICBpZiAoaW1hZ2VFbC5jb21wbGV0ZSkge1xuICAgICAgICBwcm9jZXNzTGF6eVByZWxvYWRlcihzd2lwZXIsIGltYWdlRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2VFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZSA9PiB7XG4gICAgICAgICAgcHJvY2Vzc0xhenlQcmVsb2FkZXIoc3dpcGVyLCBlLnRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHByZWxvYWQoc3dpcGVyKTtcblxuICAgIC8vIEluaXQgRmxhZ1xuICAgIHN3aXBlci5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgcHJlbG9hZChzd2lwZXIpO1xuXG4gICAgLy8gRW1pdFxuICAgIHN3aXBlci5lbWl0KCdpbml0Jyk7XG4gICAgc3dpcGVyLmVtaXQoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiBzd2lwZXI7XG4gIH1cbiAgZGVzdHJveShkZWxldGVJbnN0YW5jZSwgY2xlYW5TdHlsZXMpIHtcbiAgICBpZiAoZGVsZXRlSW5zdGFuY2UgPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlSW5zdGFuY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2xlYW5TdHlsZXMgPT09IHZvaWQgMCkge1xuICAgICAgY2xlYW5TdHlsZXMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzd2lwZXIgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIGVsLFxuICAgICAgd3JhcHBlckVsLFxuICAgICAgc2xpZGVzXG4gICAgfSA9IHN3aXBlcjtcbiAgICBpZiAodHlwZW9mIHN3aXBlci5wYXJhbXMgPT09ICd1bmRlZmluZWQnIHx8IHN3aXBlci5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnYmVmb3JlRGVzdHJveScpO1xuXG4gICAgLy8gSW5pdCBGbGFnXG4gICAgc3dpcGVyLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAvLyBEZXRhY2ggZXZlbnRzXG4gICAgc3dpcGVyLmRldGFjaEV2ZW50cygpO1xuXG4gICAgLy8gRGVzdHJveSBsb29wXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICBzd2lwZXIubG9vcERlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIHN0eWxlc1xuICAgIGlmIChjbGVhblN0eWxlcykge1xuICAgICAgc3dpcGVyLnJlbW92ZUNsYXNzZXMoKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIHdyYXBwZXJFbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBpZiAoc2xpZGVzICYmIHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgc2xpZGVzLmZvckVhY2goc2xpZGVFbCA9PiB7XG4gICAgICAgICAgc2xpZGVFbC5jbGFzc0xpc3QucmVtb3ZlKHBhcmFtcy5zbGlkZVZpc2libGVDbGFzcywgcGFyYW1zLnNsaWRlRnVsbHlWaXNpYmxlQ2xhc3MsIHBhcmFtcy5zbGlkZUFjdGl2ZUNsYXNzLCBwYXJhbXMuc2xpZGVOZXh0Q2xhc3MsIHBhcmFtcy5zbGlkZVByZXZDbGFzcyk7XG4gICAgICAgICAgc2xpZGVFbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgc2xpZGVFbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3dpcGVyLXNsaWRlLWluZGV4Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2lwZXIuZW1pdCgnZGVzdHJveScpO1xuXG4gICAgLy8gRGV0YWNoIGVtaXR0ZXIgZXZlbnRzXG4gICAgT2JqZWN0LmtleXMoc3dpcGVyLmV2ZW50c0xpc3RlbmVycykuZm9yRWFjaChldmVudE5hbWUgPT4ge1xuICAgICAgc3dpcGVyLm9mZihldmVudE5hbWUpO1xuICAgIH0pO1xuICAgIGlmIChkZWxldGVJbnN0YW5jZSAhPT0gZmFsc2UpIHtcbiAgICAgIHN3aXBlci5lbC5zd2lwZXIgPSBudWxsO1xuICAgICAgZGVsZXRlUHJvcHMoc3dpcGVyKTtcbiAgICB9XG4gICAgc3dpcGVyLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGV4dGVuZERlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgZXh0ZW5kKGV4dGVuZGVkRGVmYXVsdHMsIG5ld0RlZmF1bHRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGV4dGVuZGVkRGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIGV4dGVuZGVkRGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4gZGVmYXVsdHM7XG4gIH1cbiAgc3RhdGljIGluc3RhbGxNb2R1bGUobW9kKSB7XG4gICAgaWYgKCFTd2lwZXIucHJvdG90eXBlLl9fbW9kdWxlc19fKSBTd2lwZXIucHJvdG90eXBlLl9fbW9kdWxlc19fID0gW107XG4gICAgY29uc3QgbW9kdWxlcyA9IFN3aXBlci5wcm90b3R5cGUuX19tb2R1bGVzX187XG4gICAgaWYgKHR5cGVvZiBtb2QgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlcy5pbmRleE9mKG1vZCkgPCAwKSB7XG4gICAgICBtb2R1bGVzLnB1c2gobW9kKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtb2R1bGUpKSB7XG4gICAgICBtb2R1bGUuZm9yRWFjaChtID0+IFN3aXBlci5pbnN0YWxsTW9kdWxlKG0pKTtcbiAgICAgIHJldHVybiBTd2lwZXI7XG4gICAgfVxuICAgIFN3aXBlci5pbnN0YWxsTW9kdWxlKG1vZHVsZSk7XG4gICAgcmV0dXJuIFN3aXBlcjtcbiAgfVxufVxuT2JqZWN0LmtleXMocHJvdG90eXBlcykuZm9yRWFjaChwcm90b3R5cGVHcm91cCA9PiB7XG4gIE9iamVjdC5rZXlzKHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdKS5mb3JFYWNoKHByb3RvTWV0aG9kID0+IHtcbiAgICBTd2lwZXIucHJvdG90eXBlW3Byb3RvTWV0aG9kXSA9IHByb3RvdHlwZXNbcHJvdG90eXBlR3JvdXBdW3Byb3RvTWV0aG9kXTtcbiAgfSk7XG59KTtcblN3aXBlci51c2UoW1Jlc2l6ZSwgT2JzZXJ2ZXJdKTtcblxuZXhwb3J0IHsgU3dpcGVyIGFzIFMsIGRlZmF1bHRzIGFzIGQgfTtcbiJdLCJuYW1lcyI6WyJhIiwiZ2V0V2luZG93IiwiZyIsImdldERvY3VtZW50IiwiZWxlbWVudFBhcmVudHMiLCJtIiwiZWxlbWVudFN0eWxlIiwiZSIsImVsZW1lbnRDaGlsZHJlbiIsInMiLCJzZXRDU1NQcm9wZXJ0eSIsImYiLCJlbGVtZW50T3V0ZXJTaXplIiwibyIsImVsZW1lbnROZXh0QWxsIiwicCIsImVsZW1lbnRQcmV2QWxsIiwiaSIsImdldFRyYW5zbGF0ZSIsInEiLCJhbmltYXRlQ1NTTW9kZVNjcm9sbCIsIm4iLCJuZXh0VGljayIsInIiLCJzaG93V2FybmluZyIsImMiLCJjcmVhdGVFbGVtZW50IiwiZCIsIm5vdyIsInQiLCJleHRlbmQiLCJlbGVtZW50SW5kZXgiLCJ1IiwiZGVsZXRlUHJvcHMiLCJzdXBwb3J0IiwiY2FsY1N1cHBvcnQiLCJ3aW5kb3ciLCJkb2N1bWVudCIsInNtb290aFNjcm9sbCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwidG91Y2giLCJEb2N1bWVudFRvdWNoIiwiZ2V0U3VwcG9ydCIsImRldmljZUNhY2hlZCIsImNhbGNEZXZpY2UiLCJfdGVtcCIsInVzZXJBZ2VudCIsInBsYXRmb3JtIiwibmF2aWdhdG9yIiwidWEiLCJkZXZpY2UiLCJpb3MiLCJhbmRyb2lkIiwic2NyZWVuV2lkdGgiLCJzY3JlZW4iLCJ3aWR0aCIsInNjcmVlbkhlaWdodCIsImhlaWdodCIsIm1hdGNoIiwiaXBhZCIsImlwb2QiLCJpcGhvbmUiLCJ3aW5kb3dzIiwibWFjb3MiLCJpUGFkU2NyZWVucyIsImluZGV4T2YiLCJvcyIsImdldERldmljZSIsIm92ZXJyaWRlcyIsImJyb3dzZXIiLCJjYWxjQnJvd3NlciIsIm5lZWRQZXJzcGVjdGl2ZUZpeCIsImlzU2FmYXJpIiwidG9Mb3dlckNhc2UiLCJTdHJpbmciLCJpbmNsdWRlcyIsIm1ham9yIiwibWlub3IiLCJzcGxpdCIsIm1hcCIsIm51bSIsIk51bWJlciIsImlzV2ViVmlldyIsInRlc3QiLCJnZXRCcm93c2VyIiwiUmVzaXplIiwiX3JlZiIsInN3aXBlciIsIm9uIiwiZW1pdCIsIm9ic2VydmVyIiwiYW5pbWF0aW9uRnJhbWUiLCJyZXNpemVIYW5kbGVyIiwiZGVzdHJveWVkIiwiaW5pdGlhbGl6ZWQiLCJjcmVhdGVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiZm9yRWFjaCIsIl9yZWYyIiwiY29udGVudEJveFNpemUiLCJjb250ZW50UmVjdCIsInRhcmdldCIsImVsIiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsIm9ic2VydmUiLCJyZW1vdmVPYnNlcnZlciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidW5vYnNlcnZlIiwib3JpZW50YXRpb25DaGFuZ2VIYW5kbGVyIiwicGFyYW1zIiwicmVzaXplT2JzZXJ2ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk9ic2VydmVyIiwiZXh0ZW5kUGFyYW1zIiwib2JzZXJ2ZXJzIiwiYXR0YWNoIiwib3B0aW9ucyIsIk9ic2VydmVyRnVuYyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJraXRNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zIiwiX19wcmV2ZW50T2JzZXJ2ZXJfXyIsImxlbmd0aCIsIm9ic2VydmVyVXBkYXRlIiwic2V0VGltZW91dCIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJjaGFyYWN0ZXJEYXRhIiwicHVzaCIsImluaXQiLCJvYnNlcnZlUGFyZW50cyIsImNvbnRhaW5lclBhcmVudHMiLCJob3N0RWwiLCJvYnNlcnZlU2xpZGVDaGlsZHJlbiIsIndyYXBwZXJFbCIsImRlc3Ryb3kiLCJkaXNjb25uZWN0Iiwic3BsaWNlIiwiZXZlbnRzRW1pdHRlciIsImV2ZW50cyIsImhhbmRsZXIiLCJwcmlvcml0eSIsInNlbGYiLCJldmVudHNMaXN0ZW5lcnMiLCJtZXRob2QiLCJldmVudCIsIm9uY2UiLCJvbmNlSGFuZGxlciIsIm9mZiIsIl9fZW1pdHRlclByb3h5IiwiX2xlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsIm9uQW55IiwiZXZlbnRzQW55TGlzdGVuZXJzIiwib2ZmQW55IiwiaW5kZXgiLCJldmVudEhhbmRsZXIiLCJkYXRhIiwiY29udGV4dCIsIl9sZW4yIiwiX2tleTIiLCJpc0FycmF5Iiwic2xpY2UiLCJ1bnNoaWZ0IiwiZXZlbnRzQXJyYXkiLCJ1cGRhdGVTaXplIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJpc0hvcml6b250YWwiLCJpc1ZlcnRpY2FsIiwicGFyc2VJbnQiLCJpc05hTiIsIk9iamVjdCIsImFzc2lnbiIsInNpemUiLCJ1cGRhdGVTbGlkZXMiLCJnZXREaXJlY3Rpb25Qcm9wZXJ0eVZhbHVlIiwibm9kZSIsImxhYmVsIiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJnZXREaXJlY3Rpb25MYWJlbCIsInNsaWRlc0VsIiwic3dpcGVyU2l6ZSIsInJ0bFRyYW5zbGF0ZSIsInJ0bCIsIndyb25nUlRMIiwiaXNWaXJ0dWFsIiwidmlydHVhbCIsImVuYWJsZWQiLCJwcmV2aW91c1NsaWRlc0xlbmd0aCIsInNsaWRlcyIsInNsaWRlQ2xhc3MiLCJzbGlkZXNMZW5ndGgiLCJzbmFwR3JpZCIsInNsaWRlc0dyaWQiLCJzbGlkZXNTaXplc0dyaWQiLCJvZmZzZXRCZWZvcmUiLCJzbGlkZXNPZmZzZXRCZWZvcmUiLCJjYWxsIiwib2Zmc2V0QWZ0ZXIiLCJzbGlkZXNPZmZzZXRBZnRlciIsInByZXZpb3VzU25hcEdyaWRMZW5ndGgiLCJwcmV2aW91c1NsaWRlc0dyaWRMZW5ndGgiLCJzcGFjZUJldHdlZW4iLCJzbGlkZVBvc2l0aW9uIiwicHJldlNsaWRlU2l6ZSIsInJlcGxhY2UiLCJ2aXJ0dWFsU2l6ZSIsInNsaWRlRWwiLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5Ub3AiLCJjZW50ZXJlZFNsaWRlcyIsImNzc01vZGUiLCJncmlkRW5hYmxlZCIsImdyaWQiLCJyb3dzIiwiaW5pdFNsaWRlcyIsInVuc2V0U2xpZGVzIiwic2xpZGVTaXplIiwic2hvdWxkUmVzZXRTbGlkZVNpemUiLCJzbGlkZXNQZXJWaWV3IiwiYnJlYWtwb2ludHMiLCJrZXlzIiwiZmlsdGVyIiwia2V5Iiwic2xpZGUiLCJ1cGRhdGVTbGlkZSIsInNsaWRlU3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJjdXJyZW50V2ViS2l0VHJhbnNmb3JtIiwid2Via2l0VHJhbnNmb3JtIiwicm91bmRMZW5ndGhzIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJib3hTaXppbmciLCJvZmZzZXRXaWR0aCIsIk1hdGgiLCJmbG9vciIsInN3aXBlclNsaWRlU2l6ZSIsImFicyIsInNsaWRlc1Blckdyb3VwIiwibWluIiwic2xpZGVzUGVyR3JvdXBTa2lwIiwibWF4IiwiZWZmZWN0Iiwic2V0V3JhcHBlclNpemUiLCJ1cGRhdGVXcmFwcGVyU2l6ZSIsIm5ld1NsaWRlc0dyaWQiLCJzbGlkZXNHcmlkSXRlbSIsImxvb3AiLCJncm91cHMiLCJjZWlsIiwic2xpZGVzQmVmb3JlIiwic2xpZGVzQWZ0ZXIiLCJncm91cFNpemUiLCJfIiwic2xpZGVJbmRleCIsImNlbnRlcmVkU2xpZGVzQm91bmRzIiwiYWxsU2xpZGVzU2l6ZSIsInNsaWRlU2l6ZVZhbHVlIiwibWF4U25hcCIsInNuYXAiLCJjZW50ZXJJbnN1ZmZpY2llbnRTbGlkZXMiLCJhbGxTbGlkZXNPZmZzZXQiLCJzbmFwSW5kZXgiLCJhZGRUb1NuYXBHcmlkIiwiYWRkVG9TbGlkZXNHcmlkIiwidiIsIndhdGNoT3ZlcmZsb3ciLCJjaGVja092ZXJmbG93Iiwid2F0Y2hTbGlkZXNQcm9ncmVzcyIsInVwZGF0ZVNsaWRlc09mZnNldCIsImJhY2tGYWNlSGlkZGVuQ2xhc3MiLCJjb250YWluZXJNb2RpZmllckNsYXNzIiwiaGFzQ2xhc3NCYWNrZmFjZUNsYXNzQWRkZWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsIm1heEJhY2tmYWNlSGlkZGVuU2xpZGVzIiwiYWRkIiwicmVtb3ZlIiwidXBkYXRlQXV0b0hlaWdodCIsInNwZWVkIiwiYWN0aXZlU2xpZGVzIiwic2V0VHJhbnNpdGlvbiIsImdldFNsaWRlQnlJbmRleCIsImdldFNsaWRlSW5kZXhCeURhdGEiLCJ2aXNpYmxlU2xpZGVzIiwiYWN0aXZlSW5kZXgiLCJvZmZzZXRIZWlnaHQiLCJtaW51c09mZnNldCIsImlzRWxlbWVudCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzd2lwZXJTbGlkZU9mZnNldCIsImNzc092ZXJmbG93QWRqdXN0bWVudCIsInVwZGF0ZVNsaWRlc1Byb2dyZXNzIiwidHJhbnNsYXRlIiwib2Zmc2V0Q2VudGVyIiwic2xpZGVWaXNpYmxlQ2xhc3MiLCJzbGlkZUZ1bGx5VmlzaWJsZUNsYXNzIiwidmlzaWJsZVNsaWRlc0luZGV4ZXMiLCJzbGlkZU9mZnNldCIsInNsaWRlUHJvZ3Jlc3MiLCJtaW5UcmFuc2xhdGUiLCJvcmlnaW5hbFNsaWRlUHJvZ3Jlc3MiLCJzbGlkZUJlZm9yZSIsInNsaWRlQWZ0ZXIiLCJpc0Z1bGx5VmlzaWJsZSIsImlzVmlzaWJsZSIsInByb2dyZXNzIiwib3JpZ2luYWxQcm9ncmVzcyIsInVwZGF0ZVByb2dyZXNzIiwibXVsdGlwbGllciIsInRyYW5zbGF0ZXNEaWZmIiwibWF4VHJhbnNsYXRlIiwiaXNCZWdpbm5pbmciLCJpc0VuZCIsInByb2dyZXNzTG9vcCIsIndhc0JlZ2lubmluZyIsIndhc0VuZCIsImlzQmVnaW5uaW5nUm91bmRlZCIsImlzRW5kUm91bmRlZCIsImZpcnN0U2xpZGVJbmRleCIsImxhc3RTbGlkZUluZGV4IiwiZmlyc3RTbGlkZVRyYW5zbGF0ZSIsImxhc3RTbGlkZVRyYW5zbGF0ZSIsInRyYW5zbGF0ZU1heCIsInRyYW5zbGF0ZUFicyIsImF1dG9IZWlnaHQiLCJ1cGRhdGVTbGlkZXNDbGFzc2VzIiwiZ2V0RmlsdGVyZWRTbGlkZSIsInNlbGVjdG9yIiwic2xpZGVBY3RpdmVDbGFzcyIsInNsaWRlTmV4dENsYXNzIiwic2xpZGVQcmV2Q2xhc3MiLCJhY3RpdmVTbGlkZSIsInByZXZTbGlkZSIsIm5leHRTbGlkZSIsImNvbHVtbiIsImVtaXRTbGlkZXNDbGFzc2VzIiwicHJvY2Vzc0xhenlQcmVsb2FkZXIiLCJpbWFnZUVsIiwic2xpZGVTZWxlY3RvciIsImNsb3Nlc3QiLCJsYXp5RWwiLCJxdWVyeVNlbGVjdG9yIiwibGF6eVByZWxvYWRlckNsYXNzIiwic2hhZG93Um9vdCIsInVubGF6eSIsInJlbW92ZUF0dHJpYnV0ZSIsInByZWxvYWQiLCJhbW91bnQiLCJsYXp5UHJlbG9hZFByZXZOZXh0IiwibGVuIiwic2xpZGVzUGVyVmlld0R5bmFtaWMiLCJhY3RpdmVDb2x1bW4iLCJwcmVsb2FkQ29sdW1ucyIsImZyb20iLCJzbGlkZUluZGV4TGFzdEluVmlldyIsInJld2luZCIsInJlYWxJbmRleCIsImdldEFjdGl2ZUluZGV4QnlUcmFuc2xhdGUiLCJub3JtYWxpemVTbGlkZUluZGV4IiwidXBkYXRlQWN0aXZlSW5kZXgiLCJuZXdBY3RpdmVJbmRleCIsInByZXZpb3VzSW5kZXgiLCJwcmV2aW91c1JlYWxJbmRleCIsInByZXZpb3VzU25hcEluZGV4IiwiZ2V0VmlydHVhbFJlYWxJbmRleCIsImFJbmRleCIsInNraXAiLCJmaXJzdFNsaWRlSW5Db2x1bW4iLCJhY3RpdmVTbGlkZUluZGV4IiwiZ2V0QXR0cmlidXRlIiwicnVuQ2FsbGJhY2tzT25Jbml0IiwidXBkYXRlQ2xpY2tlZFNsaWRlIiwicGF0aCIsInBhdGhFbCIsIm1hdGNoZXMiLCJzbGlkZUZvdW5kIiwiY2xpY2tlZFNsaWRlIiwiY2xpY2tlZEluZGV4IiwidW5kZWZpbmVkIiwic2xpZGVUb0NsaWNrZWRTbGlkZSIsInVwZGF0ZSIsImdldFN3aXBlclRyYW5zbGF0ZSIsImF4aXMiLCJ2aXJ0dWFsVHJhbnNsYXRlIiwiY3VycmVudFRyYW5zbGF0ZSIsInNldFRyYW5zbGF0ZSIsImJ5Q29udHJvbGxlciIsIngiLCJ5IiwieiIsInByZXZpb3VzVHJhbnNsYXRlIiwibmV3UHJvZ3Jlc3MiLCJ0cmFuc2xhdGVUbyIsInJ1bkNhbGxiYWNrcyIsInRyYW5zbGF0ZUJvdW5kcyIsImludGVybmFsIiwiYW5pbWF0aW5nIiwicHJldmVudEludGVyYWN0aW9uT25UcmFuc2l0aW9uIiwibmV3VHJhbnNsYXRlIiwiaXNIIiwidGFyZ2V0UG9zaXRpb24iLCJzaWRlIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIm9uVHJhbnNsYXRlVG9XcmFwcGVyVHJhbnNpdGlvbkVuZCIsInRyYW5zaXRpb25FbmQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsInRyYW5zaXRpb25FbWl0IiwiZGlyZWN0aW9uIiwic3RlcCIsImRpciIsInRyYW5zaXRpb25TdGFydCIsInRyYW5zaXRpb24iLCJzbGlkZVRvIiwiaW5pdGlhbCIsIm5vcm1hbGl6ZWRUcmFuc2xhdGUiLCJub3JtYWxpemVkR3JpZCIsIm5vcm1hbGl6ZWRHcmlkTmV4dCIsImFsbG93U2xpZGVOZXh0IiwiYWxsb3dTbGlkZVByZXYiLCJzY3JvbGxTbmFwVHlwZSIsIl9pbW1lZGlhdGVWaXJ0dWFsIiwiX2Nzc01vZGVWaXJ0dWFsSW5pdGlhbFNldCIsImluaXRpYWxTbGlkZSIsIm9uU2xpZGVUb1dyYXBwZXJUcmFuc2l0aW9uRW5kIiwic2xpZGVUb0xvb3AiLCJpbmRleEFzTnVtYmVyIiwibmV3SW5kZXgiLCJ0YXJnZXRTbGlkZUluZGV4IiwiY29scyIsIm5lZWRMb29wRml4IiwibG9vcEZpeCIsInNsaWRlUmVhbEluZGV4Iiwic2xpZGVOZXh0IiwicGVyR3JvdXAiLCJzbGlkZXNQZXJHcm91cEF1dG8iLCJpbmNyZW1lbnQiLCJsb29wUHJldmVudHNTbGlkaW5nIiwiX2NsaWVudExlZnQiLCJjbGllbnRMZWZ0Iiwic2xpZGVQcmV2Iiwibm9ybWFsaXplIiwidmFsIiwibm9ybWFsaXplZFNuYXBHcmlkIiwicHJldlNuYXAiLCJwcmV2U25hcEluZGV4IiwicHJldkluZGV4IiwibGFzdEluZGV4Iiwic2xpZGVSZXNldCIsInNsaWRlVG9DbG9zZXN0IiwidGhyZXNob2xkIiwiY3VycmVudFNuYXAiLCJuZXh0U25hcCIsInNsaWRlVG9JbmRleCIsImxvb3BlZFNsaWRlcyIsImdldFNsaWRlSW5kZXgiLCJsb29wQ3JlYXRlIiwic2V0QXR0cmlidXRlIiwic2hvdWxkRmlsbEdyb3VwIiwic2hvdWxkRmlsbEdyaWQiLCJhZGRCbGFua1NsaWRlcyIsImFtb3VudE9mU2xpZGVzIiwic2xpZGVCbGFua0NsYXNzIiwiYXBwZW5kIiwibG9vcEFkZEJsYW5rU2xpZGVzIiwic2xpZGVzVG9BZGQiLCJyZWNhbGNTbGlkZXMiLCJieU1vdXNld2hlZWwiLCJsb29wQWRkaXRpb25hbFNsaWRlcyIsImZpbGwiLCJwcmVwZW5kU2xpZGVzSW5kZXhlcyIsImFwcGVuZFNsaWRlc0luZGV4ZXMiLCJpc05leHQiLCJpc1ByZXYiLCJzbGlkZXNQcmVwZW5kZWQiLCJzbGlkZXNBcHBlbmRlZCIsImFjdGl2ZUNvbEluZGV4IiwiYWN0aXZlQ29sSW5kZXhXaXRoU2hpZnQiLCJjb2xJbmRleFRvUHJlcGVuZCIsInN3aXBlckxvb3BNb3ZlRE9NIiwicHJlcGVuZCIsImN1cnJlbnRTbGlkZVRyYW5zbGF0ZSIsIm5ld1NsaWRlVHJhbnNsYXRlIiwiZGlmZiIsInRvdWNoRXZlbnRzRGF0YSIsInN0YXJ0VHJhbnNsYXRlIiwic2hpZnQiLCJjb250cm9sbGVyIiwiY29udHJvbCIsImxvb3BQYXJhbXMiLCJjb25zdHJ1Y3RvciIsImxvb3BEZXN0cm95IiwibmV3U2xpZGVzT3JkZXIiLCJzd2lwZXJTbGlkZUluZGV4Iiwic2V0R3JhYkN1cnNvciIsIm1vdmluZyIsInNpbXVsYXRlVG91Y2giLCJpc0xvY2tlZCIsInRvdWNoRXZlbnRzVGFyZ2V0IiwiY3Vyc29yIiwidW5zZXRHcmFiQ3Vyc29yIiwiZ3JhYkN1cnNvciIsImNsb3Nlc3RFbGVtZW50IiwiYmFzZSIsIl9fY2xvc2VzdEZyb20iLCJhc3NpZ25lZFNsb3QiLCJmb3VuZCIsImdldFJvb3ROb2RlIiwiaG9zdCIsInByZXZlbnRFZGdlU3dpcGUiLCJzdGFydFgiLCJlZGdlU3dpcGVEZXRlY3Rpb24iLCJlZGdlU3dpcGVUaHJlc2hvbGQiLCJpbm5lcldpZHRoIiwicHJldmVudERlZmF1bHQiLCJvblRvdWNoU3RhcnQiLCJvcmlnaW5hbEV2ZW50IiwidHlwZSIsInBvaW50ZXJJZCIsInRhcmdldFRvdWNoZXMiLCJ0b3VjaElkIiwiaWRlbnRpZmllciIsInBhZ2VYIiwidG91Y2hlcyIsInBvaW50ZXJUeXBlIiwidGFyZ2V0RWwiLCJ3aGljaCIsImJ1dHRvbiIsImlzVG91Y2hlZCIsImlzTW92ZWQiLCJzd2lwaW5nQ2xhc3NIYXNWYWx1ZSIsIm5vU3dpcGluZ0NsYXNzIiwiZXZlbnRQYXRoIiwiY29tcG9zZWRQYXRoIiwibm9Td2lwaW5nU2VsZWN0b3IiLCJpc1RhcmdldFNoYWRvdyIsIm5vU3dpcGluZyIsImFsbG93Q2xpY2siLCJzd2lwZUhhbmRsZXIiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwicGFnZVkiLCJzdGFydFkiLCJhbGxvd1RvdWNoQ2FsbGJhY2tzIiwiaXNTY3JvbGxpbmciLCJzdGFydE1vdmluZyIsInRvdWNoU3RhcnRUaW1lIiwic3dpcGVEaXJlY3Rpb24iLCJhbGxvd1RocmVzaG9sZE1vdmUiLCJmb2N1c2FibGVFbGVtZW50cyIsIm5vZGVOYW1lIiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJzaG91bGRQcmV2ZW50RGVmYXVsdCIsImFsbG93VG91Y2hNb3ZlIiwidG91Y2hTdGFydFByZXZlbnREZWZhdWx0IiwidG91Y2hTdGFydEZvcmNlUHJldmVudERlZmF1bHQiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImZyZWVNb2RlIiwib25Ub3VjaE1vdmUiLCJpZCIsInRhcmdldFRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJwcmV2ZW50ZWRCeU5lc3RlZFN3aXBlciIsInRvdWNoUmVsZWFzZU9uRWRnZXMiLCJwcmV2aW91c1giLCJwcmV2aW91c1kiLCJkaWZmWCIsImRpZmZZIiwic3FydCIsInRvdWNoQW5nbGUiLCJhdGFuMiIsIlBJIiwiY2FuY2VsYWJsZSIsInRvdWNoTW92ZVN0b3BQcm9wYWdhdGlvbiIsIm5lc3RlZCIsInN0b3BQcm9wYWdhdGlvbiIsInRvdWNoZXNEaWZmIiwib25lV2F5TW92ZW1lbnQiLCJ0b3VjaFJhdGlvIiwicHJldlRvdWNoZXNEaXJlY3Rpb24iLCJ0b3VjaGVzRGlyZWN0aW9uIiwiaXNMb29wIiwiYWxsb3dMb29wRml4IiwiZXZ0IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiZGlzcGF0Y2hFdmVudCIsImFsbG93TW9tZW50dW1Cb3VuY2UiLCJsb29wRml4ZWQiLCJEYXRlIiwiZ2V0VGltZSIsImxvb3BTd2FwUmVzZXQiLCJkaXNhYmxlUGFyZW50U3dpcGVyIiwicmVzaXN0YW5jZVJhdGlvIiwicmVzaXN0YW5jZSIsImZvbGxvd0ZpbmdlciIsIm9uVG91Y2hFbmQiLCJpc1RvdWNoRXZlbnQiLCJwcm9jZWVkIiwidG91Y2hFbmRUaW1lIiwidGltZURpZmYiLCJwYXRoVHJlZSIsImxhc3RDbGlja1RpbWUiLCJjdXJyZW50UG9zIiwic3dpcGVUb0xhc3QiLCJzdG9wSW5kZXgiLCJyZXdpbmRGaXJzdEluZGV4IiwicmV3aW5kTGFzdEluZGV4IiwicmF0aW8iLCJsb25nU3dpcGVzTXMiLCJsb25nU3dpcGVzIiwibG9uZ1N3aXBlc1JhdGlvIiwic2hvcnRTd2lwZXMiLCJpc05hdkJ1dHRvblRhcmdldCIsIm5hdmlnYXRpb24iLCJuZXh0RWwiLCJwcmV2RWwiLCJvblJlc2l6ZSIsInNldEJyZWFrcG9pbnQiLCJpc1ZpcnR1YWxMb29wIiwiYXV0b3BsYXkiLCJydW5uaW5nIiwicGF1c2VkIiwiY2xlYXJUaW1lb3V0IiwicmVzaXplVGltZW91dCIsInJlc3VtZSIsIm9uQ2xpY2siLCJwcmV2ZW50Q2xpY2tzIiwicHJldmVudENsaWNrc1Byb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwib25TY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25Mb2FkIiwib25Eb2N1bWVudFRvdWNoU3RhcnQiLCJkb2N1bWVudFRvdWNoSGFuZGxlclByb2NlZWRlZCIsInRvdWNoQWN0aW9uIiwiY2FwdHVyZSIsImRvbU1ldGhvZCIsInN3aXBlck1ldGhvZCIsInBhc3NpdmUiLCJ1cGRhdGVPbldpbmRvd1Jlc2l6ZSIsImF0dGFjaEV2ZW50cyIsImJpbmQiLCJkZXRhY2hFdmVudHMiLCJldmVudHMkMSIsImlzR3JpZEVuYWJsZWQiLCJicmVha3BvaW50IiwiZ2V0QnJlYWtwb2ludCIsImJyZWFrcG9pbnRzQmFzZSIsImN1cnJlbnRCcmVha3BvaW50IiwiYnJlYWtwb2ludE9ubHlQYXJhbXMiLCJicmVha3BvaW50UGFyYW1zIiwib3JpZ2luYWxQYXJhbXMiLCJ3YXNNdWx0aVJvdyIsImlzTXVsdGlSb3ciLCJ3YXNFbmFibGVkIiwiZW1pdENvbnRhaW5lckNsYXNzZXMiLCJwcm9wIiwid2FzTW9kdWxlRW5hYmxlZCIsImlzTW9kdWxlRW5hYmxlZCIsImRpc2FibGUiLCJlbmFibGUiLCJkaXJlY3Rpb25DaGFuZ2VkIiwibmVlZHNSZUxvb3AiLCJ3YXNMb29wIiwiY2hhbmdlRGlyZWN0aW9uIiwiaXNFbmFibGVkIiwiaGFzTG9vcCIsImNvbnRhaW5lckVsIiwiY3VycmVudEhlaWdodCIsImlubmVySGVpZ2h0IiwicG9pbnRzIiwicG9pbnQiLCJtaW5SYXRpbyIsInN1YnN0ciIsInZhbHVlIiwic29ydCIsImIiLCJtYXRjaE1lZGlhIiwicHJlcGFyZUNsYXNzZXMiLCJwcmVmaXgiLCJyZXN1bHRDbGFzc2VzIiwiaXRlbSIsImNsYXNzTmFtZXMiLCJhZGRDbGFzc2VzIiwic3VmZml4ZXMiLCJyZW1vdmVDbGFzc2VzIiwiY2xhc3NlcyIsIndhc0xvY2tlZCIsImxhc3RTbGlkZVJpZ2h0RWRnZSIsImNoZWNrT3ZlcmZsb3ckMSIsImRlZmF1bHRzIiwiY3JlYXRlRWxlbWVudHMiLCJldmVudHNQcmVmaXgiLCJ1cmwiLCJ1bmlxdWVOYXZFbGVtZW50cyIsInBhc3NpdmVMaXN0ZW5lcnMiLCJ3cmFwcGVyQ2xhc3MiLCJfZW1pdENsYXNzZXMiLCJtb2R1bGVFeHRlbmRQYXJhbXMiLCJhbGxNb2R1bGVzUGFyYW1zIiwib2JqIiwibW9kdWxlUGFyYW1OYW1lIiwibW9kdWxlUGFyYW1zIiwiYXV0byIsInByb3RvdHlwZXMiLCJleHRlbmRlZERlZmF1bHRzIiwiU3dpcGVyIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJxdWVyeVNlbGVjdG9yQWxsIiwic3dpcGVycyIsIm5ld1BhcmFtcyIsIl9fc3dpcGVyX18iLCJtb2R1bGVzIiwiX19tb2R1bGVzX18iLCJtb2QiLCJzd2lwZXJQYXJhbXMiLCJwYXNzZWRQYXJhbXMiLCJldmVudE5hbWUiLCJ2ZWxvY2l0eSIsInRydW5jIiwiY2xpY2tUaW1lb3V0IiwidmVsb2NpdGllcyIsImltYWdlc1RvTG9hZCIsImltYWdlc0xvYWRlZCIsInByb3BlcnR5Iiwic2V0UHJvZ3Jlc3MiLCJjdXJyZW50IiwiY2xzIiwiY2xhc3NOYW1lIiwiam9pbiIsImdldFNsaWRlQ2xhc3NlcyIsInVwZGF0ZXMiLCJ2aWV3IiwiZXhhY3QiLCJzcHYiLCJicmVha0xvb3AiLCJzbGlkZUluVmlldyIsImNvbXBsZXRlIiwidHJhbnNsYXRlVmFsdWUiLCJ0cmFuc2xhdGVkIiwibmV3RGlyZWN0aW9uIiwibmVlZFVwZGF0ZSIsImN1cnJlbnREaXJlY3Rpb24iLCJjaGFuZ2VMYW5ndWFnZURpcmVjdGlvbiIsIm1vdW50IiwiZWxlbWVudCIsIm1vdW50ZWQiLCJwYXJlbnROb2RlIiwiZ2V0V3JhcHBlclNlbGVjdG9yIiwidHJpbSIsImdldFdyYXBwZXIiLCJyZXMiLCJzbGlkZVNsb3RzIiwibGF6eUVsZW1lbnRzIiwiZGVsZXRlSW5zdGFuY2UiLCJjbGVhblN0eWxlcyIsImV4dGVuZERlZmF1bHRzIiwibmV3RGVmYXVsdHMiLCJpbnN0YWxsTW9kdWxlIiwidXNlIiwibW9kdWxlIiwicHJvdG90eXBlR3JvdXAiLCJwcm90b01ldGhvZCIsIlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/swiper-core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/swiper/shared/update-on-virtual-data.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ getChangedParams),\n/* harmony export */   g: () => (/* binding */ getParams),\n/* harmony export */   m: () => (/* binding */ mountSwiper),\n/* harmony export */   u: () => (/* binding */ updateOnVirtualData)\n/* harmony export */ });\n/* harmony import */ var _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./update-swiper.mjs */ \"(ssr)/./node_modules/swiper/shared/update-swiper.mjs\");\n/* harmony import */ var _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./swiper-core.mjs */ \"(ssr)/./node_modules/swiper/shared/swiper-core.mjs\");\n\n\nfunction getParams(obj, splitEvents) {\n    if (obj === void 0) {\n        obj = {};\n    }\n    if (splitEvents === void 0) {\n        splitEvents = true;\n    }\n    const params = {\n        on: {}\n    };\n    const events = {};\n    const passedParams = {};\n    (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params, _swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.d);\n    params._emitClasses = true;\n    params.init = false;\n    const rest = {};\n    const allowedParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.map((key)=>key.replace(/_/, \"\"));\n    const plainObj = Object.assign({}, obj);\n    Object.keys(plainObj).forEach((key)=>{\n        if (typeof obj[key] === \"undefined\") return;\n        if (allowedParams.indexOf(key) >= 0) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(obj[key])) {\n                params[key] = {};\n                passedParams[key] = {};\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(params[key], obj[key]);\n                (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(passedParams[key], obj[key]);\n            } else {\n                params[key] = obj[key];\n                passedParams[key] = obj[key];\n            }\n        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === \"function\") {\n            if (splitEvents) {\n                events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n            } else {\n                params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n            }\n        } else {\n            rest[key] = obj[key];\n        }\n    });\n    [\n        \"navigation\",\n        \"pagination\",\n        \"scrollbar\"\n    ].forEach((key)=>{\n        if (params[key] === true) params[key] = {};\n        if (params[key] === false) delete params[key];\n    });\n    return {\n        params,\n        passedParams,\n        rest,\n        events\n    };\n}\nfunction mountSwiper(_ref, swiperParams) {\n    let { el, nextEl, prevEl, paginationEl, scrollbarEl, swiper } = _ref;\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(swiperParams) && nextEl && prevEl) {\n        swiper.params.navigation.nextEl = nextEl;\n        swiper.originalParams.navigation.nextEl = nextEl;\n        swiper.params.navigation.prevEl = prevEl;\n        swiper.originalParams.navigation.prevEl = prevEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(swiperParams) && paginationEl) {\n        swiper.params.pagination.el = paginationEl;\n        swiper.originalParams.pagination.el = paginationEl;\n    }\n    if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(swiperParams) && scrollbarEl) {\n        swiper.params.scrollbar.el = scrollbarEl;\n        swiper.originalParams.scrollbar.el = scrollbarEl;\n    }\n    swiper.init(el);\n}\nfunction getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {\n    const keys = [];\n    if (!oldParams) return keys;\n    const addKey = (key)=>{\n        if (keys.indexOf(key) < 0) keys.push(key);\n    };\n    if (children && oldChildren) {\n        const oldChildrenKeys = oldChildren.map(getKey);\n        const childrenKeys = children.map(getKey);\n        if (oldChildrenKeys.join(\"\") !== childrenKeys.join(\"\")) addKey(\"children\");\n        if (oldChildren.length !== children.length) addKey(\"children\");\n    }\n    const watchParams = _update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.p.filter((key)=>key[0] === \"_\").map((key)=>key.replace(/_/, \"\"));\n    watchParams.forEach((key)=>{\n        if (key in swiperParams && key in oldParams) {\n            if ((0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(swiperParams[key]) && (0,_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(oldParams[key])) {\n                const newKeys = Object.keys(swiperParams[key]);\n                const oldKeys = Object.keys(oldParams[key]);\n                if (newKeys.length !== oldKeys.length) {\n                    addKey(key);\n                } else {\n                    newKeys.forEach((newKey)=>{\n                        if (swiperParams[key][newKey] !== oldParams[key][newKey]) {\n                            addKey(key);\n                        }\n                    });\n                    oldKeys.forEach((oldKey)=>{\n                        if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);\n                    });\n                }\n            } else if (swiperParams[key] !== oldParams[key]) {\n                addKey(key);\n            }\n        }\n    });\n    return keys;\n}\nconst updateOnVirtualData = (swiper)=>{\n    if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {\n        swiper.parallax.setTranslate();\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtb24tdmlydHVhbC1kYXRhLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBbUo7QUFDakc7QUFFbEQsU0FBU2MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLElBQUlELFFBQVEsS0FBSyxHQUFHO1FBQ2xCQSxNQUFNLENBQUM7SUFDVDtJQUNBLElBQUlDLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWM7SUFDaEI7SUFDQSxNQUFNQyxTQUFTO1FBQ2JDLElBQUksQ0FBQztJQUNQO0lBQ0EsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLE1BQU1DLGVBQWUsQ0FBQztJQUN0Qm5CLHFEQUFNQSxDQUFDZ0IsUUFBUUosK0NBQVFBO0lBQ3ZCSSxPQUFPSSxZQUFZLEdBQUc7SUFDdEJKLE9BQU9LLElBQUksR0FBRztJQUNkLE1BQU1DLE9BQU8sQ0FBQztJQUNkLE1BQU1DLGdCQUFnQnJCLGlEQUFVQSxDQUFDc0IsR0FBRyxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJQyxPQUFPLENBQUMsS0FBSztJQUM3RCxNQUFNQyxXQUFXQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHZjtJQUNuQ2MsT0FBT0UsSUFBSSxDQUFDSCxVQUFVSSxPQUFPLENBQUNOLENBQUFBO1FBQzVCLElBQUksT0FBT1gsR0FBRyxDQUFDVyxJQUFJLEtBQUssYUFBYTtRQUNyQyxJQUFJRixjQUFjUyxPQUFPLENBQUNQLFFBQVEsR0FBRztZQUNuQyxJQUFJckIscURBQVFBLENBQUNVLEdBQUcsQ0FBQ1csSUFBSSxHQUFHO2dCQUN0QlQsTUFBTSxDQUFDUyxJQUFJLEdBQUcsQ0FBQztnQkFDZk4sWUFBWSxDQUFDTSxJQUFJLEdBQUcsQ0FBQztnQkFDckJ6QixxREFBTUEsQ0FBQ2dCLE1BQU0sQ0FBQ1MsSUFBSSxFQUFFWCxHQUFHLENBQUNXLElBQUk7Z0JBQzVCekIscURBQU1BLENBQUNtQixZQUFZLENBQUNNLElBQUksRUFBRVgs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LE9BQU9LO0FBQ1Q7QUFFQSxNQUFNb0Msc0JBQXNCdEIsQ0FBQUE7SUFDMUIsSUFBSSxDQUFDQSxVQUFVQSxPQUFPdUIsU0FBUyxJQUFJLENBQUN2QixPQUFPNUIsTUFBTSxDQUFDb0QsT0FBTyxJQUFJeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sSUFBSSxDQUFDeEIsT0FBTzVCLE1BQU0sQ0FBQ29ELE9BQU8sQ0FBQ0MsT0FBTyxFQUFFO0lBQ3RIekIsT0FBTzBCLFlBQVk7SUFDbkIxQixPQUFPMkIsY0FBYztJQUNyQjNCLE9BQU80QixtQkFBbUI7SUFDMUIsSUFBSTVCLE9BQU82QixRQUFRLElBQUk3QixPQUFPNUIsTUFBTSxDQUFDeUQsUUFBUSxJQUFJN0IsT0FBTzVCLE1BQU0sQ0FBQ3lELFFBQVEsQ0FBQ0osT0FBTyxFQUFFO1FBQy9FekIsT0FBTzZCLFFBQVEsQ0FBQ0MsWUFBWTtJQUM5QjtBQUNGO0FBRTZGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGlhZ29uYWxzLy4vbm9kZV9tb2R1bGVzL3N3aXBlci9zaGFyZWQvdXBkYXRlLW9uLXZpcnR1YWwtZGF0YS5tanM/ZTk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlIGFzIGV4dGVuZCwgcCBhcyBwYXJhbXNMaXN0LCBpIGFzIGlzT2JqZWN0LCBuIGFzIG5lZWRzTmF2aWdhdGlvbiwgYSBhcyBuZWVkc1BhZ2luYXRpb24sIGIgYXMgbmVlZHNTY3JvbGxiYXIgfSBmcm9tICcuL3VwZGF0ZS1zd2lwZXIubWpzJztcbmltcG9ydCB7IGQgYXMgZGVmYXVsdHMgfSBmcm9tICcuL3N3aXBlci1jb3JlLm1qcyc7XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhvYmosIHNwbGl0RXZlbnRzKSB7XG4gIGlmIChvYmogPT09IHZvaWQgMCkge1xuICAgIG9iaiA9IHt9O1xuICB9XG4gIGlmIChzcGxpdEV2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgc3BsaXRFdmVudHMgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBvbjoge31cbiAgfTtcbiAgY29uc3QgZXZlbnRzID0ge307XG4gIGNvbnN0IHBhc3NlZFBhcmFtcyA9IHt9O1xuICBleHRlbmQocGFyYW1zLCBkZWZhdWx0cyk7XG4gIHBhcmFtcy5fZW1pdENsYXNzZXMgPSB0cnVlO1xuICBwYXJhbXMuaW5pdCA9IGZhbHNlO1xuICBjb25zdCByZXN0ID0ge307XG4gIGNvbnN0IGFsbG93ZWRQYXJhbXMgPSBwYXJhbXNMaXN0Lm1hcChrZXkgPT4ga2V5LnJlcGxhY2UoL18vLCAnJykpO1xuICBjb25zdCBwbGFpbk9iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gIE9iamVjdC5rZXlzKHBsYWluT2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBpZiAoYWxsb3dlZFBhcmFtcy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialtrZXldKSkge1xuICAgICAgICBwYXJhbXNba2V5XSA9IHt9O1xuICAgICAgICBwYXNzZWRQYXJhbXNba2V5XSA9IHt9O1xuICAgICAgICBleHRlbmQocGFyYW1zW2tleV0sIG9ialtrZXldKTtcbiAgICAgICAgZXh0ZW5kKHBhc3NlZFBhcmFtc1trZXldLCBvYmpba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBwYXNzZWRQYXJhbXNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5LnNlYXJjaCgvb25bQS1aXS8pID09PSAwICYmIHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHNwbGl0RXZlbnRzKSB7XG4gICAgICAgIGV2ZW50c1tgJHtrZXlbMl0udG9Mb3dlckNhc2UoKX0ke2tleS5zdWJzdHIoMyl9YF0gPSBvYmpba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcy5vbltgJHtrZXlbMl0udG9Mb3dlckNhc2UoKX0ke2tleS5zdWJzdHIoMyl9YF0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9KTtcbiAgWyduYXZpZ2F0aW9uJywgJ3BhZ2luYXRpb24nLCAnc2Nyb2xsYmFyJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChwYXJhbXNba2V5XSA9PT0gdHJ1ZSkgcGFyYW1zW2tleV0gPSB7fTtcbiAgICBpZiAocGFyYW1zW2tleV0gPT09IGZhbHNlKSBkZWxldGUgcGFyYW1zW2tleV07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHBhcmFtcyxcbiAgICBwYXNzZWRQYXJhbXMsXG4gICAgcmVzdCxcbiAgICBldmVudHNcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRTd2lwZXIoX3JlZiwgc3dpcGVyUGFyYW1zKSB7XG4gIGxldCB7XG4gICAgZWwsXG4gICAgbmV4dEVsLFxuICAgIHByZXZFbCxcbiAgICBwYWdpbmF0aW9uRWwsXG4gICAgc2Nyb2xsYmFyRWwsXG4gICAgc3dpcGVyXG4gIH0gPSBfcmVmO1xuICBpZiAobmVlZHNOYXZpZ2F0aW9uKHN3aXBlclBhcmFtcykgJiYgbmV4dEVsICYmIHByZXZFbCkge1xuICAgIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgPSBuZXh0RWw7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLm5hdmlnYXRpb24ubmV4dEVsID0gbmV4dEVsO1xuICAgIHN3aXBlci5wYXJhbXMubmF2aWdhdGlvbi5wcmV2RWwgPSBwcmV2RWw7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLm5hdmlnYXRpb24ucHJldkVsID0gcHJldkVsO1xuICB9XG4gIGlmIChuZWVkc1BhZ2luYXRpb24oc3dpcGVyUGFyYW1zKSAmJiBwYWdpbmF0aW9uRWwpIHtcbiAgICBzd2lwZXIucGFyYW1zLnBhZ2luYXRpb24uZWwgPSBwYWdpbmF0aW9uRWw7XG4gICAgc3dpcGVyLm9yaWdpbmFsUGFyYW1zLnBhZ2luYXRpb24uZWwgPSBwYWdpbmF0aW9uRWw7XG4gIH1cbiAgaWYgKG5lZWRzU2Nyb2xsYmFyKHN3aXBlclBhcmFtcykgJiYgc2Nyb2xsYmFyRWwpIHtcbiAgICBzd2lwZXIucGFyYW1zLnNjcm9sbGJhci5lbCA9IHNjcm9sbGJhckVsO1xuICAgIHN3aXBlci5vcmlnaW5hbFBhcmFtcy5zY3JvbGxiYXIuZWwgPSBzY3JvbGxiYXJFbDtcbiAgfVxuICBzd2lwZXIuaW5pdChlbCk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5nZWRQYXJhbXMoc3dpcGVyUGFyYW1zLCBvbGRQYXJhbXMsIGNoaWxkcmVuLCBvbGRDaGlsZHJlbiwgZ2V0S2V5KSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgaWYgKCFvbGRQYXJhbXMpIHJldHVybiBrZXlzO1xuICBjb25zdCBhZGRLZXkgPSBrZXkgPT4ge1xuICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA8IDApIGtleXMucHVzaChrZXkpO1xuICB9O1xuICBpZiAoY2hpbGRyZW4gJiYgb2xkQ2hpbGRyZW4pIHtcbiAgICBjb25zdCBvbGRDaGlsZHJlbktleXMgPSBvbGRDaGlsZHJlbi5tYXAoZ2V0S2V5KTtcbiAgICBjb25zdCBjaGlsZHJlbktleXMgPSBjaGlsZHJlbi5tYXAoZ2V0S2V5KTtcbiAgICBpZiAob2xkQ2hpbGRyZW5LZXlzLmpvaW4oJycpICE9PSBjaGlsZHJlbktleXMuam9pbignJykpIGFkZEtleSgnY2hpbGRyZW4nKTtcbiAgICBpZiAob2xkQ2hpbGRyZW4ubGVuZ3RoICE9PSBjaGlsZHJlbi5sZW5ndGgpIGFkZEtleSgnY2hpbGRyZW4nKTtcbiAgfVxuICBjb25zdCB3YXRjaFBhcmFtcyA9IHBhcmFtc0xpc3QuZmlsdGVyKGtleSA9PiBrZXlbMF0gPT09ICdfJykubWFwKGtleSA9PiBrZXkucmVwbGFjZSgvXy8sICcnKSk7XG4gIHdhdGNoUGFyYW1zLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoa2V5IGluIHN3aXBlclBhcmFtcyAmJiBrZXkgaW4gb2xkUGFyYW1zKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoc3dpcGVyUGFyYW1zW2tleV0pICYmIGlzT2JqZWN0KG9sZFBhcmFtc1trZXldKSkge1xuICAgICAgICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMoc3dpcGVyUGFyYW1zW2tleV0pO1xuICAgICAgICBjb25zdCBvbGRLZXlzID0gT2JqZWN0LmtleXMob2xkUGFyYW1zW2tleV0pO1xuICAgICAgICBpZiAobmV3S2V5cy5sZW5ndGggIT09IG9sZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgYWRkS2V5KGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3S2V5cy5mb3JFYWNoKG5ld0tleSA9PiB7XG4gICAgICAgICAgICBpZiAoc3dpcGVyUGFyYW1zW2tleV1bbmV3S2V5XSAhPT0gb2xkUGFyYW1zW2tleV1bbmV3S2V5XSkge1xuICAgICAgICAgICAgICBhZGRLZXkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbGRLZXlzLmZvckVhY2gob2xkS2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChzd2lwZXJQYXJhbXNba2V5XVtvbGRLZXldICE9PSBvbGRQYXJhbXNba2V5XVtvbGRLZXldKSBhZGRLZXkoa2V5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzd2lwZXJQYXJhbXNba2V5XSAhPT0gb2xkUGFyYW1zW2tleV0pIHtcbiAgICAgICAgYWRkS2V5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IHVwZGF0ZU9uVmlydHVhbERhdGEgPSBzd2lwZXIgPT4ge1xuICBpZiAoIXN3aXBlciB8fCBzd2lwZXIuZGVzdHJveWVkIHx8ICFzd2lwZXIucGFyYW1zLnZpcnR1YWwgfHwgc3dpcGVyLnBhcmFtcy52aXJ0dWFsICYmICFzd2lwZXIucGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkgcmV0dXJuO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzKCk7XG4gIHN3aXBlci51cGRhdGVQcm9ncmVzcygpO1xuICBzd2lwZXIudXBkYXRlU2xpZGVzQ2xhc3NlcygpO1xuICBpZiAoc3dpcGVyLnBhcmFsbGF4ICYmIHN3aXBlci5wYXJhbXMucGFyYWxsYXggJiYgc3dpcGVyLnBhcmFtcy5wYXJhbGxheC5lbmFibGVkKSB7XG4gICAgc3dpcGVyLnBhcmFsbGF4LnNldFRyYW5zbGF0ZSgpO1xuICB9XG59O1xuXG5leHBvcnQgeyBnZXRDaGFuZ2VkUGFyYW1zIGFzIGEsIGdldFBhcmFtcyBhcyBnLCBtb3VudFN3aXBlciBhcyBtLCB1cGRhdGVPblZpcnR1YWxEYXRhIGFzIHUgfTtcbiJdLCJuYW1lcyI6WyJlIiwiZXh0ZW5kIiwicCIsInBhcmFtc0xpc3QiLCJpIiwiaXNPYmplY3QiLCJuIiwibmVlZHNOYXZpZ2F0aW9uIiwiYSIsIm5lZWRzUGFnaW5hdGlvbiIsImIiLCJuZWVkc1Njcm9sbGJhciIsImQiLCJkZWZhdWx0cyIsImdldFBhcmFtcyIsIm9iaiIsInNwbGl0RXZlbnRzIiwicGFyYW1zIiwib24iLCJldmVudHMiLCJwYXNzZWRQYXJhbXMiLCJfZW1pdENsYXNzZXMiLCJpbml0IiwicmVzdCIsImFsbG93ZWRQYXJhbXMiLCJtYXAiLCJrZXkiLCJyZXBsYWNlIiwicGxhaW5PYmoiLCJPYmplY3QiLCJhc3NpZ24iLCJrZXlzIiwiZm9yRWFjaCIsImluZGV4T2YiLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsInN1YnN0ciIsIm1vdW50U3dpcGVyIiwiX3JlZiIsInN3aXBlclBhcmFtcyIsImVsIiwibmV4dEVsIiwicHJldkVsIiwicGFnaW5hdGlvbkVsIiwic2Nyb2xsYmFyRWwiLCJzd2lwZXIiLCJuYXZpZ2F0aW9uIiwib3JpZ2luYWxQYXJhbXMiLCJwYWdpbmF0aW9uIiwic2Nyb2xsYmFyIiwiZ2V0Q2hhbmdlZFBhcmFtcyIsIm9sZFBhcmFtcyIsImNoaWxkcmVuIiwib2xkQ2hpbGRyZW4iLCJnZXRLZXkiLCJhZGRLZXkiLCJwdXNoIiwib2xkQ2hpbGRyZW5LZXlzIiwiY2hpbGRyZW5LZXlzIiwiam9pbiIsImxlbmd0aCIsIndhdGNoUGFyYW1zIiwiZmlsdGVyIiwibmV3S2V5cyIsIm9sZEtleXMiLCJuZXdLZXkiLCJvbGRLZXkiLCJ1cGRhdGVPblZpcnR1YWxEYXRhIiwiZGVzdHJveWVkIiwidmlydHVhbCIsImVuYWJsZWQiLCJ1cGRhdGVTbGlkZXMiLCJ1cGRhdGVQcm9ncmVzcyIsInVwZGF0ZVNsaWRlc0NsYXNzZXMiLCJwYXJhbGxheCIsInNldFRyYW5zbGF0ZSIsImciLCJtIiwidSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/update-swiper.mjs":
/*!******************************************************!*\
  !*** ./node_modules/swiper/shared/update-swiper.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ needsPagination),\n/* harmony export */   b: () => (/* binding */ needsScrollbar),\n/* harmony export */   c: () => (/* binding */ attrToProp),\n/* harmony export */   d: () => (/* binding */ uniqueClasses),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   n: () => (/* binding */ needsNavigation),\n/* harmony export */   p: () => (/* binding */ paramsList),\n/* harmony export */   u: () => (/* binding */ updateSwiper),\n/* harmony export */   w: () => (/* binding */ wrapperClass)\n/* harmony export */ });\n/* underscore in name -> watch for changes */ const paramsList = [\n    \"eventsPrefix\",\n    \"injectStyles\",\n    \"injectStylesUrls\",\n    \"modules\",\n    \"init\",\n    \"_direction\",\n    \"oneWayMovement\",\n    \"touchEventsTarget\",\n    \"initialSlide\",\n    \"_speed\",\n    \"cssMode\",\n    \"updateOnWindowResize\",\n    \"resizeObserver\",\n    \"nested\",\n    \"focusableElements\",\n    \"_enabled\",\n    \"_width\",\n    \"_height\",\n    \"preventInteractionOnTransition\",\n    \"userAgent\",\n    \"url\",\n    \"_edgeSwipeDetection\",\n    \"_edgeSwipeThreshold\",\n    \"_freeMode\",\n    \"_autoHeight\",\n    \"setWrapperSize\",\n    \"virtualTranslate\",\n    \"_effect\",\n    \"breakpoints\",\n    \"breakpointsBase\",\n    \"_spaceBetween\",\n    \"_slidesPerView\",\n    \"maxBackfaceHiddenSlides\",\n    \"_grid\",\n    \"_slidesPerGroup\",\n    \"_slidesPerGroupSkip\",\n    \"_slidesPerGroupAuto\",\n    \"_centeredSlides\",\n    \"_centeredSlidesBounds\",\n    \"_slidesOffsetBefore\",\n    \"_slidesOffsetAfter\",\n    \"normalizeSlideIndex\",\n    \"_centerInsufficientSlides\",\n    \"_watchOverflow\",\n    \"roundLengths\",\n    \"touchRatio\",\n    \"touchAngle\",\n    \"simulateTouch\",\n    \"_shortSwipes\",\n    \"_longSwipes\",\n    \"longSwipesRatio\",\n    \"longSwipesMs\",\n    \"_followFinger\",\n    \"allowTouchMove\",\n    \"_threshold\",\n    \"touchMoveStopPropagation\",\n    \"touchStartPreventDefault\",\n    \"touchStartForcePreventDefault\",\n    \"touchReleaseOnEdges\",\n    \"uniqueNavElements\",\n    \"_resistance\",\n    \"_resistanceRatio\",\n    \"_watchSlidesProgress\",\n    \"_grabCursor\",\n    \"preventClicks\",\n    \"preventClicksPropagation\",\n    \"_slideToClickedSlide\",\n    \"_loop\",\n    \"loopAdditionalSlides\",\n    \"loopAddBlankSlides\",\n    \"loopPreventsSliding\",\n    \"_rewind\",\n    \"_allowSlidePrev\",\n    \"_allowSlideNext\",\n    \"_swipeHandler\",\n    \"_noSwiping\",\n    \"noSwipingClass\",\n    \"noSwipingSelector\",\n    \"passiveListeners\",\n    \"containerModifierClass\",\n    \"slideClass\",\n    \"slideActiveClass\",\n    \"slideVisibleClass\",\n    \"slideFullyVisibleClass\",\n    \"slideNextClass\",\n    \"slidePrevClass\",\n    \"slideBlankClass\",\n    \"wrapperClass\",\n    \"lazyPreloaderClass\",\n    \"lazyPreloadPrevNext\",\n    \"runCallbacksOnInit\",\n    \"observer\",\n    \"observeParents\",\n    \"observeSlideChildren\",\n    // modules\n    \"a11y\",\n    \"_autoplay\",\n    \"_controller\",\n    \"coverflowEffect\",\n    \"cubeEffect\",\n    \"fadeEffect\",\n    \"flipEffect\",\n    \"creativeEffect\",\n    \"cardsEffect\",\n    \"hashNavigation\",\n    \"history\",\n    \"keyboard\",\n    \"mousewheel\",\n    \"_navigation\",\n    \"_pagination\",\n    \"parallax\",\n    \"_scrollbar\",\n    \"_thumbs\",\n    \"virtual\",\n    \"zoom\",\n    \"control\"\n];\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\" && !o.__swiper__;\n}\nfunction extend(target, src) {\n    const noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    Object.keys(src).filter((key)=>noExtend.indexOf(key) < 0).forEach((key)=>{\n        if (typeof target[key] === \"undefined\") target[key] = src[key];\n        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n            if (src[key].__swiper__) target[key] = src[key];\n            else extend(target[key], src[key]);\n        } else {\n            target[key] = src[key];\n        }\n    });\n}\nfunction needsNavigation(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.navigation && typeof params.navigation.nextEl === \"undefined\" && typeof params.navigation.prevEl === \"undefined\";\n}\nfunction needsPagination(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.pagination && typeof params.pagination.el === \"undefined\";\n}\nfunction needsScrollbar(params) {\n    if (params === void 0) {\n        params = {};\n    }\n    return params.scrollbar && typeof params.scrollbar.el === \"undefined\";\n}\nfunction uniqueClasses(classNames) {\n    if (classNames === void 0) {\n        classNames = \"\";\n    }\n    const classes = classNames.split(\" \").map((c)=>c.trim()).filter((c)=>!!c);\n    const unique = [];\n    classes.forEach((c)=>{\n        if (unique.indexOf(c) < 0) unique.push(c);\n    });\n    return unique.join(\" \");\n}\nfunction attrToProp(attrName) {\n    if (attrName === void 0) {\n        attrName = \"\";\n    }\n    return attrName.replace(/-[a-z]/g, (l)=>l.toUpperCase().replace(\"-\", \"\"));\n}\nfunction wrapperClass(className) {\n    if (className === void 0) {\n        className = \"\";\n    }\n    if (!className) return \"swiper-wrapper\";\n    if (!className.includes(\"swiper-wrapper\")) return `swiper-wrapper ${className}`;\n    return className;\n}\nfunction updateSwiper(_ref) {\n    let { swiper, slides, passedParams, changedParams, nextEl, prevEl, scrollbarEl, paginationEl } = _ref;\n    const updateParams = changedParams.filter((key)=>key !== \"children\" && key !== \"direction\" && key !== \"wrapperClass\");\n    const { params: currentParams, pagination, navigation, scrollbar, virtual, thumbs } = swiper;\n    let needThumbsInit;\n    let needControllerInit;\n    let needPaginationInit;\n    let needScrollbarInit;\n    let needNavigationInit;\n    let loopNeedDestroy;\n    let loopNeedEnable;\n    let loopNeedReloop;\n    if (changedParams.includes(\"thumbs\") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {\n        needThumbsInit = true;\n    }\n    if (changedParams.includes(\"controller\") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {\n        needControllerInit = true;\n    }\n    if (changedParams.includes(\"pagination\") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {\n        needPaginationInit = true;\n    }\n    if (changedParams.includes(\"scrollbar\") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {\n        needScrollbarInit = true;\n    }\n    if (changedParams.includes(\"navigation\") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {\n        needNavigationInit = true;\n    }\n    const destroyModule = (mod)=>{\n        if (!swiper[mod]) return;\n        swiper[mod].destroy();\n        if (mod === \"navigation\") {\n            if (swiper.isElement) {\n                swiper[mod].prevEl.remove();\n                swiper[mod].nextEl.remove();\n            }\n            currentParams[mod].prevEl = undefined;\n            currentParams[mod].nextEl = undefined;\n            swiper[mod].prevEl = undefined;\n            swiper[mod].nextEl = undefined;\n        } else {\n            if (swiper.isElement) {\n                swiper[mod].el.remove();\n            }\n            currentParams[mod].el = undefined;\n            swiper[mod].el = undefined;\n        }\n    };\n    if (changedParams.includes(\"loop\") && swiper.isElement) {\n        if (currentParams.loop && !passedParams.loop) {\n            loopNeedDestroy = true;\n        } else if (!currentParams.loop && passedParams.loop) {\n            loopNeedEnable = true;\n        } else {\n            loopNeedReloop = true;\n        }\n    }\n    updateParams.forEach((key)=>{\n        if (isObject(currentParams[key]) && isObject(passedParams[key])) {\n            Object.assign(currentParams[key], passedParams[key]);\n            if ((key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\") && \"enabled\" in passedParams[key] && !passedParams[key].enabled) {\n                destroyModule(key);\n            }\n        } else {\n            const newValue = passedParams[key];\n            if ((newValue === true || newValue === false) && (key === \"navigation\" || key === \"pagination\" || key === \"scrollbar\")) {\n                if (newValue === false) {\n                    destroyModule(key);\n                }\n            } else {\n                currentParams[key] = passedParams[key];\n            }\n        }\n    });\n    if (updateParams.includes(\"controller\") && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (changedParams.includes(\"children\") && slides && virtual && currentParams.virtual.enabled) {\n        virtual.slides = slides;\n        virtual.update(true);\n    } else if (changedParams.includes(\"virtual\") && virtual && currentParams.virtual.enabled) {\n        if (slides) virtual.slides = slides;\n        virtual.update(true);\n    }\n    if (changedParams.includes(\"children\") && slides && currentParams.loop) {\n        loopNeedReloop = true;\n    }\n    if (needThumbsInit) {\n        const initialized = thumbs.init();\n        if (initialized) thumbs.update(true);\n    }\n    if (needControllerInit) {\n        swiper.controller.control = currentParams.controller.control;\n    }\n    if (needPaginationInit) {\n        if (swiper.isElement && (!paginationEl || typeof paginationEl === \"string\")) {\n            paginationEl = document.createElement(\"div\");\n            paginationEl.classList.add(\"swiper-pagination\");\n            paginationEl.part.add(\"pagination\");\n            swiper.el.appendChild(paginationEl);\n        }\n        if (paginationEl) currentParams.pagination.el = paginationEl;\n        pagination.init();\n        pagination.render();\n        pagination.update();\n    }\n    if (needScrollbarInit) {\n        if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === \"string\")) {\n            scrollbarEl = document.createElement(\"div\");\n            scrollbarEl.classList.add(\"swiper-scrollbar\");\n            scrollbarEl.part.add(\"scrollbar\");\n            swiper.el.appendChild(scrollbarEl);\n        }\n        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;\n        scrollbar.init();\n        scrollbar.updateSize();\n        scrollbar.setTranslate();\n    }\n    if (needNavigationInit) {\n        if (swiper.isElement) {\n            if (!nextEl || typeof nextEl === \"string\") {\n                nextEl = document.createElement(\"div\");\n                nextEl.classList.add(\"swiper-button-next\");\n                nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;\n                nextEl.part.add(\"button-next\");\n                swiper.el.appendChild(nextEl);\n            }\n            if (!prevEl || typeof prevEl === \"string\") {\n                prevEl = document.createElement(\"div\");\n                prevEl.classList.add(\"swiper-button-prev\");\n                prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;\n                prevEl.part.add(\"button-prev\");\n                swiper.el.appendChild(prevEl);\n            }\n        }\n        if (nextEl) currentParams.navigation.nextEl = nextEl;\n        if (prevEl) currentParams.navigation.prevEl = prevEl;\n        navigation.init();\n        navigation.update();\n    }\n    if (changedParams.includes(\"allowSlideNext\")) {\n        swiper.allowSlideNext = passedParams.allowSlideNext;\n    }\n    if (changedParams.includes(\"allowSlidePrev\")) {\n        swiper.allowSlidePrev = passedParams.allowSlidePrev;\n    }\n    if (changedParams.includes(\"direction\")) {\n        swiper.changeDirection(passedParams.direction, false);\n    }\n    if (loopNeedDestroy || loopNeedReloop) {\n        swiper.loopDestroy();\n    }\n    if (loopNeedEnable || loopNeedReloop) {\n        swiper.loopCreate();\n    }\n    swiper.update();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDLEdBQzNDLE1BQU1BLGFBQWE7SUFBQztJQUFnQjtJQUFnQjtJQUFvQjtJQUFXO0lBQVE7SUFBYztJQUFrQjtJQUFxQjtJQUFnQjtJQUFVO0lBQVc7SUFBd0I7SUFBa0I7SUFBVTtJQUFxQjtJQUFZO0lBQVU7SUFBVztJQUFrQztJQUFhO0lBQU87SUFBdUI7SUFBdUI7SUFBYTtJQUFlO0lBQWtCO0lBQW9CO0lBQVc7SUFBZTtJQUFtQjtJQUFpQjtJQUFrQjtJQUEyQjtJQUFTO0lBQW1CO0lBQXVCO0lBQXVCO0lBQW1CO0lBQXlCO0lBQXVCO0lBQXNCO0lBQXVCO0lBQTZCO0lBQWtCO0lBQWdCO0lBQWM7SUFBYztJQUFpQjtJQUFnQjtJQUFlO0lBQW1CO0lBQWdCO0lBQWlCO0lBQWtCO0lBQWM7SUFBNEI7SUFBNEI7SUFBaUM7SUFBdUI7SUFBcUI7SUFBZTtJQUFvQjtJQUF3QjtJQUFlO0lBQWlCO0lBQTRCO0lBQXdCO0lBQVM7SUFBd0I7SUFBc0I7SUFBdUI7SUFBVztJQUFtQjtJQUFtQjtJQUFpQjtJQUFjO0lBQWtCO0lBQXFCO0lBQW9CO0lBQTBCO0lBQWM7SUFBb0I7SUFBcUI7SUFBMEI7SUFBa0I7SUFBa0I7SUFBbUI7SUFBZ0I7SUFBc0I7SUFBdUI7SUFBc0I7SUFBWTtJQUFrQjtJQUN6c0QsVUFBVTtJQUNWO0lBQVE7SUFBYTtJQUFlO0lBQW1CO0lBQWM7SUFBYztJQUFjO0lBQWtCO0lBQWU7SUFBa0I7SUFBVztJQUFZO0lBQWM7SUFBZTtJQUFlO0lBQVk7SUFBYztJQUFXO0lBQVc7SUFBUTtDQUFVO0FBRXpSLFNBQVNDLFNBQVNDLENBQUM7SUFDakIsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLE1BQU0sUUFBUUEsRUFBRUMsV0FBVyxJQUFJQyxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFB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ekNBLFNBQVMyRCxTQUFTQyxhQUFhLENBQUM7Z0JBQ2hDNUQsT0FBTzZELFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO2dCQUNyQjlELE9BQU9vRSxTQUFTLEdBQUcxQyxPQUFPMkMsTUFBTSxDQUFDMUYsV0FBVyxDQUFDNEYsYUFBYTtnQkFDMUR2RSxPQUFPK0QsSUFBSSxDQUFDRCxHQUFHLENBQUM7Z0JBQ2hCcEMsT0FBT3ZCLEVBQUUsQ0FBQzZELFdBQVcsQ0FBQ2hFO1lBQ3hCO1FBQ0Y7UUFDQSxJQUFJRCxRQUFRa0MsY0FBY25DLFVBQVUsQ0FBQ0MsTUFBTSxHQUFHQTtRQUM5QyxJQUFJQyxRQUFRaUMsY0FBY25DLFVBQVUsQ0FBQ0UsTUFBTSxHQUFHQTtRQUM5Q0YsV0FBVzRELElBQUk7UUFDZjVELFdBQVcwRCxNQUFNO0lBQ25CO0lBQ0EsSUFBSTNCLGNBQWNOLFFBQVEsQ0FBQyxtQkFBbUI7UUFDNUNHLE9BQU84QyxjQUFjLEdBQUc1QyxhQUFhNEMsY0FBYztJQUNyRDtJQUNBLElBQUkzQyxjQUFjTixRQUFRLENBQUMsbUJBQW1CO1FBQzVDRyxPQUFPK0MsY0FBYyxHQUFHN0MsYUFBYTZDLGNBQWM7SUFDckQ7SUFDQSxJQUFJNUMsY0FBY04sUUFBUSxDQUFDLGNBQWM7UUFDdkNHLE9BQU9nRCxlQUFlLENBQUM5QyxhQUFhK0MsU0FBUyxFQUFFO0lBQ2pEO0lBQ0EsSUFBSWxDLG1CQUFtQkUsZ0JBQWdCO1FBQ3JDakIsT0FBT2tELFdBQVc7SUFDcEI7SUFDQSxJQUFJbEMsa0JBQWtCQyxnQkFBZ0I7UUFDcENqQixPQUFPbUQsVUFBVTtJQUNuQjtJQUNBbkQsT0FBTzhCLE1BQU07QUFDZjtBQUVtTSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYWdvbmFscy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3VwZGF0ZS1zd2lwZXIubWpzP2EzZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyogdW5kZXJzY29yZSBpbiBuYW1lIC0+IHdhdGNoIGZvciBjaGFuZ2VzICovXG5jb25zdCBwYXJhbXNMaXN0ID0gWydldmVudHNQcmVmaXgnLCAnaW5qZWN0U3R5bGVzJywgJ2luamVjdFN0eWxlc1VybHMnLCAnbW9kdWxlcycsICdpbml0JywgJ19kaXJlY3Rpb24nLCAnb25lV2F5TW92ZW1lbnQnLCAndG91Y2hFdmVudHNUYXJnZXQnLCAnaW5pdGlhbFNsaWRlJywgJ19zcGVlZCcsICdjc3NNb2RlJywgJ3VwZGF0ZU9uV2luZG93UmVzaXplJywgJ3Jlc2l6ZU9ic2VydmVyJywgJ25lc3RlZCcsICdmb2N1c2FibGVFbGVtZW50cycsICdfZW5hYmxlZCcsICdfd2lkdGgnLCAnX2hlaWdodCcsICdwcmV2ZW50SW50ZXJhY3Rpb25PblRyYW5zaXRpb24nLCAndXNlckFnZW50JywgJ3VybCcsICdfZWRnZVN3aXBlRGV0ZWN0aW9uJywgJ19lZGdlU3dpcGVUaHJlc2hvbGQnLCAnX2ZyZWVNb2RlJywgJ19hdXRvSGVpZ2h0JywgJ3NldFdyYXBwZXJTaXplJywgJ3ZpcnR1YWxUcmFuc2xhdGUnLCAnX2VmZmVjdCcsICdicmVha3BvaW50cycsICdicmVha3BvaW50c0Jhc2UnLCAnX3NwYWNlQmV0d2VlbicsICdfc2xpZGVzUGVyVmlldycsICdtYXhCYWNrZmFjZUhpZGRlblNsaWRlcycsICdfZ3JpZCcsICdfc2xpZGVzUGVyR3JvdXAnLCAnX3NsaWRlc1Blckdyb3VwU2tpcCcsICdfc2xpZGVzUGVyR3JvdXBBdXRvJywgJ19jZW50ZXJlZFNsaWRlcycsICdfY2VudGVyZWRTbGlkZXNCb3VuZHMnLCAnX3NsaWRlc09mZnNldEJlZm9yZScsICdfc2xpZGVzT2Zmc2V0QWZ0ZXInLCAnbm9ybWFsaXplU2xpZGVJbmRleCcsICdfY2VudGVySW5zdWZmaWNpZW50U2xpZGVzJywgJ193YXRjaE92ZXJmbG93JywgJ3JvdW5kTGVuZ3RocycsICd0b3VjaFJhdGlvJywgJ3RvdWNoQW5nbGUnLCAnc2ltdWxhdGVUb3VjaCcsICdfc2hvcnRTd2lwZXMnLCAnX2xvbmdTd2lwZXMnLCAnbG9uZ1N3aXBlc1JhdGlvJywgJ2xvbmdTd2lwZXNNcycsICdfZm9sbG93RmluZ2VyJywgJ2FsbG93VG91Y2hNb3ZlJywgJ190aHJlc2hvbGQnLCAndG91Y2hNb3ZlU3RvcFByb3BhZ2F0aW9uJywgJ3RvdWNoU3RhcnRQcmV2ZW50RGVmYXVsdCcsICd0b3VjaFN0YXJ0Rm9yY2VQcmV2ZW50RGVmYXVsdCcsICd0b3VjaFJlbGVhc2VPbkVkZ2VzJywgJ3VuaXF1ZU5hdkVsZW1lbnRzJywgJ19yZXNpc3RhbmNlJywgJ19yZXNpc3RhbmNlUmF0aW8nLCAnX3dhdGNoU2xpZGVzUHJvZ3Jlc3MnLCAnX2dyYWJDdXJzb3InLCAncHJldmVudENsaWNrcycsICdwcmV2ZW50Q2xpY2tzUHJvcGFnYXRpb24nLCAnX3NsaWRlVG9DbGlja2VkU2xpZGUnLCAnX2xvb3AnLCAnbG9vcEFkZGl0aW9uYWxTbGlkZXMnLCAnbG9vcEFkZEJsYW5rU2xpZGVzJywgJ2xvb3BQcmV2ZW50c1NsaWRpbmcnLCAnX3Jld2luZCcsICdfYWxsb3dTbGlkZVByZXYnLCAnX2FsbG93U2xpZGVOZXh0JywgJ19zd2lwZUhhbmRsZXInLCAnX25vU3dpcGluZycsICdub1N3aXBpbmdDbGFzcycsICdub1N3aXBpbmdTZWxlY3RvcicsICdwYXNzaXZlTGlzdGVuZXJzJywgJ2NvbnRhaW5lck1vZGlmaWVyQ2xhc3MnLCAnc2xpZGVDbGFzcycsICdzbGlkZUFjdGl2ZUNsYXNzJywgJ3NsaWRlVmlzaWJsZUNsYXNzJywgJ3NsaWRlRnVsbHlWaXNpYmxlQ2xhc3MnLCAnc2xpZGVOZXh0Q2xhc3MnLCAnc2xpZGVQcmV2Q2xhc3MnLCAnc2xpZGVCbGFua0NsYXNzJywgJ3dyYXBwZXJDbGFzcycsICdsYXp5UHJlbG9hZGVyQ2xhc3MnLCAnbGF6eVByZWxvYWRQcmV2TmV4dCcsICdydW5DYWxsYmFja3NPbkluaXQnLCAnb2JzZXJ2ZXInLCAnb2JzZXJ2ZVBhcmVudHMnLCAnb2JzZXJ2ZVNsaWRlQ2hpbGRyZW4nLFxuLy8gbW9kdWxlc1xuJ2ExMXknLCAnX2F1dG9wbGF5JywgJ19jb250cm9sbGVyJywgJ2NvdmVyZmxvd0VmZmVjdCcsICdjdWJlRWZmZWN0JywgJ2ZhZGVFZmZlY3QnLCAnZmxpcEVmZmVjdCcsICdjcmVhdGl2ZUVmZmVjdCcsICdjYXJkc0VmZmVjdCcsICdoYXNoTmF2aWdhdGlvbicsICdoaXN0b3J5JywgJ2tleWJvYXJkJywgJ21vdXNld2hlZWwnLCAnX25hdmlnYXRpb24nLCAnX3BhZ2luYXRpb24nLCAncGFyYWxsYXgnLCAnX3Njcm9sbGJhcicsICdfdGh1bWJzJywgJ3ZpcnR1YWwnLCAnem9vbScsICdjb250cm9sJ107XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvICE9PSBudWxsICYmIG8uY29uc3RydWN0b3IgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCcgJiYgIW8uX19zd2lwZXJfXztcbn1cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNyYykge1xuICBjb25zdCBub0V4dGVuZCA9IFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddO1xuICBPYmplY3Qua2V5cyhzcmMpLmZpbHRlcihrZXkgPT4gbm9FeHRlbmQuaW5kZXhPZihrZXkpIDwgMCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgaWYgKGlzT2JqZWN0KHNyY1trZXldKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkgJiYgT2JqZWN0LmtleXMoc3JjW2tleV0pLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChzcmNba2V5XS5fX3N3aXBlcl9fKSB0YXJnZXRba2V5XSA9IHNyY1trZXldO2Vsc2UgZXh0ZW5kKHRhcmdldFtrZXldLCBzcmNba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG5lZWRzTmF2aWdhdGlvbihwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cbiAgcmV0dXJuIHBhcmFtcy5uYXZpZ2F0aW9uICYmIHR5cGVvZiBwYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJhbXMubmF2aWdhdGlvbi5wcmV2RWwgPT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gbmVlZHNQYWdpbmF0aW9uKHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICByZXR1cm4gcGFyYW1zLnBhZ2luYXRpb24gJiYgdHlwZW9mIHBhcmFtcy5wYWdpbmF0aW9uLmVsID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIG5lZWRzU2Nyb2xsYmFyKHBhcmFtcykge1xuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICByZXR1cm4gcGFyYW1zLnNjcm9sbGJhciAmJiB0eXBlb2YgcGFyYW1zLnNjcm9sbGJhci5lbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiB1bmlxdWVDbGFzc2VzKGNsYXNzTmFtZXMpIHtcbiAgaWYgKGNsYXNzTmFtZXMgPT09IHZvaWQgMCkge1xuICAgIGNsYXNzTmFtZXMgPSAnJztcbiAgfVxuICBjb25zdCBjbGFzc2VzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpLm1hcChjID0+IGMudHJpbSgpKS5maWx0ZXIoYyA9PiAhIWMpO1xuICBjb25zdCB1bmlxdWUgPSBbXTtcbiAgY2xhc3Nlcy5mb3JFYWNoKGMgPT4ge1xuICAgIGlmICh1bmlxdWUuaW5kZXhPZihjKSA8IDApIHVuaXF1ZS5wdXNoKGMpO1xuICB9KTtcbiAgcmV0dXJuIHVuaXF1ZS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhdHRyVG9Qcm9wKGF0dHJOYW1lKSB7XG4gIGlmIChhdHRyTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgYXR0ck5hbWUgPSAnJztcbiAgfVxuICByZXR1cm4gYXR0ck5hbWUucmVwbGFjZSgvLVthLXpdL2csIGwgPT4gbC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoJy0nLCAnJykpO1xufVxuZnVuY3Rpb24gd3JhcHBlckNsYXNzKGNsYXNzTmFtZSkge1xuICBpZiAoY2xhc3NOYW1lID09PSB2b2lkIDApIHtcbiAgICBjbGFzc05hbWUgPSAnJztcbiAgfVxuICBpZiAoIWNsYXNzTmFtZSkgcmV0dXJuICdzd2lwZXItd3JhcHBlcic7XG4gIGlmICghY2xhc3NOYW1lLmluY2x1ZGVzKCdzd2lwZXItd3JhcHBlcicpKSByZXR1cm4gYHN3aXBlci13cmFwcGVyICR7Y2xhc3NOYW1lfWA7XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN3aXBlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgc3dpcGVyLFxuICAgIHNsaWRlcyxcbiAgICBwYXNzZWRQYXJhbXMsXG4gICAgY2hhbmdlZFBhcmFtcyxcbiAgICBuZXh0RWwsXG4gICAgcHJldkVsLFxuICAgIHNjcm9sbGJhckVsLFxuICAgIHBhZ2luYXRpb25FbFxuICB9ID0gX3JlZjtcbiAgY29uc3QgdXBkYXRlUGFyYW1zID0gY2hhbmdlZFBhcmFtcy5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdkaXJlY3Rpb24nICYmIGtleSAhPT0gJ3dyYXBwZXJDbGFzcycpO1xuICBjb25zdCB7XG4gICAgcGFyYW1zOiBjdXJyZW50UGFyYW1zLFxuICAgIHBhZ2luYXRpb24sXG4gICAgbmF2aWdhdGlvbixcbiAgICBzY3JvbGxiYXIsXG4gICAgdmlydHVhbCxcbiAgICB0aHVtYnNcbiAgfSA9IHN3aXBlcjtcbiAgbGV0IG5lZWRUaHVtYnNJbml0O1xuICBsZXQgbmVlZENvbnRyb2xsZXJJbml0O1xuICBsZXQgbmVlZFBhZ2luYXRpb25Jbml0O1xuICBsZXQgbmVlZFNjcm9sbGJhckluaXQ7XG4gIGxldCBuZWVkTmF2aWdhdGlvbkluaXQ7XG4gIGxldCBsb29wTmVlZERlc3Ryb3k7XG4gIGxldCBsb29wTmVlZEVuYWJsZTtcbiAgbGV0IGxvb3BOZWVkUmVsb29wO1xuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygndGh1bWJzJykgJiYgcGFzc2VkUGFyYW1zLnRodW1icyAmJiBwYXNzZWRQYXJhbXMudGh1bWJzLnN3aXBlciAmJiBjdXJyZW50UGFyYW1zLnRodW1icyAmJiAhY3VycmVudFBhcmFtcy50aHVtYnMuc3dpcGVyKSB7XG4gICAgbmVlZFRodW1ic0luaXQgPSB0cnVlO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdjb250cm9sbGVyJykgJiYgcGFzc2VkUGFyYW1zLmNvbnRyb2xsZXIgJiYgcGFzc2VkUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbCAmJiBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIgJiYgIWN1cnJlbnRQYXJhbXMuY29udHJvbGxlci5jb250cm9sKSB7XG4gICAgbmVlZENvbnRyb2xsZXJJbml0ID0gdHJ1ZTtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygncGFnaW5hdGlvbicpICYmIHBhc3NlZFBhcmFtcy5wYWdpbmF0aW9uICYmIChwYXNzZWRQYXJhbXMucGFnaW5hdGlvbi5lbCB8fCBwYWdpbmF0aW9uRWwpICYmIChjdXJyZW50UGFyYW1zLnBhZ2luYXRpb24gfHwgY3VycmVudFBhcmFtcy5wYWdpbmF0aW9uID09PSBmYWxzZSkgJiYgcGFnaW5hdGlvbiAmJiAhcGFnaW5hdGlvbi5lbCkge1xuICAgIG5lZWRQYWdpbmF0aW9uSW5pdCA9IHRydWU7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ3Njcm9sbGJhcicpICYmIHBhc3NlZFBhcmFtcy5zY3JvbGxiYXIgJiYgKHBhc3NlZFBhcmFtcy5zY3JvbGxiYXIuZWwgfHwgc2Nyb2xsYmFyRWwpICYmIChjdXJyZW50UGFyYW1zLnNjcm9sbGJhciB8fCBjdXJyZW50UGFyYW1zLnNjcm9sbGJhciA9PT0gZmFsc2UpICYmIHNjcm9sbGJhciAmJiAhc2Nyb2xsYmFyLmVsKSB7XG4gICAgbmVlZFNjcm9sbGJhckluaXQgPSB0cnVlO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCduYXZpZ2F0aW9uJykgJiYgcGFzc2VkUGFyYW1zLm5hdmlnYXRpb24gJiYgKHBhc3NlZFBhcmFtcy5uYXZpZ2F0aW9uLnByZXZFbCB8fCBwcmV2RWwpICYmIChwYXNzZWRQYXJhbXMubmF2aWdhdGlvbi5uZXh0RWwgfHwgbmV4dEVsKSAmJiAoY3VycmVudFBhcmFtcy5uYXZpZ2F0aW9uIHx8IGN1cnJlbnRQYXJhbXMubmF2aWdhdGlvbiA9PT0gZmFsc2UpICYmIG5hdmlnYXRpb24gJiYgIW5hdmlnYXRpb24ucHJldkVsICYmICFuYXZpZ2F0aW9uLm5leHRFbCkge1xuICAgIG5lZWROYXZpZ2F0aW9uSW5pdCA9IHRydWU7XG4gIH1cbiAgY29uc3QgZGVzdHJveU1vZHVsZSA9IG1vZCA9PiB7XG4gICAgaWYgKCFzd2lwZXJbbW9kXSkgcmV0dXJuO1xuICAgIHN3aXBlclttb2RdLmRlc3Ryb3koKTtcbiAgICBpZiAobW9kID09PSAnbmF2aWdhdGlvbicpIHtcbiAgICAgIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgICAgIHN3aXBlclttb2RdLnByZXZFbC5yZW1vdmUoKTtcbiAgICAgICAgc3dpcGVyW21vZF0ubmV4dEVsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmFtc1ttb2RdLnByZXZFbCA9IHVuZGVmaW5lZDtcbiAgICAgIGN1cnJlbnRQYXJhbXNbbW9kXS5uZXh0RWwgPSB1bmRlZmluZWQ7XG4gICAgICBzd2lwZXJbbW9kXS5wcmV2RWwgPSB1bmRlZmluZWQ7XG4gICAgICBzd2lwZXJbbW9kXS5uZXh0RWwgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzd2lwZXIuaXNFbGVtZW50KSB7XG4gICAgICAgIHN3aXBlclttb2RdLmVsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhcmFtc1ttb2RdLmVsID0gdW5kZWZpbmVkO1xuICAgICAgc3dpcGVyW21vZF0uZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnbG9vcCcpICYmIHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICBpZiAoY3VycmVudFBhcmFtcy5sb29wICYmICFwYXNzZWRQYXJhbXMubG9vcCkge1xuICAgICAgbG9vcE5lZWREZXN0cm95ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFjdXJyZW50UGFyYW1zLmxvb3AgJiYgcGFzc2VkUGFyYW1zLmxvb3ApIHtcbiAgICAgIGxvb3BOZWVkRW5hYmxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcE5lZWRSZWxvb3AgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChpc09iamVjdChjdXJyZW50UGFyYW1zW2tleV0pICYmIGlzT2JqZWN0KHBhc3NlZFBhcmFtc1trZXldKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UGFyYW1zW2tleV0sIHBhc3NlZFBhcmFtc1trZXldKTtcbiAgICAgIGlmICgoa2V5ID09PSAnbmF2aWdhdGlvbicgfHwga2V5ID09PSAncGFnaW5hdGlvbicgfHwga2V5ID09PSAnc2Nyb2xsYmFyJykgJiYgJ2VuYWJsZWQnIGluIHBhc3NlZFBhcmFtc1trZXldICYmICFwYXNzZWRQYXJhbXNba2V5XS5lbmFibGVkKSB7XG4gICAgICAgIGRlc3Ryb3lNb2R1bGUoa2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXNzZWRQYXJhbXNba2V5XTtcbiAgICAgIGlmICgobmV3VmFsdWUgPT09IHRydWUgfHwgbmV3VmFsdWUgPT09IGZhbHNlKSAmJiAoa2V5ID09PSAnbmF2aWdhdGlvbicgfHwga2V5ID09PSAncGFnaW5hdGlvbicgfHwga2V5ID09PSAnc2Nyb2xsYmFyJykpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlc3Ryb3lNb2R1bGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhcmFtc1trZXldID0gcGFzc2VkUGFyYW1zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKHVwZGF0ZVBhcmFtcy5pbmNsdWRlcygnY29udHJvbGxlcicpICYmICFuZWVkQ29udHJvbGxlckluaXQgJiYgc3dpcGVyLmNvbnRyb2xsZXIgJiYgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCAmJiBjdXJyZW50UGFyYW1zLmNvbnRyb2xsZXIgJiYgY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2wpIHtcbiAgICBzd2lwZXIuY29udHJvbGxlci5jb250cm9sID0gY3VycmVudFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2w7XG4gIH1cbiAgaWYgKGNoYW5nZWRQYXJhbXMuaW5jbHVkZXMoJ2NoaWxkcmVuJykgJiYgc2xpZGVzICYmIHZpcnR1YWwgJiYgY3VycmVudFBhcmFtcy52aXJ0dWFsLmVuYWJsZWQpIHtcbiAgICB2aXJ0dWFsLnNsaWRlcyA9IHNsaWRlcztcbiAgICB2aXJ0dWFsLnVwZGF0ZSh0cnVlKTtcbiAgfSBlbHNlIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCd2aXJ0dWFsJykgJiYgdmlydHVhbCAmJiBjdXJyZW50UGFyYW1zLnZpcnR1YWwuZW5hYmxlZCkge1xuICAgIGlmIChzbGlkZXMpIHZpcnR1YWwuc2xpZGVzID0gc2xpZGVzO1xuICAgIHZpcnR1YWwudXBkYXRlKHRydWUpO1xuICB9XG4gIGlmIChjaGFuZ2VkUGFyYW1zLmluY2x1ZGVzKCdjaGlsZHJlbicpICYmIHNsaWRlcyAmJiBjdXJyZW50UGFyYW1zLmxvb3ApIHtcbiAgICBsb29wTmVlZFJlbG9vcCA9IHRydWU7XG4gIH1cbiAgaWYgKG5lZWRUaHVtYnNJbml0KSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB0aHVtYnMuaW5pdCgpO1xuICAgIGlmIChpbml0aWFsaXplZCkgdGh1bWJzLnVwZGF0ZSh0cnVlKTtcbiAgfVxuICBpZiAobmVlZENvbnRyb2xsZXJJbml0KSB7XG4gICAgc3dpcGVyLmNvbnRyb2xsZXIuY29udHJvbCA9IGN1cnJlbnRQYXJhbXMuY29udHJvbGxlci5jb250cm9sO1xuICB9XG4gIGlmIChuZWVkUGFnaW5hdGlvbkluaXQpIHtcbiAgICBpZiAoc3dpcGVyLmlzRWxlbWVudCAmJiAoIXBhZ2luYXRpb25FbCB8fCB0eXBlb2YgcGFnaW5hdGlvbkVsID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHBhZ2luYXRpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcGFnaW5hdGlvbkVsLmNsYXNzTGlzdC5hZGQoJ3N3aXBlci1wYWdpbmF0aW9uJyk7XG4gICAgICBwYWdpbmF0aW9uRWwucGFydC5hZGQoJ3BhZ2luYXRpb24nKTtcbiAgICAgIHN3aXBlci5lbC5hcHBlbmRDaGlsZChwYWdpbmF0aW9uRWwpO1xuICAgIH1cbiAgICBpZiAocGFnaW5hdGlvbkVsKSBjdXJyZW50UGFyYW1zLnBhZ2luYXRpb24uZWwgPSBwYWdpbmF0aW9uRWw7XG4gICAgcGFnaW5hdGlvbi5pbml0KCk7XG4gICAgcGFnaW5hdGlvbi5yZW5kZXIoKTtcbiAgICBwYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChuZWVkU2Nyb2xsYmFySW5pdCkge1xuICAgIGlmIChzd2lwZXIuaXNFbGVtZW50ICYmICghc2Nyb2xsYmFyRWwgfHwgdHlwZW9mIHNjcm9sbGJhckVsID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHNjcm9sbGJhckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JvbGxiYXJFbC5jbGFzc0xpc3QuYWRkKCdzd2lwZXItc2Nyb2xsYmFyJyk7XG4gICAgICBzY3JvbGxiYXJFbC5wYXJ0LmFkZCgnc2Nyb2xsYmFyJyk7XG4gICAgICBzd2lwZXIuZWwuYXBwZW5kQ2hpbGQoc2Nyb2xsYmFyRWwpO1xuICAgIH1cbiAgICBpZiAoc2Nyb2xsYmFyRWwpIGN1cnJlbnRQYXJhbXMuc2Nyb2xsYmFyLmVsID0gc2Nyb2xsYmFyRWw7XG4gICAgc2Nyb2xsYmFyLmluaXQoKTtcbiAgICBzY3JvbGxiYXIudXBkYXRlU2l6ZSgpO1xuICAgIHNjcm9sbGJhci5zZXRUcmFuc2xhdGUoKTtcbiAgfVxuICBpZiAobmVlZE5hdmlnYXRpb25Jbml0KSB7XG4gICAgaWYgKHN3aXBlci5pc0VsZW1lbnQpIHtcbiAgICAgIGlmICghbmV4dEVsIHx8IHR5cGVvZiBuZXh0RWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5leHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBuZXh0RWwuY2xhc3NMaXN0LmFkZCgnc3dpcGVyLWJ1dHRvbi1uZXh0Jyk7XG4gICAgICAgIG5leHRFbC5pbm5lckhUTUwgPSBzd2lwZXIuaG9zdEVsLmNvbnN0cnVjdG9yLm5leHRCdXR0b25Tdmc7XG4gICAgICAgIG5leHRFbC5wYXJ0LmFkZCgnYnV0dG9uLW5leHQnKTtcbiAgICAgICAgc3dpcGVyLmVsLmFwcGVuZENoaWxkKG5leHRFbCk7XG4gICAgICB9XG4gICAgICBpZiAoIXByZXZFbCB8fCB0eXBlb2YgcHJldkVsID09PSAnc3RyaW5nJykge1xuICAgICAgICBwcmV2RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldkVsLmNsYXNzTGlzdC5hZGQoJ3N3aXBlci1idXR0b24tcHJldicpO1xuICAgICAgICBwcmV2RWwuaW5uZXJIVE1MID0gc3dpcGVyLmhvc3RFbC5jb25zdHJ1Y3Rvci5wcmV2QnV0dG9uU3ZnO1xuICAgICAgICBwcmV2RWwucGFydC5hZGQoJ2J1dHRvbi1wcmV2Jyk7XG4gICAgICAgIHN3aXBlci5lbC5hcHBlbmRDaGlsZChwcmV2RWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dEVsKSBjdXJyZW50UGFyYW1zLm5hdmlnYXRpb24ubmV4dEVsID0gbmV4dEVsO1xuICAgIGlmIChwcmV2RWwpIGN1cnJlbnRQYXJhbXMubmF2aWdhdGlvbi5wcmV2RWwgPSBwcmV2RWw7XG4gICAgbmF2aWdhdGlvbi5pbml0KCk7XG4gICAgbmF2aWdhdGlvbi51cGRhdGUoKTtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnYWxsb3dTbGlkZU5leHQnKSkge1xuICAgIHN3aXBlci5hbGxvd1NsaWRlTmV4dCA9IHBhc3NlZFBhcmFtcy5hbGxvd1NsaWRlTmV4dDtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnYWxsb3dTbGlkZVByZXYnKSkge1xuICAgIHN3aXBlci5hbGxvd1NsaWRlUHJldiA9IHBhc3NlZFBhcmFtcy5hbGxvd1NsaWRlUHJldjtcbiAgfVxuICBpZiAoY2hhbmdlZFBhcmFtcy5pbmNsdWRlcygnZGlyZWN0aW9uJykpIHtcbiAgICBzd2lwZXIuY2hhbmdlRGlyZWN0aW9uKHBhc3NlZFBhcmFtcy5kaXJlY3Rpb24sIGZhbHNlKTtcbiAgfVxuICBpZiAobG9vcE5lZWREZXN0cm95IHx8IGxvb3BOZWVkUmVsb29wKSB7XG4gICAgc3dpcGVyLmxvb3BEZXN0cm95KCk7XG4gIH1cbiAgaWYgKGxvb3BOZWVkRW5hYmxlIHx8IGxvb3BOZWVkUmVsb29wKSB7XG4gICAgc3dpcGVyLmxvb3BDcmVhdGUoKTtcbiAgfVxuICBzd2lwZXIudXBkYXRlKCk7XG59XG5cbmV4cG9ydCB7IG5lZWRzUGFnaW5hdGlvbiBhcyBhLCBuZWVkc1Njcm9sbGJhciBhcyBiLCBhdHRyVG9Qcm9wIGFzIGMsIHVuaXF1ZUNsYXNzZXMgYXMgZCwgZXh0ZW5kIGFzIGUsIGlzT2JqZWN0IGFzIGksIG5lZWRzTmF2aWdhdGlvbiBhcyBuLCBwYXJhbXNMaXN0IGFzIHAsIHVwZGF0ZVN3aXBlciBhcyB1LCB3cmFwcGVyQ2xhc3MgYXMgdyB9O1xuIl0sIm5hbWVzIjpbInBhcmFtc0xpc3QiLCJpc09iamVjdCIsIm8iLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiX19zd2lwZXJfXyIsImV4dGVuZCIsInRhcmdldCIsInNyYyIsIm5vRXh0ZW5kIiwia2V5cyIsImZpbHRlciIsImtleSIsImluZGV4T2YiLCJmb3JFYWNoIiwibGVuZ3RoIiwibmVlZHNOYXZpZ2F0aW9uIiwicGFyYW1zIiwibmF2aWdhdGlvbiIsIm5leHRFbCIsInByZXZFbCIsIm5lZWRzUGFnaW5hdGlvbiIsInBhZ2luYXRpb24iLCJlbCIsIm5lZWRzU2Nyb2xsYmFyIiwic2Nyb2xsYmFyIiwidW5pcXVlQ2xhc3NlcyIsImNsYXNzTmFtZXMiLCJjbGFzc2VzIiwic3BsaXQiLCJtYXAiLCJjIiwidHJpbSIsInVuaXF1ZSIsInB1c2giLCJqb2luIiwiYXR0clRvUHJvcCIsImF0dHJOYW1lIiwicmVwbGFjZSIsImwiLCJ0b1VwcGVyQ2FzZSIsIndyYXBwZXJDbGFzcyIsImNsYXNzTmFtZSIsImluY2x1ZGVzIiwidXBkYXRlU3dpcGVyIiwiX3JlZiIsInN3aXBlciIsInNsaWRlcyIsInBhc3NlZFBhcmFtcyIsImNoYW5nZWRQYXJhbXMiLCJzY3JvbGxiYXJFbCIsInBhZ2luYXRpb25FbCIsInVwZGF0ZVBhcmFtcyIsImN1cnJlbnRQYXJhbXMiLCJ2aXJ0dWFsIiwidGh1bWJzIiwibmVlZFRodW1ic0luaXQiLCJuZWVkQ29udHJvbGxlckluaXQiLCJuZWVkUGFnaW5hdGlvbkluaXQiLCJuZWVkU2Nyb2xsYmFySW5pdCIsIm5lZWROYXZpZ2F0aW9uSW5pdCIsImxvb3BOZWVkRGVzdHJveSIsImxvb3BOZWVkRW5hYmxlIiwibG9vcE5lZWRSZWxvb3AiLCJjb250cm9sbGVyIiwiY29udHJvbCIsImRlc3Ryb3lNb2R1bGUiLCJtb2QiLCJkZXN0cm95IiwiaXNFbGVtZW50IiwicmVtb3ZlIiwidW5kZWZpbmVkIiwibG9vcCIsImFzc2lnbiIsImVuYWJsZWQiLCJuZXdWYWx1ZSIsInVwZGF0ZSIsImluaXRpYWxpemVkIiwiaW5pdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsInBhcnQiLCJhcHBlbmRDaGlsZCIsInJlbmRlciIsInVwZGF0ZVNpemUiLCJzZXRUcmFuc2xhdGUiLCJpbm5lckhUTUwiLCJob3N0RWwiLCJuZXh0QnV0dG9uU3ZnIiwicHJldkJ1dHRvblN2ZyIsImFsbG93U2xpZGVOZXh0IiwiYWxsb3dTbGlkZVByZXYiLCJjaGFuZ2VEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJsb29wRGVzdHJveSIsImxvb3BDcmVhdGUiLCJhIiwiYiIsImQiLCJlIiwiaSIsIm4iLCJwIiwidSIsInciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/update-swiper.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/shared/utils.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/shared/utils.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ elementParents),\n/* harmony export */   b: () => (/* binding */ elementOffset),\n/* harmony export */   c: () => (/* binding */ createElement),\n/* harmony export */   d: () => (/* binding */ now),\n/* harmony export */   e: () => (/* binding */ elementChildren),\n/* harmony export */   f: () => (/* binding */ elementOuterSize),\n/* harmony export */   g: () => (/* binding */ elementIndex),\n/* harmony export */   h: () => (/* binding */ classesToTokens),\n/* harmony export */   i: () => (/* binding */ getTranslate),\n/* harmony export */   j: () => (/* binding */ elementTransitionEnd),\n/* harmony export */   k: () => (/* binding */ isObject),\n/* harmony export */   l: () => (/* binding */ getSlideTransformEl),\n/* harmony export */   m: () => (/* binding */ elementStyle),\n/* harmony export */   n: () => (/* binding */ nextTick),\n/* harmony export */   o: () => (/* binding */ elementNextAll),\n/* harmony export */   p: () => (/* binding */ elementPrevAll),\n/* harmony export */   q: () => (/* binding */ animateCSSModeScroll),\n/* harmony export */   r: () => (/* binding */ showWarning),\n/* harmony export */   s: () => (/* binding */ setCSSProperty),\n/* harmony export */   t: () => (/* binding */ extend),\n/* harmony export */   u: () => (/* binding */ deleteProps)\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"(ssr)/./node_modules/swiper/shared/ssr-window.esm.mjs\");\n\nfunction classesToTokens(classes) {\n    if (classes === void 0) {\n        classes = \"\";\n    }\n    return classes.trim().split(\" \").filter((c)=>!!c.trim());\n}\nfunction deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key)=>{\n        try {\n            object[key] = null;\n        } catch (e) {\n        // no getter for object\n        }\n        try {\n            delete object[key];\n        } catch (e) {\n        // something got wrong\n        }\n    });\n}\nfunction nextTick(callback, delay) {\n    if (delay === void 0) {\n        delay = 0;\n    }\n    return setTimeout(callback, delay);\n}\nfunction now() {\n    return Date.now();\n}\nfunction getComputedStyle(el) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let style;\n    if (window1.getComputedStyle) {\n        style = window1.getComputedStyle(el, null);\n    }\n    if (!style && el.currentStyle) {\n        style = el.currentStyle;\n    }\n    if (!style) {\n        style = el.style;\n    }\n    return style;\n}\nfunction getTranslate(el, axis) {\n    if (axis === void 0) {\n        axis = \"x\";\n    }\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n    const curStyle = getComputedStyle(el);\n    if (window1.WebKitCSSMatrix) {\n        curTransform = curStyle.transform || curStyle.webkitTransform;\n        if (curTransform.split(\",\").length > 6) {\n            curTransform = curTransform.split(\", \").map((a)=>a.replace(\",\", \".\")).join(\", \");\n        }\n        // Some old versions of Webkit choke when 'none' is passed; pass\n        // empty string instead in this case\n        transformMatrix = new window1.WebKitCSSMatrix(curTransform === \"none\" ? \"\" : curTransform);\n    } else {\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue(\"transform\").replace(\"translate(\", \"matrix(1, 0, 0, 1,\");\n        matrix = transformMatrix.toString().split(\",\");\n    }\n    if (axis === \"x\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n        else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === \"y\") {\n        // Latest Chrome and webkits Fix\n        if (window1.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n        else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n}\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === \"Object\";\n}\nfunction isNode(node) {\n    // eslint-disable-next-line\n    if (false) {}\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    const noExtend = [\n        \"__proto__\",\n        \"constructor\",\n        \"prototype\"\n    ];\n    for(let i = 1; i < arguments.length; i += 1){\n        const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n            const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);\n            for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){\n                const nextKey = keysArray[nextIndex];\n                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n                if (desc !== undefined && desc.enumerable) {\n                    if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n                        to[nextKey] = {};\n                        if (nextSource[nextKey].__swiper__) {\n                            to[nextKey] = nextSource[nextKey];\n                        } else {\n                            extend(to[nextKey], nextSource[nextKey]);\n                        }\n                    } else {\n                        to[nextKey] = nextSource[nextKey];\n                    }\n                }\n            }\n        }\n    }\n    return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n    let { swiper, targetPosition, side } = _ref;\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const startPosition = -swiper.translate;\n    let startTime = null;\n    let time;\n    const duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = \"none\";\n    window1.cancelAnimationFrame(swiper.cssModeFrameID);\n    const dir = targetPosition > startPosition ? \"next\" : \"prev\";\n    const isOutOfBound = (current, target)=>{\n        return dir === \"next\" && current >= target || dir === \"prev\" && current <= target;\n    };\n    const animate = ()=>{\n        time = new Date().getTime();\n        if (startTime === null) {\n            startTime = time;\n        }\n        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            currentPosition = targetPosition;\n        }\n        swiper.wrapperEl.scrollTo({\n            [side]: currentPosition\n        });\n        if (isOutOfBound(currentPosition, targetPosition)) {\n            swiper.wrapperEl.style.overflow = \"hidden\";\n            swiper.wrapperEl.style.scrollSnapType = \"\";\n            setTimeout(()=>{\n                swiper.wrapperEl.style.overflow = \"\";\n                swiper.wrapperEl.scrollTo({\n                    [side]: currentPosition\n                });\n            });\n            window1.cancelAnimationFrame(swiper.cssModeFrameID);\n            return;\n        }\n        swiper.cssModeFrameID = window1.requestAnimationFrame(animate);\n    };\n    animate();\n}\nfunction getSlideTransformEl(slideEl) {\n    return slideEl.querySelector(\".swiper-slide-transform\") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(\".swiper-slide-transform\") || slideEl;\n}\nfunction elementChildren(element, selector) {\n    if (selector === void 0) {\n        selector = \"\";\n    }\n    return [\n        ...element.children\n    ].filter((el)=>el.matches(selector));\n}\nfunction showWarning(text) {\n    try {\n        console.warn(text);\n        return;\n    } catch (err) {\n    // err\n    }\n}\nfunction createElement(tag, classes) {\n    if (classes === void 0) {\n        classes = [];\n    }\n    const el = document.createElement(tag);\n    el.classList.add(...Array.isArray(classes) ? classes : classesToTokens(classes));\n    return el;\n}\nfunction elementOffset(el) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    const document1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    const box = el.getBoundingClientRect();\n    const body = document1.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window1 ? window1.scrollY : el.scrollTop;\n    const scrollLeft = el === window1 ? window1.scrollX : el.scrollLeft;\n    return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft\n    };\n}\nfunction elementPrevAll(el, selector) {\n    const prevEls = [];\n    while(el.previousElementSibling){\n        const prev = el.previousElementSibling; // eslint-disable-line\n        if (selector) {\n            if (prev.matches(selector)) prevEls.push(prev);\n        } else prevEls.push(prev);\n        el = prev;\n    }\n    return prevEls;\n}\nfunction elementNextAll(el, selector) {\n    const nextEls = [];\n    while(el.nextElementSibling){\n        const next = el.nextElementSibling; // eslint-disable-line\n        if (selector) {\n            if (next.matches(selector)) nextEls.push(next);\n        } else nextEls.push(next);\n        el = next;\n    }\n    return nextEls;\n}\nfunction elementStyle(el, prop) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    return window1.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n    let child = el;\n    let i;\n    if (child) {\n        i = 0;\n        // eslint-disable-next-line\n        while((child = child.previousSibling) !== null){\n            if (child.nodeType === 1) i += 1;\n        }\n        return i;\n    }\n    return undefined;\n}\nfunction elementParents(el, selector) {\n    const parents = []; // eslint-disable-line\n    let parent = el.parentElement; // eslint-disable-line\n    while(parent){\n        if (selector) {\n            if (parent.matches(selector)) parents.push(parent);\n        } else {\n            parents.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n    function fireCallBack(e) {\n        if (e.target !== el) return;\n        callback.call(el, e);\n        el.removeEventListener(\"transitionend\", fireCallBack);\n    }\n    if (callback) {\n        el.addEventListener(\"transitionend\", fireCallBack);\n    }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n    const window1 = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n    if (includeMargins) {\n        return el[size === \"width\" ? \"offsetWidth\" : \"offsetHeight\"] + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-right\" : \"margin-top\")) + parseFloat(window1.getComputedStyle(el, null).getPropertyValue(size === \"width\" ? \"margin-left\" : \"margin-bottom\"));\n    }\n    return el.offsetWidth;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3NoYXJlZC91dGlscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUV4RSxTQUFTSSxnQkFBZ0JDLE9BQU87SUFDOUIsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVU7SUFDWjtJQUNBLE9BQU9BLFFBQVFDLElBQUksR0FBR0MsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBSyxDQUFDLENBQUNBLEVBQUVILElBQUk7QUFDdkQ7QUFFQSxTQUFTSSxZQUFZQyxHQUFHO0lBQ3RCLE1BQU1DLFNBQVNEO0lBQ2ZFLE9BQU9DLElBQUksQ0FBQ0YsUUFBUUcsT0FBTyxDQUFDQyxDQUFBQTtRQUMxQixJQUFJO1lBQ0ZKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHO1FBQ2hCLEVBQUUsT0FBT0MsR0FBRztRQUNWLHVCQUF1QjtRQUN6QjtRQUNBLElBQUk7WUFDRixPQUFPTCxNQUFNLENBQUNJLElBQUk7UUFDcEIsRUFBRSxPQUFPQyxHQUFHO1FBQ1Ysc0JBQXNCO1FBQ3hCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLFNBQVNDLFFBQVEsRUFBRUMsS0FBSztJQUMvQixJQUFJQSxVQUFVLEtBQUssR0FBRztRQUNwQkEsUUFBUTtJQUNWO0lBQ0EsT0FBT0MsV0FBV0YsVUFBVUM7QUFDOUI7QUFDQSxTQUFTRTtJQUNQLE9BQU9DLEtBQUtELEdBQUc7QUFDakI7QUFDQSxTQUFTRSxpQkFBaUJDLEVBQUU7SUFDMUIsTUFBTUMsVUFBU3pCLHNEQUFTQTtJQUN4QixJQUFJMEI7SUFDSixJQUFJRCxRQUFPRixnQkFBZ0IsRUFBRTtRQUMzQkcsUUFBUUQsUUFBT0YsZ0JBQWdCLENBQUNDLElBQUk7SUFDdEM7SUFDQSxJQUFJLENBQUNFLFNBQVNGLEdBQUdHLFlBQVksRUFBRTtRQUM3QkQsUUFBUUYsR0FBR0csWUFBWTtJQUN6QjtJQUNBLElBQUksQ0FBQ0QsT0FBTztRQUNWQSxR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QWlCRDtJQUMxQztJQUNBLElBQUluSixVQUFVO1FBQ1pNLEdBQUcrSSxnQkFBZ0IsQ0FBQyxpQkFBaUJGO0lBQ3ZDO0FBQ0Y7QUFDQSxTQUFTRyxpQkFBaUJoSixFQUFFLEVBQUVpSixJQUFJLEVBQUVDLGNBQWM7SUFDaEQsTUFBTWpKLFVBQVN6QixzREFBU0E7SUFDeEIsSUFBSTBLLGdCQUFnQjtRQUNsQixPQUFPbEosRUFBRSxDQUFDaUosU0FBUyxVQUFVLGdCQUFnQixlQUFlLEdBQUd6SCxXQUFXdkIsUUFBT0YsZ0JBQWdCLENBQUNDLElBQUksTUFBTXFCLGdCQUFnQixDQUFDNEgsU0FBUyxVQUFVLGlCQUFpQixpQkFBaUJ6SCxXQUFXdkIsUUFBT0YsZ0JBQWdCLENBQUNDLElBQUksTUFBTXFCLGdCQUFnQixDQUFDNEgsU0FBUyxVQUFVLGdCQUFnQjtJQUNyUjtJQUNBLE9BQU9qSixHQUFHbUosV0FBVztBQUN2QjtBQUUyYSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYWdvbmFscy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc2hhcmVkL3V0aWxzLm1qcz85ZDE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGEgYXMgZ2V0V2luZG93LCBnIGFzIGdldERvY3VtZW50IH0gZnJvbSAnLi9zc3Itd2luZG93LmVzbS5tanMnO1xuXG5mdW5jdGlvbiBjbGFzc2VzVG9Ub2tlbnMoY2xhc3Nlcykge1xuICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NlcyA9ICcnO1xuICB9XG4gIHJldHVybiBjbGFzc2VzLnRyaW0oKS5zcGxpdCgnICcpLmZpbHRlcihjID0+ICEhYy50cmltKCkpO1xufVxuXG5mdW5jdGlvbiBkZWxldGVQcm9wcyhvYmopIHtcbiAgY29uc3Qgb2JqZWN0ID0gb2JqO1xuICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goa2V5ID0+IHtcbiAgICB0cnkge1xuICAgICAgb2JqZWN0W2tleV0gPSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5vIGdldHRlciBmb3Igb2JqZWN0XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkZWxldGUgb2JqZWN0W2tleV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc29tZXRoaW5nIGdvdCB3cm9uZ1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBuZXh0VGljayhjYWxsYmFjaywgZGVsYXkpIHtcbiAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICBkZWxheSA9IDA7XG4gIH1cbiAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBsZXQgc3R5bGU7XG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xuICB9XG4gIGlmICghc3R5bGUgJiYgZWwuY3VycmVudFN0eWxlKSB7XG4gICAgc3R5bGUgPSBlbC5jdXJyZW50U3R5bGU7XG4gIH1cbiAgaWYgKCFzdHlsZSkge1xuICAgIHN0eWxlID0gZWwuc3R5bGU7XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKGVsLCBheGlzKSB7XG4gIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICBheGlzID0gJ3gnO1xuICB9XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICBsZXQgbWF0cml4O1xuICBsZXQgY3VyVHJhbnNmb3JtO1xuICBsZXQgdHJhbnNmb3JtTWF0cml4O1xuICBjb25zdCBjdXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkge1xuICAgIGN1clRyYW5zZm9ybSA9IGN1clN0eWxlLnRyYW5zZm9ybSB8fCBjdXJTdHlsZS53ZWJraXRUcmFuc2Zvcm07XG4gICAgaWYgKGN1clRyYW5zZm9ybS5zcGxpdCgnLCcpLmxlbmd0aCA+IDYpIHtcbiAgICAgIGN1clRyYW5zZm9ybSA9IGN1clRyYW5zZm9ybS5zcGxpdCgnLCAnKS5tYXAoYSA9PiBhLnJlcGxhY2UoJywnLCAnLicpKS5qb2luKCcsICcpO1xuICAgIH1cbiAgICAvLyBTb21lIG9sZCB2ZXJzaW9ucyBvZiBXZWJraXQgY2hva2Ugd2hlbiAnbm9uZScgaXMgcGFzc2VkOyBwYXNzXG4gICAgLy8gZW1wdHkgc3RyaW5nIGluc3RlYWQgaW4gdGhpcyBjYXNlXG4gICAgdHJhbnNmb3JtTWF0cml4ID0gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoY3VyVHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IGN1clRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNmb3JtTWF0cml4ID0gY3VyU3R5bGUuTW96VHJhbnNmb3JtIHx8IGN1clN0eWxlLk9UcmFuc2Zvcm0gfHwgY3VyU3R5bGUuTXNUcmFuc2Zvcm0gfHwgY3VyU3R5bGUubXNUcmFuc2Zvcm0gfHwgY3VyU3R5bGUudHJhbnNmb3JtIHx8IGN1clN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zZm9ybScpLnJlcGxhY2UoJ3RyYW5zbGF0ZSgnLCAnbWF0cml4KDEsIDAsIDAsIDEsJyk7XG4gICAgbWF0cml4ID0gdHJhbnNmb3JtTWF0cml4LnRvU3RyaW5nKCkuc3BsaXQoJywnKTtcbiAgfVxuICBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgLy8gTGF0ZXN0IENocm9tZSBhbmQgd2Via2l0cyBGaXhcbiAgICBpZiAod2luZG93LldlYktpdENTU01hdHJpeCkgY3VyVHJhbnNmb3JtID0gdHJhbnNmb3JtTWF0cml4Lm00MTtcbiAgICAvLyBDcmF6eSBJRTEwIE1hdHJpeFxuICAgIGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPT09IDE2KSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFsxMl0pO1xuICAgIC8vIE5vcm1hbCBCcm93c2Vyc1xuICAgIGVsc2UgY3VyVHJhbnNmb3JtID0gcGFyc2VGbG9hdChtYXRyaXhbNF0pO1xuICB9XG4gIGlmIChheGlzID09PSAneScpIHtcbiAgICAvLyBMYXRlc3QgQ2hyb21lIGFuZCB3ZWJraXRzIEZpeFxuICAgIGlmICh3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KSBjdXJUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1NYXRyaXgubTQyO1xuICAgIC8vIENyYXp5IElFMTAgTWF0cml4XG4gICAgZWxzZSBpZiAobWF0cml4Lmxlbmd0aCA9PT0gMTYpIGN1clRyYW5zZm9ybSA9IHBhcnNlRmxvYXQobWF0cml4WzEzXSk7XG4gICAgLy8gTm9ybWFsIEJyb3dzZXJzXG4gICAgZWxzZSBjdXJUcmFuc2Zvcm0gPSBwYXJzZUZsb2F0KG1hdHJpeFs1XSk7XG4gIH1cbiAgcmV0dXJuIGN1clRyYW5zZm9ybSB8fCAwO1xufVxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5jb25zdHJ1Y3RvciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jztcbn1cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG4gIHJldHVybiBub2RlICYmIChub2RlLm5vZGVUeXBlID09PSAxIHx8IG5vZGUubm9kZVR5cGUgPT09IDExKTtcbn1cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgY29uc3QgdG8gPSBPYmplY3QoYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdKTtcbiAgY29uc3Qgbm9FeHRlbmQgPSBbJ19fcHJvdG9fXycsICdjb25zdHJ1Y3RvcicsICdwcm90b3R5cGUnXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBuZXh0U291cmNlID0gaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldO1xuICAgIGlmIChuZXh0U291cmNlICE9PSB1bmRlZmluZWQgJiYgbmV4dFNvdXJjZSAhPT0gbnVsbCAmJiAhaXNOb2RlKG5leHRTb3VyY2UpKSB7XG4gICAgICBjb25zdCBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpLmZpbHRlcihrZXkgPT4gbm9FeHRlbmQuaW5kZXhPZihrZXkpIDwgMCk7XG4gICAgICBmb3IgKGxldCBuZXh0SW5kZXggPSAwLCBsZW4gPSBrZXlzQXJyYXkubGVuZ3RoOyBuZXh0SW5kZXggPCBsZW47IG5leHRJbmRleCArPSAxKSB7XG4gICAgICAgIGNvbnN0IG5leHRLZXkgPSBrZXlzQXJyYXlbbmV4dEluZGV4XTtcbiAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHRvW25leHRLZXldKSAmJiBpc09iamVjdChuZXh0U291cmNlW25leHRLZXldKSkge1xuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2VbbmV4dEtleV0uX19zd2lwZXJfXykge1xuICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHRlbmQodG9bbmV4dEtleV0sIG5leHRTb3VyY2VbbmV4dEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0KHRvW25leHRLZXldKSAmJiBpc09iamVjdChuZXh0U291cmNlW25leHRLZXldKSkge1xuICAgICAgICAgICAgdG9bbmV4dEtleV0gPSB7fTtcbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlW25leHRLZXldLl9fc3dpcGVyX18pIHtcbiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXh0ZW5kKHRvW25leHRLZXldLCBuZXh0U291cmNlW25leHRLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdG87XG59XG5mdW5jdGlvbiBzZXRDU1NQcm9wZXJ0eShlbCwgdmFyTmFtZSwgdmFyVmFsdWUpIHtcbiAgZWwuc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFyVmFsdWUpO1xufVxuZnVuY3Rpb24gYW5pbWF0ZUNTU01vZGVTY3JvbGwoX3JlZikge1xuICBsZXQge1xuICAgIHN3aXBlcixcbiAgICB0YXJnZXRQb3NpdGlvbixcbiAgICBzaWRlXG4gIH0gPSBfcmVmO1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IC1zd2lwZXIudHJhbnNsYXRlO1xuICBsZXQgc3RhcnRUaW1lID0gbnVsbDtcbiAgbGV0IHRpbWU7XG4gIGNvbnN0IGR1cmF0aW9uID0gc3dpcGVyLnBhcmFtcy5zcGVlZDtcbiAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5zY3JvbGxTbmFwVHlwZSA9ICdub25lJztcbiAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHN3aXBlci5jc3NNb2RlRnJhbWVJRCk7XG4gIGNvbnN0IGRpciA9IHRhcmdldFBvc2l0aW9uID4gc3RhcnRQb3NpdGlvbiA/ICduZXh0JyA6ICdwcmV2JztcbiAgY29uc3QgaXNPdXRPZkJvdW5kID0gKGN1cnJlbnQsIHRhcmdldCkgPT4ge1xuICAgIHJldHVybiBkaXIgPT09ICduZXh0JyAmJiBjdXJyZW50ID49IHRhcmdldCB8fCBkaXIgPT09ICdwcmV2JyAmJiBjdXJyZW50IDw9IHRhcmdldDtcbiAgfTtcbiAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICB0aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKHN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1heChNYXRoLm1pbigodGltZSAtIHN0YXJ0VGltZSkgLyBkdXJhdGlvbiwgMSksIDApO1xuICAgIGNvbnN0IGVhc2VQcm9ncmVzcyA9IDAuNSAtIE1hdGguY29zKHByb2dyZXNzICogTWF0aC5QSSkgLyAyO1xuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uICsgZWFzZVByb2dyZXNzICogKHRhcmdldFBvc2l0aW9uIC0gc3RhcnRQb3NpdGlvbik7XG4gICAgaWYgKGlzT3V0T2ZCb3VuZChjdXJyZW50UG9zaXRpb24sIHRhcmdldFBvc2l0aW9uKSkge1xuICAgICAgY3VycmVudFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgfVxuICAgIHN3aXBlci53cmFwcGVyRWwuc2Nyb2xsVG8oe1xuICAgICAgW3NpZGVdOiBjdXJyZW50UG9zaXRpb25cbiAgICB9KTtcbiAgICBpZiAoaXNPdXRPZkJvdW5kKGN1cnJlbnRQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pKSB7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICBzd2lwZXIud3JhcHBlckVsLnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gJyc7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3dpcGVyLndyYXBwZXJFbC5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICBzd2lwZXIud3JhcHBlckVsLnNjcm9sbFRvKHtcbiAgICAgICAgICBbc2lkZV06IGN1cnJlbnRQb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHN3aXBlci5jc3NNb2RlRnJhbWVJRCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXBlci5jc3NNb2RlRnJhbWVJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gIH07XG4gIGFuaW1hdGUoKTtcbn1cbmZ1bmN0aW9uIGdldFNsaWRlVHJhbnNmb3JtRWwoc2xpZGVFbCkge1xuICByZXR1cm4gc2xpZGVFbC5xdWVyeVNlbGVjdG9yKCcuc3dpcGVyLXNsaWRlLXRyYW5zZm9ybScpIHx8IHNsaWRlRWwuc2hhZG93Um9vdCAmJiBzbGlkZUVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignLnN3aXBlci1zbGlkZS10cmFuc2Zvcm0nKSB8fCBzbGlkZUVsO1xufVxuZnVuY3Rpb24gZWxlbWVudENoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGlmIChzZWxlY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0b3IgPSAnJztcbiAgfVxuICByZXR1cm4gWy4uLmVsZW1lbnQuY2hpbGRyZW5dLmZpbHRlcihlbCA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBzaG93V2FybmluZyh0ZXh0KSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS53YXJuKHRleHQpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZXJyXG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc2VzKSB7XG4gIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHtcbiAgICBjbGFzc2VzID0gW107XG4gIH1cbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmNsYXNzTGlzdC5hZGQoLi4uKEFycmF5LmlzQXJyYXkoY2xhc3NlcykgPyBjbGFzc2VzIDogY2xhc3Nlc1RvVG9rZW5zKGNsYXNzZXMpKSk7XG4gIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRPZmZzZXQoZWwpIHtcbiAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgY29uc3QgYm94ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCBjbGllbnRUb3AgPSBlbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMDtcbiAgY29uc3QgY2xpZW50TGVmdCA9IGVsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG4gIGNvbnN0IHNjcm9sbFRvcCA9IGVsID09PSB3aW5kb3cgPyB3aW5kb3cuc2Nyb2xsWSA6IGVsLnNjcm9sbFRvcDtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IGVsID09PSB3aW5kb3cgPyB3aW5kb3cuc2Nyb2xsWCA6IGVsLnNjcm9sbExlZnQ7XG4gIHJldHVybiB7XG4gICAgdG9wOiBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wLFxuICAgIGxlZnQ6IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRQcmV2QWxsKGVsLCBzZWxlY3Rvcikge1xuICBjb25zdCBwcmV2RWxzID0gW107XG4gIHdoaWxlIChlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGlmIChwcmV2Lm1hdGNoZXMoc2VsZWN0b3IpKSBwcmV2RWxzLnB1c2gocHJldik7XG4gICAgfSBlbHNlIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICBlbCA9IHByZXY7XG4gIH1cbiAgcmV0dXJuIHByZXZFbHM7XG59XG5mdW5jdGlvbiBlbGVtZW50TmV4dEFsbChlbCwgc2VsZWN0b3IpIHtcbiAgY29uc3QgbmV4dEVscyA9IFtdO1xuICB3aGlsZSAoZWwubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgY29uc3QgbmV4dCA9IGVsLm5leHRFbGVtZW50U2libGluZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgaWYgKG5leHQubWF0Y2hlcyhzZWxlY3RvcikpIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICB9IGVsc2UgbmV4dEVscy5wdXNoKG5leHQpO1xuICAgIGVsID0gbmV4dDtcbiAgfVxuICByZXR1cm4gbmV4dEVscztcbn1cbmZ1bmN0aW9uIGVsZW1lbnRTdHlsZShlbCwgcHJvcCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xufVxuZnVuY3Rpb24gZWxlbWVudEluZGV4KGVsKSB7XG4gIGxldCBjaGlsZCA9IGVsO1xuICBsZXQgaTtcbiAgaWYgKGNoaWxkKSB7XG4gICAgaSA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgd2hpbGUgKChjaGlsZCA9IGNoaWxkLnByZXZpb3VzU2libGluZykgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkgaSArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZWxlbWVudFBhcmVudHMoZWwsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBsZXQgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBpZiAocGFyZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBwYXJlbnRzO1xufVxuZnVuY3Rpb24gZWxlbWVudFRyYW5zaXRpb25FbmQoZWwsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGZpcmVDYWxsQmFjayhlKSB7XG4gICAgaWYgKGUudGFyZ2V0ICE9PSBlbCkgcmV0dXJuO1xuICAgIGNhbGxiYWNrLmNhbGwoZWwsIGUpO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xuICB9XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmaXJlQ2FsbEJhY2spO1xuICB9XG59XG5mdW5jdGlvbiBlbGVtZW50T3V0ZXJTaXplKGVsLCBzaXplLCBpbmNsdWRlTWFyZ2lucykge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgaWYgKGluY2x1ZGVNYXJnaW5zKSB7XG4gICAgcmV0dXJuIGVsW3NpemUgPT09ICd3aWR0aCcgPyAnb2Zmc2V0V2lkdGgnIDogJ29mZnNldEhlaWdodCddICsgcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShzaXplID09PSAnd2lkdGgnID8gJ21hcmdpbi1yaWdodCcgOiAnbWFyZ2luLXRvcCcpKSArIHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUoc2l6ZSA9PT0gJ3dpZHRoJyA/ICdtYXJnaW4tbGVmdCcgOiAnbWFyZ2luLWJvdHRvbScpKTtcbiAgfVxuICByZXR1cm4gZWwub2Zmc2V0V2lkdGg7XG59XG5cbmV4cG9ydCB7IGVsZW1lbnRQYXJlbnRzIGFzIGEsIGVsZW1lbnRPZmZzZXQgYXMgYiwgY3JlYXRlRWxlbWVudCBhcyBjLCBub3cgYXMgZCwgZWxlbWVudENoaWxkcmVuIGFzIGUsIGVsZW1lbnRPdXRlclNpemUgYXMgZiwgZWxlbWVudEluZGV4IGFzIGcsIGNsYXNzZXNUb1Rva2VucyBhcyBoLCBnZXRUcmFuc2xhdGUgYXMgaSwgZWxlbWVudFRyYW5zaXRpb25FbmQgYXMgaiwgaXNPYmplY3QgYXMgaywgZ2V0U2xpZGVUcmFuc2Zvcm1FbCBhcyBsLCBlbGVtZW50U3R5bGUgYXMgbSwgbmV4dFRpY2sgYXMgbiwgZWxlbWVudE5leHRBbGwgYXMgbywgZWxlbWVudFByZXZBbGwgYXMgcCwgYW5pbWF0ZUNTU01vZGVTY3JvbGwgYXMgcSwgc2hvd1dhcm5pbmcgYXMgciwgc2V0Q1NTUHJvcGVydHkgYXMgcywgZXh0ZW5kIGFzIHQsIGRlbGV0ZVByb3BzIGFzIHUgfTtcbiJdLCJuYW1lcyI6WyJhIiwiZ2V0V2luZG93IiwiZyIsImdldERvY3VtZW50IiwiY2xhc3Nlc1RvVG9rZW5zIiwiY2xhc3NlcyIsInRyaW0iLCJzcGxpdCIsImZpbHRlciIsImMiLCJkZWxldGVQcm9wcyIsIm9iaiIsIm9iamVjdCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiZSIsIm5leHRUaWNrIiwiY2FsbGJhY2siLCJkZWxheSIsInNldFRpbWVvdXQiLCJub3ciLCJEYXRlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImVsIiwid2luZG93Iiwic3R5bGUiLCJjdXJyZW50U3R5bGUiLCJnZXRUcmFuc2xhdGUiLCJheGlzIiwibWF0cml4IiwiY3VyVHJhbnNmb3JtIiwidHJhbnNmb3JtTWF0cml4IiwiY3VyU3R5bGUiLCJXZWJLaXRDU1NNYXRyaXgiLCJ0cmFuc2Zvcm0iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJsZW5ndGgiLCJtYXAiLCJyZXBsYWNlIiwiam9pbiIsIk1velRyYW5zZm9ybSIsIk9UcmFuc2Zvcm0iLCJNc1RyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRvU3RyaW5nIiwibTQxIiwicGFyc2VGbG9hdCIsIm00MiIsImlzT2JqZWN0IiwibyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY2FsbCIsInNsaWNlIiwiaXNOb2RlIiwibm9kZSIsIkhUTUxFbGVtZW50Iiwibm9kZVR5cGUiLCJleHRlbmQiLCJ0byIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIm5vRXh0ZW5kIiwiaSIsIm5leHRTb3VyY2UiLCJrZXlzQXJyYXkiLCJpbmRleE9mIiwibmV4dEluZGV4IiwibGVuIiwibmV4dEtleSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX19zd2lwZXJfXyIsInNldENTU1Byb3BlcnR5IiwidmFyTmFtZSIsInZhclZhbHVlIiwic2V0UHJvcGVydHkiLCJhbmltYXRlQ1NTTW9kZVNjcm9sbCIsIl9yZWYiLCJzd2lwZXIiLCJ0YXJnZXRQb3NpdGlvbiIsInNpZGUiLCJzdGFydFBvc2l0aW9uIiwidHJhbnNsYXRlIiwic3RhcnRUaW1lIiwidGltZSIsImR1cmF0aW9uIiwicGFyYW1zIiwic3BlZWQiLCJ3cmFwcGVyRWwiLCJzY3JvbGxTbmFwVHlwZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY3NzTW9kZUZyYW1lSUQiLCJkaXIiLCJpc091dE9mQm91bmQiLCJjdXJyZW50IiwidGFyZ2V0IiwiYW5pbWF0ZSIsImdldFRpbWUiLCJwcm9ncmVzcyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJlYXNlUHJvZ3Jlc3MiLCJjb3MiLCJQSSIsImN1cnJlbnRQb3NpdGlvbiIsInNjcm9sbFRvIiwib3ZlcmZsb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnZXRTbGlkZVRyYW5zZm9ybUVsIiwic2xpZGVFbCIsInF1ZXJ5U2VsZWN0b3IiLCJzaGFkb3dSb290IiwiZWxlbWVudENoaWxkcmVuIiwiZWxlbWVudCIsInNlbGVjdG9yIiwiY2hpbGRyZW4iLCJtYXRjaGVzIiwic2hvd1dhcm5pbmciLCJ0ZXh0IiwiY29uc29sZSIsIndhcm4iLCJlcnIiLCJjcmVhdGVFbGVtZW50IiwidGFnIiwiZG9jdW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJBcnJheSIsImlzQXJyYXkiLCJlbGVtZW50T2Zmc2V0IiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYm9keSIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJzY3JvbGxUb3AiLCJzY3JvbGxZIiwic2Nyb2xsTGVmdCIsInNjcm9sbFgiLCJ0b3AiLCJsZWZ0IiwiZWxlbWVudFByZXZBbGwiLCJwcmV2RWxzIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInByZXYiLCJwdXNoIiwiZWxlbWVudE5leHRBbGwiLCJuZXh0RWxzIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibmV4dCIsImVsZW1lbnRTdHlsZSIsInByb3AiLCJlbGVtZW50SW5kZXgiLCJjaGlsZCIsInByZXZpb3VzU2libGluZyIsImVsZW1lbnRQYXJlbnRzIiwicGFyZW50cyIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJlbGVtZW50VHJhbnNpdGlvbkVuZCIsImZpcmVDYWxsQmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZWxlbWVudE91dGVyU2l6ZSIsInNpemUiLCJpbmNsdWRlTWFyZ2lucyIsIm9mZnNldFdpZHRoIiwiYiIsImQiLCJmIiwiaCIsImoiLCJrIiwibCIsIm0iLCJuIiwicCIsInEiLCJyIiwicyIsInQiLCJ1Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/shared/utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/swiper-react.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/swiper-react.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swiper: () => (/* binding */ Swiper),\n/* harmony export */   SwiperSlide: () => (/* binding */ SwiperSlide),\n/* harmony export */   useSwiper: () => (/* binding */ useSwiper),\n/* harmony export */   useSwiperSlide: () => (/* binding */ useSwiperSlide)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ \"(ssr)/./node_modules/swiper/shared/swiper-core.mjs\");\n/* harmony import */ var _shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/update-on-virtual-data.mjs */ \"(ssr)/./node_modules/swiper/shared/update-on-virtual-data.mjs\");\n/* harmony import */ var _shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shared/update-swiper.mjs */ \"(ssr)/./node_modules/swiper/shared/update-swiper.mjs\");\n/**\n * Swiper React 11.0.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: November 22, 2023\n */ \n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction isChildSwiperSlide(child) {\n    return child.type && child.type.displayName && child.type.displayName.includes(\"SwiperSlide\");\n}\nfunction processChildren(c) {\n    const slides = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach((child)=>{\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.children) {\n            processChildren(child.props.children).forEach((slide)=>slides.push(slide));\n        }\n    });\n    return slides;\n}\nfunction getChildren(c) {\n    const slides = [];\n    const slots = {\n        \"container-start\": [],\n        \"container-end\": [],\n        \"wrapper-start\": [],\n        \"wrapper-end\": []\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(c).forEach((child)=>{\n        if (isChildSwiperSlide(child)) {\n            slides.push(child);\n        } else if (child.props && child.props.slot && slots[child.props.slot]) {\n            slots[child.props.slot].push(child);\n        } else if (child.props && child.props.children) {\n            const foundSlides = processChildren(child.props.children);\n            if (foundSlides.length > 0) {\n                foundSlides.forEach((slide)=>slides.push(slide));\n            } else {\n                slots[\"container-end\"].push(child);\n            }\n        } else {\n            slots[\"container-end\"].push(child);\n        }\n    });\n    return {\n        slides,\n        slots\n    };\n}\nfunction renderVirtual(swiper, slides, virtualData) {\n    if (!virtualData) return null;\n    const getSlideIndex = (index)=>{\n        let slideIndex = index;\n        if (index < 0) {\n            slideIndex = slides.length + index;\n        } else if (slideIndex >= slides.length) {\n            // eslint-disable-next-line\n            slideIndex = slideIndex - slides.length;\n        }\n        return slideIndex;\n    };\n    const style = swiper.isHorizontal() ? {\n        [swiper.rtlTranslate ? \"right\" : \"left\"]: `${virtualData.offset}px`\n    } : {\n        top: `${virtualData.offset}px`\n    };\n    const { from, to } = virtualData;\n    const loopFrom = swiper.params.loop ? -slides.length : 0;\n    const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;\n    const slidesToRender = [];\n    for(let i = loopFrom; i < loopTo; i += 1){\n        if (i >= from && i <= to) {\n            slidesToRender.push(slides[getSlideIndex(i)]);\n        }\n    }\n    return slidesToRender.map((child, index)=>{\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n            swiper,\n            style,\n            key: `slide-${index}`\n        });\n    });\n}\nfunction useIsomorphicLayoutEffect(callback, deps) {\n    // eslint-disable-next-line\n    if (true) return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(callback, deps);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(callback, deps);\n}\nconst SwiperSlideContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst useSwiperSlide = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperSlideContext);\n};\nconst SwiperContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst useSwiper = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SwiperContext);\n};\nconst Swiper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_temp, externalElRef) {\n    let { className, tag: Tag = \"div\", wrapperTag: WrapperTag = \"div\", children, onSwiper, ...rest } = _temp === void 0 ? {} : _temp;\n    let eventsAssigned = false;\n    const [containerClasses, setContainerClasses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper\");\n    const [virtualData, setVirtualData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [breakpointChanged, setBreakpointChanged] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const initializedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const swiperElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const swiperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const oldPassedParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const oldSlides = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const nextElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const prevElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const paginationElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const scrollbarElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { params: swiperParams, passedParams, rest: restProps, events } = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(rest);\n    const { slides, slots } = getChildren(children);\n    const onBeforeBreakpoint = ()=>{\n        setBreakpointChanged(!breakpointChanged);\n    };\n    Object.assign(swiperParams.on, {\n        _containerClasses (swiper, classes) {\n            setContainerClasses(classes);\n        }\n    });\n    const initSwiper = ()=>{\n        // init swiper\n        Object.assign(swiperParams.on, events);\n        eventsAssigned = true;\n        const passParams = {\n            ...swiperParams\n        };\n        delete passParams.wrapperClass;\n        swiperRef.current = new _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_1__.S(passParams);\n        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {\n            swiperRef.current.virtual.slides = slides;\n            const extendWith = {\n                cache: false,\n                slides,\n                renderExternal: setVirtualData,\n                renderExternalUpdate: false\n            };\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.params.virtual, extendWith);\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.e)(swiperRef.current.originalParams.virtual, extendWith);\n        }\n    };\n    if (!swiperElRef.current) {\n        initSwiper();\n    }\n    // Listen for breakpoints change\n    if (swiperRef.current) {\n        swiperRef.current.on(\"_beforeBreakpoint\", onBeforeBreakpoint);\n    }\n    const attachEvents = ()=>{\n        if (eventsAssigned || !events || !swiperRef.current) return;\n        Object.keys(events).forEach((eventName)=>{\n            swiperRef.current.on(eventName, events[eventName]);\n        });\n    };\n    const detachEvents = ()=>{\n        if (!events || !swiperRef.current) return;\n        Object.keys(events).forEach((eventName)=>{\n            swiperRef.current.off(eventName, events[eventName]);\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            if (swiperRef.current) swiperRef.current.off(\"_beforeBreakpoint\", onBeforeBreakpoint);\n        };\n    });\n    // set initialized flag\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!initializedRef.current && swiperRef.current) {\n            swiperRef.current.emitSlidesClasses();\n            initializedRef.current = true;\n        }\n    });\n    // mount swiper\n    useIsomorphicLayoutEffect(()=>{\n        if (externalElRef) {\n            externalElRef.current = swiperElRef.current;\n        }\n        if (!swiperElRef.current) return;\n        if (swiperRef.current.destroyed) {\n            initSwiper();\n        }\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.m)({\n            el: swiperElRef.current,\n            nextEl: nextElRef.current,\n            prevEl: prevElRef.current,\n            paginationEl: paginationElRef.current,\n            scrollbarEl: scrollbarElRef.current,\n            swiper: swiperRef.current\n        }, swiperParams);\n        if (onSwiper) onSwiper(swiperRef.current);\n        // eslint-disable-next-line\n        return ()=>{\n            if (swiperRef.current && !swiperRef.current.destroyed) {\n                swiperRef.current.destroy(true, false);\n            }\n        };\n    }, []);\n    // watch for params change\n    useIsomorphicLayoutEffect(()=>{\n        attachEvents();\n        const changedParams = (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c)=>c.key);\n        oldPassedParamsRef.current = passedParams;\n        oldSlides.current = slides;\n        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {\n            (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.u)({\n                swiper: swiperRef.current,\n                slides,\n                passedParams,\n                changedParams,\n                nextEl: nextElRef.current,\n                prevEl: prevElRef.current,\n                scrollbarEl: scrollbarElRef.current,\n                paginationEl: paginationElRef.current\n            });\n        }\n        return ()=>{\n            detachEvents();\n        };\n    });\n    // update on virtual update\n    useIsomorphicLayoutEffect(()=>{\n        (0,_shared_update_on_virtual_data_mjs__WEBPACK_IMPORTED_MODULE_2__.u)(swiperRef.current);\n    }, [\n        virtualData\n    ]);\n    // bypass swiper instance to slides\n    function renderSlides() {\n        if (swiperParams.virtual) {\n            return renderVirtual(swiperRef.current, slides, virtualData);\n        }\n        return slides.map((child, index)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(child, {\n                swiper: swiperRef.current,\n                swiperSlideIndex: index\n            });\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: swiperElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(`${containerClasses}${className ? ` ${className}` : \"\"}`)\n    }, restProps), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperContext.Provider, {\n        value: swiperRef.current\n    }, slots[\"container-start\"], /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(WrapperTag, {\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.w)(swiperParams.wrapperClass)\n    }, slots[\"wrapper-start\"], renderSlides(), slots[\"wrapper-end\"]), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.n)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: prevElRef,\n        className: \"swiper-button-prev\"\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: nextElRef,\n        className: \"swiper-button-next\"\n    })), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.b)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: scrollbarElRef,\n        className: \"swiper-scrollbar\"\n    }), (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.a)(swiperParams) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: paginationElRef,\n        className: \"swiper-pagination\"\n    }), slots[\"container-end\"]));\n});\nSwiper.displayName = \"Swiper\";\nconst SwiperSlide = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_temp, externalRef) {\n    let { tag: Tag = \"div\", children, className = \"\", swiper, zoom, lazy, virtualIndex, swiperSlideIndex, ...rest } = _temp === void 0 ? {} : _temp;\n    const slideElRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [slideClasses, setSlideClasses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"swiper-slide\");\n    const [lazyLoaded, setLazyLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    function updateClasses(_s, el, classNames) {\n        if (el === slideElRef.current) {\n            setSlideClasses(classNames);\n        }\n    }\n    useIsomorphicLayoutEffect(()=>{\n        if (typeof swiperSlideIndex !== \"undefined\") {\n            slideElRef.current.swiperSlideIndex = swiperSlideIndex;\n        }\n        if (externalRef) {\n            externalRef.current = slideElRef.current;\n        }\n        if (!slideElRef.current || !swiper) {\n            return;\n        }\n        if (swiper.destroyed) {\n            if (slideClasses !== \"swiper-slide\") {\n                setSlideClasses(\"swiper-slide\");\n            }\n            return;\n        }\n        swiper.on(\"_slideClass\", updateClasses);\n        // eslint-disable-next-line\n        return ()=>{\n            if (!swiper) return;\n            swiper.off(\"_slideClass\", updateClasses);\n        };\n    });\n    useIsomorphicLayoutEffect(()=>{\n        if (swiper && slideElRef.current && !swiper.destroyed) {\n            setSlideClasses(swiper.getSlideClasses(slideElRef.current));\n        }\n    }, [\n        swiper\n    ]);\n    const slideData = {\n        isActive: slideClasses.indexOf(\"swiper-slide-active\") >= 0,\n        isVisible: slideClasses.indexOf(\"swiper-slide-visible\") >= 0,\n        isPrev: slideClasses.indexOf(\"swiper-slide-prev\") >= 0,\n        isNext: slideClasses.indexOf(\"swiper-slide-next\") >= 0\n    };\n    const renderChildren = ()=>{\n        return typeof children === \"function\" ? children(slideData) : children;\n    };\n    const onLoad = ()=>{\n        setLazyLoaded(true);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, _extends({\n        ref: slideElRef,\n        className: (0,_shared_update_swiper_mjs__WEBPACK_IMPORTED_MODULE_3__.d)(`${slideClasses}${className ? ` ${className}` : \"\"}`),\n        \"data-swiper-slide-index\": virtualIndex,\n        onLoad: onLoad\n    }, rest), zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-zoom-container\",\n        \"data-swiper-zoom\": typeof zoom === \"number\" ? zoom : undefined\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    }))), !zoom && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(SwiperSlideContext.Provider, {\n        value: slideData\n    }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        className: \"swiper-lazy-preloader\"\n    })));\n});\nSwiperSlide.displayName = \"SwiperSlide\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci1yZWFjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBRWtIO0FBQzFEO0FBQytFO0FBQzRDO0FBRXBMLFNBQVM4QjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsU0FBU1EsbUJBQW1CQyxLQUFLO0lBQy9CLE9BQU9BLE1BQU1DLElBQUksSUFBSUQsTUFBTUMsSUFBSSxDQUFDQyxXQUFXLElBQUlGLE1BQU1DLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxRQUFRLENBQUM7QUFDakY7QUFDQSxTQUFTQyxnQkFBZ0JDLENBQUM7SUFDeEIsTUFBTUMsU0FBUyxFQUFFO0lBQ2pCbkQsMkNBQWMsQ0FBQ3FELE9BQU8sQ0FBQ0gsR0FBR0ksT0FBTyxDQUFDVCxDQUFBQTtRQUNoQyxJQUFJRCxtQkFBbUJDLFFBQVE7WUFDN0JNLE9BQU9JLElBQUksQ0FBQ1Y7UUFDZCxPQUFPLElBQUlBLE1BQU1XLEtBQUssSUFBSVgsTUFBTVcsS0FBSyxDQUFDQyxRQUFRLEVBQUU7WUFDOUNSLGdCQUFnQkosTUFBTVcsS0FBSyxDQUFDQyxRQUFRLEVBQUVILE9BQU8s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RyxHQUFHLENBQUM7UUFDN0UsMkJBQTJCaUU7UUFDM0JpQixRQUFRQTtJQUNWLEdBQUc1RSxPQUFPeUQsUUFBUSxXQUFXLEdBQUU1SixnREFBbUIsQ0FBQ3NGLG1CQUFtQmlFLFFBQVEsRUFBRTtRQUM5RUMsT0FBT2dCO0lBQ1QsR0FBRyxXQUFXLEdBQUV4SyxnREFBbUIsQ0FBQyxPQUFPO1FBQ3pDNkYsV0FBVztRQUNYLG9CQUFvQixPQUFPK0QsU0FBUyxXQUFXQSxPQUFPb0I7SUFDeEQsR0FBR0Ysa0JBQWtCakIsUUFBUSxDQUFDSyxjQUFjLFdBQVcsR0FBRWxLLGdEQUFtQixDQUFDLE9BQU87UUFDbEY2RixXQUFXO0lBQ2IsTUFBTSxDQUFDK0QsUUFBUSxXQUFXLEdBQUU1SixnREFBbUIsQ0FBQ3NGLG1CQUFtQmlFLFFBQVEsRUFBRTtRQUMzRUMsT0FBT2dCO0lBQ1QsR0FBR00sa0JBQWtCakIsUUFBUSxDQUFDSyxjQUFjLFdBQVcsR0FBRWxLLGdEQUFtQixDQUFDLE9BQU87UUFDbEY2RixXQUFXO0lBQ2I7QUFDRjtBQUNBNkQsWUFBWTNHLFdBQVcsR0FBRztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYWdvbmFscy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc3dpcGVyLXJlYWN0Lm1qcz8zY2RlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3dpcGVyIFJlYWN0IDExLjAuNVxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAyMyBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIFJlbGVhc2VkIG9uOiBOb3ZlbWJlciAyMiwgMjAyM1xuICovXG5cbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlQ29udGV4dCwgY3JlYXRlQ29udGV4dCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFMgYXMgU3dpcGVyJDEgfSBmcm9tICcuL3NoYXJlZC9zd2lwZXItY29yZS5tanMnO1xuaW1wb3J0IHsgZyBhcyBnZXRQYXJhbXMsIG0gYXMgbW91bnRTd2lwZXIsIGEgYXMgZ2V0Q2hhbmdlZFBhcmFtcywgdSBhcyB1cGRhdGVPblZpcnR1YWxEYXRhIH0gZnJvbSAnLi9zaGFyZWQvdXBkYXRlLW9uLXZpcnR1YWwtZGF0YS5tanMnO1xuaW1wb3J0IHsgZCBhcyB1bmlxdWVDbGFzc2VzLCB3IGFzIHdyYXBwZXJDbGFzcywgbiBhcyBuZWVkc05hdmlnYXRpb24sIGIgYXMgbmVlZHNTY3JvbGxiYXIsIGEgYXMgbmVlZHNQYWdpbmF0aW9uLCBlIGFzIGV4dGVuZCwgdSBhcyB1cGRhdGVTd2lwZXIgfSBmcm9tICcuL3NoYXJlZC91cGRhdGUtc3dpcGVyLm1qcyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBpc0NoaWxkU3dpcGVyU2xpZGUoY2hpbGQpIHtcbiAgcmV0dXJuIGNoaWxkLnR5cGUgJiYgY2hpbGQudHlwZS5kaXNwbGF5TmFtZSAmJiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lLmluY2x1ZGVzKCdTd2lwZXJTbGlkZScpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuKGMpIHtcbiAgY29uc3Qgc2xpZGVzID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoYykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgaWYgKGlzQ2hpbGRTd2lwZXJTbGlkZShjaGlsZCkpIHtcbiAgICAgIHNsaWRlcy5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBwcm9jZXNzQ2hpbGRyZW4oY2hpbGQucHJvcHMuY2hpbGRyZW4pLmZvckVhY2goc2xpZGUgPT4gc2xpZGVzLnB1c2goc2xpZGUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2xpZGVzO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oYykge1xuICBjb25zdCBzbGlkZXMgPSBbXTtcbiAgY29uc3Qgc2xvdHMgPSB7XG4gICAgJ2NvbnRhaW5lci1zdGFydCc6IFtdLFxuICAgICdjb250YWluZXItZW5kJzogW10sXG4gICAgJ3dyYXBwZXItc3RhcnQnOiBbXSxcbiAgICAnd3JhcHBlci1lbmQnOiBbXVxuICB9O1xuICBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGMpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGlmIChpc0NoaWxkU3dpcGVyU2xpZGUoY2hpbGQpKSB7XG4gICAgICBzbGlkZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5zbG90ICYmIHNsb3RzW2NoaWxkLnByb3BzLnNsb3RdKSB7XG4gICAgICBzbG90c1tjaGlsZC5wcm9wcy5zbG90XS5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnByb3BzICYmIGNoaWxkLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBmb3VuZFNsaWRlcyA9IHByb2Nlc3NDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICBpZiAoZm91bmRTbGlkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3VuZFNsaWRlcy5mb3JFYWNoKHNsaWRlID0+IHNsaWRlcy5wdXNoKHNsaWRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90c1snY29udGFpbmVyLWVuZCddLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbG90c1snY29udGFpbmVyLWVuZCddLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2xpZGVzLFxuICAgIHNsb3RzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbmRlclZpcnR1YWwoc3dpcGVyLCBzbGlkZXMsIHZpcnR1YWxEYXRhKSB7XG4gIGlmICghdmlydHVhbERhdGEpIHJldHVybiBudWxsO1xuICBjb25zdCBnZXRTbGlkZUluZGV4ID0gaW5kZXggPT4ge1xuICAgIGxldCBzbGlkZUluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgc2xpZGVJbmRleCA9IHNsaWRlcy5sZW5ndGggKyBpbmRleDtcbiAgICB9IGVsc2UgaWYgKHNsaWRlSW5kZXggPj0gc2xpZGVzLmxlbmd0aCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBzbGlkZUluZGV4ID0gc2xpZGVJbmRleCAtIHNsaWRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzbGlkZUluZGV4O1xuICB9O1xuICBjb25zdCBzdHlsZSA9IHN3aXBlci5pc0hvcml6b250YWwoKSA/IHtcbiAgICBbc3dpcGVyLnJ0bFRyYW5zbGF0ZSA/ICdyaWdodCcgOiAnbGVmdCddOiBgJHt2aXJ0dWFsRGF0YS5vZmZzZXR9cHhgXG4gIH0gOiB7XG4gICAgdG9wOiBgJHt2aXJ0dWFsRGF0YS5vZmZzZXR9cHhgXG4gIH07XG4gIGNvbnN0IHtcbiAgICBmcm9tLFxuICAgIHRvXG4gIH0gPSB2aXJ0dWFsRGF0YTtcbiAgY29uc3QgbG9vcEZyb20gPSBzd2lwZXIucGFyYW1zLmxvb3AgPyAtc2xpZGVzLmxlbmd0aCA6IDA7XG4gIGNvbnN0IGxvb3BUbyA9IHN3aXBlci5wYXJhbXMubG9vcCA/IHNsaWRlcy5sZW5ndGggKiAyIDogc2xpZGVzLmxlbmd0aDtcbiAgY29uc3Qgc2xpZGVzVG9SZW5kZXIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IGxvb3BGcm9tOyBpIDwgbG9vcFRvOyBpICs9IDEpIHtcbiAgICBpZiAoaSA+PSBmcm9tICYmIGkgPD0gdG8pIHtcbiAgICAgIHNsaWRlc1RvUmVuZGVyLnB1c2goc2xpZGVzW2dldFNsaWRlSW5kZXgoaSldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsaWRlc1RvUmVuZGVyLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgIHN3aXBlcixcbiAgICAgIHN0eWxlLFxuICAgICAga2V5OiBgc2xpZGUtJHtpbmRleH1gXG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNhbGxiYWNrLCBkZXBzKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1c2VFZmZlY3QoY2FsbGJhY2ssIGRlcHMpO1xuICByZXR1cm4gdXNlTGF5b3V0RWZmZWN0KGNhbGxiYWNrLCBkZXBzKTtcbn1cblxuY29uc3QgU3dpcGVyU2xpZGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VTd2lwZXJTbGlkZSA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoU3dpcGVyU2xpZGVDb250ZXh0KTtcbn07XG5jb25zdCBTd2lwZXJDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VTd2lwZXIgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFN3aXBlckNvbnRleHQpO1xufTtcblxuY29uc3QgU3dpcGVyID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF90ZW1wLCBleHRlcm5hbEVsUmVmKSB7XG4gIGxldCB7XG4gICAgY2xhc3NOYW1lLFxuICAgIHRhZzogVGFnID0gJ2RpdicsXG4gICAgd3JhcHBlclRhZzogV3JhcHBlclRhZyA9ICdkaXYnLFxuICAgIGNoaWxkcmVuLFxuICAgIG9uU3dpcGVyLFxuICAgIC4uLnJlc3RcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBsZXQgZXZlbnRzQXNzaWduZWQgPSBmYWxzZTtcbiAgY29uc3QgW2NvbnRhaW5lckNsYXNzZXMsIHNldENvbnRhaW5lckNsYXNzZXNdID0gdXNlU3RhdGUoJ3N3aXBlcicpO1xuICBjb25zdCBbdmlydHVhbERhdGEsIHNldFZpcnR1YWxEYXRhXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbYnJlYWtwb2ludENoYW5nZWQsIHNldEJyZWFrcG9pbnRDaGFuZ2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBzd2lwZXJFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc3dpcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBvbGRQYXNzZWRQYXJhbXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG9sZFNsaWRlcyA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgbmV4dEVsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwcmV2RWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBhZ2luYXRpb25FbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2Nyb2xsYmFyRWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBwYXJhbXM6IHN3aXBlclBhcmFtcyxcbiAgICBwYXNzZWRQYXJhbXMsXG4gICAgcmVzdDogcmVzdFByb3BzLFxuICAgIGV2ZW50c1xuICB9ID0gZ2V0UGFyYW1zKHJlc3QpO1xuICBjb25zdCB7XG4gICAgc2xpZGVzLFxuICAgIHNsb3RzXG4gIH0gPSBnZXRDaGlsZHJlbihjaGlsZHJlbik7XG4gIGNvbnN0IG9uQmVmb3JlQnJlYWtwb2ludCA9ICgpID0+IHtcbiAgICBzZXRCcmVha3BvaW50Q2hhbmdlZCghYnJlYWtwb2ludENoYW5nZWQpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN3aXBlclBhcmFtcy5vbiwge1xuICAgIF9jb250YWluZXJDbGFzc2VzKHN3aXBlciwgY2xhc3Nlcykge1xuICAgICAgc2V0Q29udGFpbmVyQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbml0U3dpcGVyID0gKCkgPT4ge1xuICAgIC8vIGluaXQgc3dpcGVyXG4gICAgT2JqZWN0LmFzc2lnbihzd2lwZXJQYXJhbXMub24sIGV2ZW50cyk7XG4gICAgZXZlbnRzQXNzaWduZWQgPSB0cnVlO1xuICAgIGNvbnN0IHBhc3NQYXJhbXMgPSB7XG4gICAgICAuLi5zd2lwZXJQYXJhbXNcbiAgICB9O1xuICAgIGRlbGV0ZSBwYXNzUGFyYW1zLndyYXBwZXJDbGFzcztcbiAgICBzd2lwZXJSZWYuY3VycmVudCA9IG5ldyBTd2lwZXIkMShwYXNzUGFyYW1zKTtcbiAgICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQudmlydHVhbCAmJiBzd2lwZXJSZWYuY3VycmVudC5wYXJhbXMudmlydHVhbC5lbmFibGVkKSB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC52aXJ0dWFsLnNsaWRlcyA9IHNsaWRlcztcbiAgICAgIGNvbnN0IGV4dGVuZFdpdGggPSB7XG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICByZW5kZXJFeHRlcm5hbDogc2V0VmlydHVhbERhdGEsXG4gICAgICAgIHJlbmRlckV4dGVybmFsVXBkYXRlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGV4dGVuZChzd2lwZXJSZWYuY3VycmVudC5wYXJhbXMudmlydHVhbCwgZXh0ZW5kV2l0aCk7XG4gICAgICBleHRlbmQoc3dpcGVyUmVmLmN1cnJlbnQub3JpZ2luYWxQYXJhbXMudmlydHVhbCwgZXh0ZW5kV2l0aCk7XG4gICAgfVxuICB9O1xuICBpZiAoIXN3aXBlckVsUmVmLmN1cnJlbnQpIHtcbiAgICBpbml0U3dpcGVyKCk7XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIGJyZWFrcG9pbnRzIGNoYW5nZVxuICBpZiAoc3dpcGVyUmVmLmN1cnJlbnQpIHtcbiAgICBzd2lwZXJSZWYuY3VycmVudC5vbignX2JlZm9yZUJyZWFrcG9pbnQnLCBvbkJlZm9yZUJyZWFrcG9pbnQpO1xuICB9XG4gIGNvbnN0IGF0dGFjaEV2ZW50cyA9ICgpID0+IHtcbiAgICBpZiAoZXZlbnRzQXNzaWduZWQgfHwgIWV2ZW50cyB8fCAhc3dpcGVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgIHN3aXBlclJlZi5jdXJyZW50Lm9uKGV2ZW50TmFtZSwgZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBkZXRhY2hFdmVudHMgPSAoKSA9PiB7XG4gICAgaWYgKCFldmVudHMgfHwgIXN3aXBlclJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICBzd2lwZXJSZWYuY3VycmVudC5vZmYoZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgfSk7XG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzd2lwZXJSZWYuY3VycmVudCkgc3dpcGVyUmVmLmN1cnJlbnQub2ZmKCdfYmVmb3JlQnJlYWtwb2ludCcsIG9uQmVmb3JlQnJlYWtwb2ludCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gc2V0IGluaXRpYWxpemVkIGZsYWdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWluaXRpYWxpemVkUmVmLmN1cnJlbnQgJiYgc3dpcGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIHN3aXBlclJlZi5jdXJyZW50LmVtaXRTbGlkZXNDbGFzc2VzKCk7XG4gICAgICBpbml0aWFsaXplZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIG1vdW50IHN3aXBlclxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZXh0ZXJuYWxFbFJlZikge1xuICAgICAgZXh0ZXJuYWxFbFJlZi5jdXJyZW50ID0gc3dpcGVyRWxSZWYuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKCFzd2lwZXJFbFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgaWYgKHN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkge1xuICAgICAgaW5pdFN3aXBlcigpO1xuICAgIH1cbiAgICBtb3VudFN3aXBlcih7XG4gICAgICBlbDogc3dpcGVyRWxSZWYuY3VycmVudCxcbiAgICAgIG5leHRFbDogbmV4dEVsUmVmLmN1cnJlbnQsXG4gICAgICBwcmV2RWw6IHByZXZFbFJlZi5jdXJyZW50LFxuICAgICAgcGFnaW5hdGlvbkVsOiBwYWdpbmF0aW9uRWxSZWYuY3VycmVudCxcbiAgICAgIHNjcm9sbGJhckVsOiBzY3JvbGxiYXJFbFJlZi5jdXJyZW50LFxuICAgICAgc3dpcGVyOiBzd2lwZXJSZWYuY3VycmVudFxuICAgIH0sIHN3aXBlclBhcmFtcyk7XG4gICAgaWYgKG9uU3dpcGVyKSBvblN3aXBlcihzd2lwZXJSZWYuY3VycmVudCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzd2lwZXJSZWYuY3VycmVudCAmJiAhc3dpcGVyUmVmLmN1cnJlbnQuZGVzdHJveWVkKSB7XG4gICAgICAgIHN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3kodHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyB3YXRjaCBmb3IgcGFyYW1zIGNoYW5nZVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhdHRhY2hFdmVudHMoKTtcbiAgICBjb25zdCBjaGFuZ2VkUGFyYW1zID0gZ2V0Q2hhbmdlZFBhcmFtcyhwYXNzZWRQYXJhbXMsIG9sZFBhc3NlZFBhcmFtc1JlZi5jdXJyZW50LCBzbGlkZXMsIG9sZFNsaWRlcy5jdXJyZW50LCBjID0+IGMua2V5KTtcbiAgICBvbGRQYXNzZWRQYXJhbXNSZWYuY3VycmVudCA9IHBhc3NlZFBhcmFtcztcbiAgICBvbGRTbGlkZXMuY3VycmVudCA9IHNsaWRlcztcbiAgICBpZiAoY2hhbmdlZFBhcmFtcy5sZW5ndGggJiYgc3dpcGVyUmVmLmN1cnJlbnQgJiYgIXN3aXBlclJlZi5jdXJyZW50LmRlc3Ryb3llZCkge1xuICAgICAgdXBkYXRlU3dpcGVyKHtcbiAgICAgICAgc3dpcGVyOiBzd2lwZXJSZWYuY3VycmVudCxcbiAgICAgICAgc2xpZGVzLFxuICAgICAgICBwYXNzZWRQYXJhbXMsXG4gICAgICAgIGNoYW5nZWRQYXJhbXMsXG4gICAgICAgIG5leHRFbDogbmV4dEVsUmVmLmN1cnJlbnQsXG4gICAgICAgIHByZXZFbDogcHJldkVsUmVmLmN1cnJlbnQsXG4gICAgICAgIHNjcm9sbGJhckVsOiBzY3JvbGxiYXJFbFJlZi5jdXJyZW50LFxuICAgICAgICBwYWdpbmF0aW9uRWw6IHBhZ2luYXRpb25FbFJlZi5jdXJyZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRldGFjaEV2ZW50cygpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSBvbiB2aXJ0dWFsIHVwZGF0ZVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB1cGRhdGVPblZpcnR1YWxEYXRhKHN3aXBlclJlZi5jdXJyZW50KTtcbiAgfSwgW3ZpcnR1YWxEYXRhXSk7XG5cbiAgLy8gYnlwYXNzIHN3aXBlciBpbnN0YW5jZSB0byBzbGlkZXNcbiAgZnVuY3Rpb24gcmVuZGVyU2xpZGVzKCkge1xuICAgIGlmIChzd2lwZXJQYXJhbXMudmlydHVhbCkge1xuICAgICAgcmV0dXJuIHJlbmRlclZpcnR1YWwoc3dpcGVyUmVmLmN1cnJlbnQsIHNsaWRlcywgdmlydHVhbERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGVzLm1hcCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBzd2lwZXI6IHN3aXBlclJlZi5jdXJyZW50LFxuICAgICAgICBzd2lwZXJTbGlkZUluZGV4OiBpbmRleFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgIHJlZjogc3dpcGVyRWxSZWYsXG4gICAgY2xhc3NOYW1lOiB1bmlxdWVDbGFzc2VzKGAke2NvbnRhaW5lckNsYXNzZXN9JHtjbGFzc05hbWUgPyBgICR7Y2xhc3NOYW1lfWAgOiAnJ31gKVxuICB9LCByZXN0UHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2lwZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN3aXBlclJlZi5jdXJyZW50XG4gIH0sIHNsb3RzWydjb250YWluZXItc3RhcnQnXSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlclRhZywge1xuICAgIGNsYXNzTmFtZTogd3JhcHBlckNsYXNzKHN3aXBlclBhcmFtcy53cmFwcGVyQ2xhc3MpXG4gIH0sIHNsb3RzWyd3cmFwcGVyLXN0YXJ0J10sIHJlbmRlclNsaWRlcygpLCBzbG90c1snd3JhcHBlci1lbmQnXSksIG5lZWRzTmF2aWdhdGlvbihzd2lwZXJQYXJhbXMpICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBwcmV2RWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1idXR0b24tcHJldlwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBuZXh0RWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1idXR0b24tbmV4dFwiXG4gIH0pKSwgbmVlZHNTY3JvbGxiYXIoc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBzY3JvbGxiYXJFbFJlZixcbiAgICBjbGFzc05hbWU6IFwic3dpcGVyLXNjcm9sbGJhclwiXG4gIH0pLCBuZWVkc1BhZ2luYXRpb24oc3dpcGVyUGFyYW1zKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBwYWdpbmF0aW9uRWxSZWYsXG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1wYWdpbmF0aW9uXCJcbiAgfSksIHNsb3RzWydjb250YWluZXItZW5kJ10pKTtcbn0pO1xuU3dpcGVyLmRpc3BsYXlOYW1lID0gJ1N3aXBlcic7XG5cbmNvbnN0IFN3aXBlclNsaWRlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKF90ZW1wLCBleHRlcm5hbFJlZikge1xuICBsZXQge1xuICAgIHRhZzogVGFnID0gJ2RpdicsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lID0gJycsXG4gICAgc3dpcGVyLFxuICAgIHpvb20sXG4gICAgbGF6eSxcbiAgICB2aXJ0dWFsSW5kZXgsXG4gICAgc3dpcGVyU2xpZGVJbmRleCxcbiAgICAuLi5yZXN0XG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3Qgc2xpZGVFbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3NsaWRlQ2xhc3Nlcywgc2V0U2xpZGVDbGFzc2VzXSA9IHVzZVN0YXRlKCdzd2lwZXItc2xpZGUnKTtcbiAgY29uc3QgW2xhenlMb2FkZWQsIHNldExhenlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBmdW5jdGlvbiB1cGRhdGVDbGFzc2VzKF9zLCBlbCwgY2xhc3NOYW1lcykge1xuICAgIGlmIChlbCA9PT0gc2xpZGVFbFJlZi5jdXJyZW50KSB7XG4gICAgICBzZXRTbGlkZUNsYXNzZXMoY2xhc3NOYW1lcyk7XG4gICAgfVxuICB9XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3dpcGVyU2xpZGVJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNsaWRlRWxSZWYuY3VycmVudC5zd2lwZXJTbGlkZUluZGV4ID0gc3dpcGVyU2xpZGVJbmRleDtcbiAgICB9XG4gICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gc2xpZGVFbFJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoIXNsaWRlRWxSZWYuY3VycmVudCB8fCAhc3dpcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzd2lwZXIuZGVzdHJveWVkKSB7XG4gICAgICBpZiAoc2xpZGVDbGFzc2VzICE9PSAnc3dpcGVyLXNsaWRlJykge1xuICAgICAgICBzZXRTbGlkZUNsYXNzZXMoJ3N3aXBlci1zbGlkZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2lwZXIub24oJ19zbGlkZUNsYXNzJywgdXBkYXRlQ2xhc3Nlcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghc3dpcGVyKSByZXR1cm47XG4gICAgICBzd2lwZXIub2ZmKCdfc2xpZGVDbGFzcycsIHVwZGF0ZUNsYXNzZXMpO1xuICAgIH07XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3dpcGVyICYmIHNsaWRlRWxSZWYuY3VycmVudCAmJiAhc3dpcGVyLmRlc3Ryb3llZCkge1xuICAgICAgc2V0U2xpZGVDbGFzc2VzKHN3aXBlci5nZXRTbGlkZUNsYXNzZXMoc2xpZGVFbFJlZi5jdXJyZW50KSk7XG4gICAgfVxuICB9LCBbc3dpcGVyXSk7XG4gIGNvbnN0IHNsaWRlRGF0YSA9IHtcbiAgICBpc0FjdGl2ZTogc2xpZGVDbGFzc2VzLmluZGV4T2YoJ3N3aXBlci1zbGlkZS1hY3RpdmUnKSA+PSAwLFxuICAgIGlzVmlzaWJsZTogc2xpZGVDbGFzc2VzLmluZGV4T2YoJ3N3aXBlci1zbGlkZS12aXNpYmxlJykgPj0gMCxcbiAgICBpc1ByZXY6IHNsaWRlQ2xhc3Nlcy5pbmRleE9mKCdzd2lwZXItc2xpZGUtcHJldicpID49IDAsXG4gICAgaXNOZXh0OiBzbGlkZUNsYXNzZXMuaW5kZXhPZignc3dpcGVyLXNsaWRlLW5leHQnKSA+PSAwXG4gIH07XG4gIGNvbnN0IHJlbmRlckNoaWxkcmVuID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihzbGlkZURhdGEpIDogY2hpbGRyZW47XG4gIH07XG4gIGNvbnN0IG9uTG9hZCA9ICgpID0+IHtcbiAgICBzZXRMYXp5TG9hZGVkKHRydWUpO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBzbGlkZUVsUmVmLFxuICAgIGNsYXNzTmFtZTogdW5pcXVlQ2xhc3NlcyhgJHtzbGlkZUNsYXNzZXN9JHtjbGFzc05hbWUgPyBgICR7Y2xhc3NOYW1lfWAgOiAnJ31gKSxcbiAgICBcImRhdGEtc3dpcGVyLXNsaWRlLWluZGV4XCI6IHZpcnR1YWxJbmRleCxcbiAgICBvbkxvYWQ6IG9uTG9hZFxuICB9LCByZXN0KSwgem9vbSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTd2lwZXJTbGlkZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc2xpZGVEYXRhXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IFwic3dpcGVyLXpvb20tY29udGFpbmVyXCIsXG4gICAgXCJkYXRhLXN3aXBlci16b29tXCI6IHR5cGVvZiB6b29tID09PSAnbnVtYmVyJyA/IHpvb20gOiB1bmRlZmluZWRcbiAgfSwgcmVuZGVyQ2hpbGRyZW4oKSwgbGF6eSAmJiAhbGF6eUxvYWRlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1sYXp5LXByZWxvYWRlclwiXG4gIH0pKSksICF6b29tICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN3aXBlclNsaWRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzbGlkZURhdGFcbiAgfSwgcmVuZGVyQ2hpbGRyZW4oKSwgbGF6eSAmJiAhbGF6eUxvYWRlZCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcInN3aXBlci1sYXp5LXByZWxvYWRlclwiXG4gIH0pKSk7XG59KTtcblN3aXBlclNsaWRlLmRpc3BsYXlOYW1lID0gJ1N3aXBlclNsaWRlJztcblxuZXhwb3J0IHsgU3dpcGVyLCBTd2lwZXJTbGlkZSwgdXNlU3dpcGVyLCB1c2VTd2lwZXJTbGlkZSB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJmb3J3YXJkUmVmIiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJTIiwiU3dpcGVyJDEiLCJnIiwiZ2V0UGFyYW1zIiwibSIsIm1vdW50U3dpcGVyIiwiYSIsImdldENoYW5nZWRQYXJhbXMiLCJ1IiwidXBkYXRlT25WaXJ0dWFsRGF0YSIsImQiLCJ1bmlxdWVDbGFzc2VzIiwidyIsIndyYXBwZXJDbGFzcyIsIm4iLCJuZWVkc05hdmlnYXRpb24iLCJiIiwibmVlZHNTY3JvbGxiYXIiLCJuZWVkc1BhZ2luYXRpb24iLCJlIiwiZXh0ZW5kIiwidXBkYXRlU3dpcGVyIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiaXNDaGlsZFN3aXBlclNsaWRlIiwiY2hpbGQiLCJ0eXBlIiwiZGlzcGxheU5hbWUiLCJpbmNsdWRlcyIsInByb2Nlc3NDaGlsZHJlbiIsImMiLCJzbGlkZXMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJmb3JFYWNoIiwicHVzaCIsInByb3BzIiwiY2hpbGRyZW4iLCJzbGlkZSIsImdldENoaWxkcmVuIiwic2xvdHMiLCJzbG90IiwiZm91bmRTbGlkZXMiLCJyZW5kZXJWaXJ0dWFsIiwic3dpcGVyIiwidmlydHVhbERhdGEiLCJnZXRTbGlkZUluZGV4IiwiaW5kZXgiLCJzbGlkZUluZGV4Iiwic3R5bGUiLCJpc0hvcml6b250YWwiLCJydGxUcmFuc2xhdGUiLCJvZmZzZXQiLCJ0b3AiLCJmcm9tIiwidG8iLCJsb29wRnJvbSIsInBhcmFtcyIsImxvb3AiLCJsb29wVG8iLCJzbGlkZXNUb1JlbmRlciIsIm1hcCIsImNsb25lRWxlbWVudCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJjYWxsYmFjayIsImRlcHMiLCJTd2lwZXJTbGlkZUNvbnRleHQiLCJ1c2VTd2lwZXJTbGlkZSIsIlN3aXBlckNvbnRleHQiLCJ1c2VTd2lwZXIiLCJTd2lwZXIiLCJfdGVtcCIsImV4dGVybmFsRWxSZWYiLCJjbGFzc05hbWUiLCJ0YWciLCJUYWciLCJ3cmFwcGVyVGFnIiwiV3JhcHBlclRhZyIsIm9uU3dpcGVyIiwicmVzdCIsImV2ZW50c0Fzc2lnbmVkIiwiY29udGFpbmVyQ2xhc3NlcyIsInNldENvbnRhaW5lckNsYXNzZXMiLCJzZXRWaXJ0dWFsRGF0YSIsImJyZWFrcG9pbnRDaGFuZ2VkIiwic2V0QnJlYWtwb2ludENoYW5nZWQiLCJpbml0aWFsaXplZFJlZiIsInN3aXBlckVsUmVmIiwic3dpcGVyUmVmIiwib2xkUGFzc2VkUGFyYW1zUmVmIiwib2xkU2xpZGVzIiwibmV4dEVsUmVmIiwicHJldkVsUmVmIiwicGFnaW5hdGlvbkVsUmVmIiwic2Nyb2xsYmFyRWxSZWYiLCJzd2lwZXJQYXJhbXMiLCJwYXNzZWRQYXJhbXMiLCJyZXN0UHJvcHMiLCJldmVudHMiLCJvbkJlZm9yZUJyZWFrcG9pbnQiLCJvbiIsIl9jb250YWluZXJDbGFzc2VzIiwiY2xhc3NlcyIsImluaXRTd2lwZXIiLCJwYXNzUGFyYW1zIiwiY3VycmVudCIsInZpcnR1YWwiLCJlbmFibGVkIiwiZXh0ZW5kV2l0aCIsImNhY2hlIiwicmVuZGVyRXh0ZXJuYWwiLCJyZW5kZXJFeHRlcm5hbFVwZGF0ZSIsIm9yaWdpbmFsUGFyYW1zIiwiYXR0YWNoRXZlbnRzIiwia2V5cyIsImV2ZW50TmFtZSIsImRldGFjaEV2ZW50cyIsIm9mZiIsImVtaXRTbGlkZXNDbGFzc2VzIiwiZGVzdHJveWVkIiwiZWwiLCJuZXh0RWwiLCJwcmV2RWwiLCJwYWdpbmF0aW9uRWwiLCJzY3JvbGxiYXJFbCIsImRlc3Ryb3kiLCJjaGFuZ2VkUGFyYW1zIiwicmVuZGVyU2xpZGVzIiwic3dpcGVyU2xpZGVJbmRleCIsImNyZWF0ZUVsZW1lbnQiLCJyZWYiLCJQcm92aWRlciIsInZhbHVlIiwiRnJhZ21lbnQiLCJTd2lwZXJTbGlkZSIsImV4dGVybmFsUmVmIiwiem9vbSIsImxhenkiLCJ2aXJ0dWFsSW5kZXgiLCJzbGlkZUVsUmVmIiwic2xpZGVDbGFzc2VzIiwic2V0U2xpZGVDbGFzc2VzIiwibGF6eUxvYWRlZCIsInNldExhenlMb2FkZWQiLCJ1cGRhdGVDbGFzc2VzIiwiX3MiLCJjbGFzc05hbWVzIiwiZ2V0U2xpZGVDbGFzc2VzIiwic2xpZGVEYXRhIiwiaXNBY3RpdmUiLCJpbmRleE9mIiwiaXNWaXNpYmxlIiwiaXNQcmV2IiwiaXNOZXh0IiwicmVuZGVyQ2hpbGRyZW4iLCJvbkxvYWQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/swiper-react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swiper/swiper.mjs":
/*!****************************************!*\
  !*** ./node_modules/swiper/swiper.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swiper: () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   \"default\": () => (/* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S)\n/* harmony export */ });\n/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ \"(ssr)/./node_modules/swiper/shared/swiper-core.mjs\");\n/**\n * Swiper 11.0.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: November 22, 2023\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dpcGVyL3N3aXBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Q0FVQyxHQUVvRSIsInNvdXJjZXMiOlsid2VicGFjazovL2RpYWdvbmFscy8uL25vZGVfbW9kdWxlcy9zd2lwZXIvc3dpcGVyLm1qcz8zZTUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3dpcGVyIDExLjAuNVxuICogTW9zdCBtb2Rlcm4gbW9iaWxlIHRvdWNoIHNsaWRlciBhbmQgZnJhbWV3b3JrIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgdHJhbnNpdGlvbnNcbiAqIGh0dHBzOi8vc3dpcGVyanMuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMTQtMjAyMyBWbGFkaW1pciBLaGFybGFtcGlkaVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIFJlbGVhc2VkIG9uOiBOb3ZlbWJlciAyMiwgMjAyM1xuICovXG5cbmV4cG9ydCB7IFMgYXMgU3dpcGVyLCBTIGFzIGRlZmF1bHQgfSBmcm9tICcuL3NoYXJlZC9zd2lwZXItY29yZS5tanMnO1xuIl0sIm5hbWVzIjpbIlMiLCJTd2lwZXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swiper/swiper.mjs\n");

/***/ })

};
;